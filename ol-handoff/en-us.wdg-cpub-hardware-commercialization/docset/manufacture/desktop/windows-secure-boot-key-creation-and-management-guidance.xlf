<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationtype">Human Translation</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">docset\manufacture\desktop\windows-secure-boot-key-creation-and-management-guidance.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">2a475a3b8ab9b913069becce668bcd70c8a5c6a5</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-48076a9</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Windows Secure Boot Key Creation and Management Guidance</source>
          <target>Windows Secure Boot Key Creation and Management Guidance</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Windows Secure Boot Key Creation and Management Guidance</source>
          <target>Windows Secure Boot Key Creation and Management Guidance</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Windows Secure Boot Key Creation and Management Guidance</source>
          <target>Windows Secure Boot Key Creation and Management Guidance</target>
        </segment>
      </unit>
      <unit id="104">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&lt;</data>
          <data id="id4">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Vishal Manan, Architect, OEM Consulting</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">vmanan@microsoft.com</pc></source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Vishal Manan, Architect, OEM Consulting</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">vmanan@microsoft.com</pc></target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&lt;</data>
          <data id="id4">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Arie van der Hoeven, Architect, OEM Consulting</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ariev@microsoft.com</pc></source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Arie van der Hoeven, Architect, OEM Consulting</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ariev@microsoft.com</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>This document helps guide OEMs and ODMs in creation and management of the Secure Boot keys and certificates in a manufacturing environment.</source>
          <target>This document helps guide OEMs and ODMs in creation and management of the Secure Boot keys and certificates in a manufacturing environment.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>It addresses questions related to creation, storage and retrieval of Platform Keys (PKs), secure firmware update keys, and third party Key Exchange Keys (KEKs).</source>
          <target>It addresses questions related to creation, storage and retrieval of Platform Keys (PKs), secure firmware update keys, and third party Key Exchange Keys (KEKs).</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=320504)</data>
        </originalData>
        <segment state="initial">
          <source>Windows requirements for UEFI and Secure Boot can be found in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Hardware Certification Requirements</pc> and other documents made available through sources such as Windows Connect and MSDN.</source>
          <target>Windows requirements for UEFI and Secure Boot can be found in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Hardware Certification Requirements</pc> and other documents made available through sources such as Windows Connect and MSDN.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>This paper does not introduce new requirements or represent an official Windows program.</source>
          <target>This paper does not introduce new requirements or represent an official Windows program.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>It is intended as guidance beyond certification requirements, to assist in building efficient and secure processes for creating and managing Secure Boot Keys.</source>
          <target>It is intended as guidance beyond certification requirements, to assist in building efficient and secure processes for creating and managing Secure Boot Keys.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>This is important because UEFI Secure Boot is based on the usage of Private Key Infrastructure to authenticate code before allowed to execute.</source>
          <target>This is important because UEFI Secure Boot is based on the usage of Private Key Infrastructure to authenticate code before allowed to execute.</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
        </originalData>
        <segment state="initial">
          <source>The reader is expected to know the fundamentals of UEFI, basic understanding of Secure Boot (Chapter 27 of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc>), and PKI security model.</source>
          <target>The reader is expected to know the fundamentals of UEFI, basic understanding of Secure Boot (Chapter 27 of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc>), and PKI security model.</target>
        </segment>
      </unit>
      <unit id="113">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=254893)</data>
        </originalData>
        <segment state="initial">
          <source>Requirements, tests, and tools validating Secure Boot on Windows are available today through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Hardware Certification Kit (HCK)</pc>.</source>
          <target>Requirements, tests, and tools validating Secure Boot on Windows are available today through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Hardware Certification Kit (HCK)</pc>.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>However, these HCK resources do not address creation and management of keys for Windows deployments.</source>
          <target>However, these HCK resources do not address creation and management of keys for Windows deployments.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>This paper addresses key management as a resource to help guide partners through deployment of the keys used by the firmware.</source>
          <target>This paper addresses key management as a resource to help guide partners through deployment of the keys used by the firmware.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>It is not intended as prescriptive guidance and does not include any new requirements.</source>
          <target>It is not intended as prescriptive guidance and does not include any new requirements.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>On this page:</source>
          <target>On this page:</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#securebootkeymanagement)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1. Secure Boot, Windows and Key Management</pc> contains information on boot security and PKI architecture as it applies to Windows and Secure Boot.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1. Secure Boot, Windows and Key Management</pc> contains information on boot security and PKI architecture as it applies to Windows and Secure Boot.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#keymanagementsolutions)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">2. Key Management Solutions</pc> is intended to help partners design a key management and design solution that fits their needs.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">2. Key Management Solutions</pc> is intended to help partners design a key management and design solution that fits their needs.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#summaryandresources)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">3. Summary and Resources</pc> includes appendices, checklists, APIs, and other references.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">3. Summary and Resources</pc> includes appendices, checklists, APIs, and other references.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>This document serves as a starting point in developing customer ready PCs, factory deployment tools and key security best practices.</source>
          <target>This document serves as a starting point in developing customer ready PCs, factory deployment tools and key security best practices.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>1. Secure Boot, Windows and Key Management</source>
          <target>1. Secure Boot, Windows and Key Management</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>The UEFI (Unified Extensible Firmware Interface) specification defines a firmware execution authentication process called Secure Boot.</source>
          <target>The UEFI (Unified Extensible Firmware Interface) specification defines a firmware execution authentication process called Secure Boot.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>As an industry standard, Secure Boot defines how platform firmware manages certificates, authenticates firmware, and how the operating system interfaces with this process.</source>
          <target>As an industry standard, Secure Boot defines how platform firmware manages certificates, authenticates firmware, and how the operating system interfaces with this process.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>Secure Boot is based on the Public Key Infrastructure (PKI) process to authenticate modules before they are allowed to execute.</source>
          <target>Secure Boot is based on the Public Key Infrastructure (PKI) process to authenticate modules before they are allowed to execute.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>These modules can include firmware drivers, option ROMs, UEFI drivers on disk, UEFI applications, or UEFI boot loaders.</source>
          <target>These modules can include firmware drivers, option ROMs, UEFI drivers on disk, UEFI applications, or UEFI boot loaders.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>Through image authentication before execution, Secure Boot reduces the risk of pre-boot malware attacks such as rootkits.</source>
          <target>Through image authentication before execution, Secure Boot reduces the risk of pre-boot malware attacks such as rootkits.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Microsoft relies on UEFI Secure Boot in Windows 10, Windows 8.1 and Windows 8 as part of its Trusted Boot security architecture to improve platform security for our customers.</source>
          <target>Microsoft relies on UEFI Secure Boot in Windows 10, Windows 8.1 and Windows 8 as part of its Trusted Boot security architecture to improve platform security for our customers.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>Secure Boot is required for Windows 10, Windows 8.1 and Windows 8 client PCs as defined in the Windows Hardware Certification Requirements.</source>
          <target>Secure Boot is required for Windows 10, Windows 8.1 and Windows 8 client PCs as defined in the Windows Hardware Certification Requirements.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>The Secure Boot process works as follows and as shown in Figure 1:</source>
          <target>The Secure Boot process works as follows and as shown in Figure 1:</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Firmware Boot Components:</pc> The firmware verifies the OS loader is trusted (Windows or another trusted operating system.)</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Firmware Boot Components:</pc> The firmware verifies the OS loader is trusted (Windows or another trusted operating system.)</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Windows boot components: BootMgr, WinLoad, Windows Kernel Startup.</source>
          <target>Windows boot components: BootMgr, WinLoad, Windows Kernel Startup.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Windows boot components verify the signature on each component.</source>
          <target>Windows boot components verify the signature on each component.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Any non-trusted components will not be loaded and instead will trigger Secure Boot remediation.</source>
          <target>Any non-trusted components will not be loaded and instead will trigger Secure Boot remediation.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Antivirus and Antimalware Software initialization:</pc> This software is checked for a special signature issued by Microsoft verifying that it is a trusted boot critical driver, and will launch early in the boot process.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Antivirus and Antimalware Software initialization:</pc> This software is checked for a special signature issued by Microsoft verifying that it is a trusted boot critical driver, and will launch early in the boot process.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Boot Critical Driver initialization:</pc> The signatures on all Boot-critical drivers are checked as part of Secure Boot verification in WinLoad.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Boot Critical Driver initialization:</pc> The signatures on all Boot-critical drivers are checked as part of Secure Boot verification in WinLoad.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Additional OS Initialization</source>
          <target>Additional OS Initialization</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Windows Logon Screen</source>
          <target>Windows Logon Screen</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>image of platform integrity architecture</source>
          <target>image of platform integrity architecture</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>Figure 1: Windows Trusted Boot Architecture</source>
          <target>Figure 1: Windows Trusted Boot Architecture</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Implementation of UEFI Secure Boot is part of Microsoft’s Trusted Boot Architecture, introduced in Windows 8.1.</source>
          <target>Implementation of UEFI Secure Boot is part of Microsoft’s Trusted Boot Architecture, introduced in Windows 8.1.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>A growing trend in the evolution of malware exploits is targeting the boot path as a preferred attack vector.</source>
          <target>A growing trend in the evolution of malware exploits is targeting the boot path as a preferred attack vector.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>This class of attack has been difficult to guard against, since antimalware products can be disabled by malicious software that prevents them from loading entirely.</source>
          <target>This class of attack has been difficult to guard against, since antimalware products can be disabled by malicious software that prevents them from loading entirely.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>With Windows Trusted Boot architecture and its establishment of a root of trust with Secure Boot, the customer is protected from malicious code executing in the boot path by ensuring that only signed, certified “known good” code and boot loaders can execute before the operating system itself loads.</source>
          <target>With Windows Trusted Boot architecture and its establishment of a root of trust with Secure Boot, the customer is protected from malicious code executing in the boot path by ensuring that only signed, certified “known good” code and boot loaders can execute before the operating system itself loads.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>1.1 Public-Key Infrastructure (PKI) and Secure Boot</source>
          <target>1.1 Public-Key Infrastructure (PKI) and Secure Boot</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>The PKI establishes authenticity and trust in a system.</source>
          <target>The PKI establishes authenticity and trust in a system.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>Secure Boot leverages PKI for two high-level purposes:</source>
          <target>Secure Boot leverages PKI for two high-level purposes:</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>During boot to determine if early boot modules are trusted for execution.</source>
          <target>During boot to determine if early boot modules are trusted for execution.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>To authenticate requests to service requests include modification of Secure Boot databases and updates to platform firmware.</source>
          <target>To authenticate requests to service requests include modification of Secure Boot databases and updates to platform firmware.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>A PKI consists of:</source>
          <target>A PKI consists of:</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>A certificate authority (CA) that issues the digital certificates.</source>
          <target>A certificate authority (CA) that issues the digital certificates.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>A registration authority which verifies the identity of users requesting a certificate from the CA.</source>
          <target>A registration authority which verifies the identity of users requesting a certificate from the CA.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>A central directory in which to store and index keys.</source>
          <target>A central directory in which to store and index keys.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>A certificate management system.</source>
          <target>A certificate management system.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>1.2 Public Key Cryptography</source>
          <target>1.2 Public Key Cryptography</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>Public key cryptography uses a pair of mathematically related cryptographic keys, known as the public and private key.</source>
          <target>Public key cryptography uses a pair of mathematically related cryptographic keys, known as the public and private key.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>If you know one of the keys, you cannot easily calculate what the other one is.</source>
          <target>If you know one of the keys, you cannot easily calculate what the other one is.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>If one key is used to encrypt information, then only the corresponding key can decrypt that information.</source>
          <target>If one key is used to encrypt information, then only the corresponding key can decrypt that information.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>For Secure Boot, the private key is used to digitally sign code and the public key is used to verify the signature on that code to prove its authenticity.</source>
          <target>For Secure Boot, the private key is used to digitally sign code and the public key is used to verify the signature on that code to prove its authenticity.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>If a private key is compromised, then systems with corresponding public keys are no longer secure.</source>
          <target>If a private key is compromised, then systems with corresponding public keys are no longer secure.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>This can lead to boot kit attacks and will damage the reputation of the entity responsible for ensuring the security of the private key.</source>
          <target>This can lead to boot kit attacks and will damage the reputation of the entity responsible for ensuring the security of the private key.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>In a Secure Boot public key system you have the following:</source>
          <target>In a Secure Boot public key system you have the following:</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>1.2.1 RSA 2048 Encryption</source>
          <target>1.2.1 RSA 2048 Encryption</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>RSA-2048 is an asymmetric cryptographic algorithm.</source>
          <target>RSA-2048 is an asymmetric cryptographic algorithm.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>The space needed to store an RSA-2048 modulus in raw form is 2048 bits.</source>
          <target>The space needed to store an RSA-2048 modulus in raw form is 2048 bits.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>1.2.2 Self-signed certificate</source>
          <target>1.2.2 Self-signed certificate</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>A certificate signed by the private key that matches the public key of the certificate is known as a self-signed certificate.</source>
          <target>A certificate signed by the private key that matches the public key of the certificate is known as a self-signed certificate.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Root certification authority (CA) certificates fall into this category.</source>
          <target>Root certification authority (CA) certificates fall into this category.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>1.2.3 Certification Authority</source>
          <target>1.2.3 Certification Authority</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>The certification authority (CA) issues signed certificates that affirm the identity of the certificate subject and bind that identity to the public key contained in the certificate.</source>
          <target>The certification authority (CA) issues signed certificates that affirm the identity of the certificate subject and bind that identity to the public key contained in the certificate.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>The CA signs the certificate by using its private key.</source>
          <target>The CA signs the certificate by using its private key.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>It issues the corresponding public key to all interested parties in a self-signed root CA certificate.</source>
          <target>It issues the corresponding public key to all interested parties in a self-signed root CA certificate.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>In Secure Boot, Certification Authorities (CAs) include the OEM (or their delegates) and Microsoft.</source>
          <target>In Secure Boot, Certification Authorities (CAs) include the OEM (or their delegates) and Microsoft.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>The CAs generate the key pairs that form the root of trust and then use the private keys to sign legitimate operations such as allowed early boot EFI modules and firmware servicing requests.</source>
          <target>The CAs generate the key pairs that form the root of trust and then use the private keys to sign legitimate operations such as allowed early boot EFI modules and firmware servicing requests.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>The corresponding public keys are shipped embedded into the UEFI firmware on Secure Boot-enabled PCs and are used to verify these operations.</source>
          <target>The corresponding public keys are shipped embedded into the UEFI firmware on Secure Boot-enabled PCs and are used to verify these operations.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>(More information on usage of CAs and key exchanges is readily available on the internet which relates to the Secure Boot model.)</source>
          <target>(More information on usage of CAs and key exchanges is readily available on the internet which relates to the Secure Boot model.)</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>1.2.4 Public Key</source>
          <target>1.2.4 Public Key</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>The public Platform Key ships on the PC and is accessible or “public”.</source>
          <target>The public Platform Key ships on the PC and is accessible or “public”.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>In this document we will use the suffix “pub” to denote public key.</source>
          <target>In this document we will use the suffix “pub” to denote public key.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>For example, PKpub denotes the public half of the PK.</source>
          <target>For example, PKpub denotes the public half of the PK.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>1.2.5 Private Key</source>
          <target>1.2.5 Private Key</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>For PKI to work the private key needs to be securely managed.</source>
          <target>For PKI to work the private key needs to be securely managed.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>It should be accessible to a few highly trusted individuals in an organization and located in a physically secure location with strong access policy restrictions in place.</source>
          <target>It should be accessible to a few highly trusted individuals in an organization and located in a physically secure location with strong access policy restrictions in place.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>In this document we will use the suffix “priv” to denote private key.</source>
          <target>In this document we will use the suffix “priv” to denote private key.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>For example, the PKpriv indicates private half of the PK.</source>
          <target>For example, the PKpriv indicates private half of the PK.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>1.2.6 Certificates</source>
          <target>1.2.6 Certificates</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>The primary use for digital certificates is to verify the origin of signed data, such as binaries etc. A common use of certificates is for internet message security using Transport Layer Security (TLS) or Secure Sockets Layer (SSL).</source>
          <target>The primary use for digital certificates is to verify the origin of signed data, such as binaries etc. A common use of certificates is for internet message security using Transport Layer Security (TLS) or Secure Sockets Layer (SSL).</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>Verifying the signed data with a certificate lets the recipient know the origin of the data and if it has been altered in transit.</source>
          <target>Verifying the signed data with a certificate lets the recipient know the origin of the data and if it has been altered in transit.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>A digital certificate in general contains, at a high level, a distinguished name (DN), a public key, and a signature.</source>
          <target>A digital certificate in general contains, at a high level, a distinguished name (DN), a public key, and a signature.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>The DN identifies an entity -- a company, for example -- that holds the private key that matches the public key of the certificate.</source>
          <target>The DN identifies an entity -- a company, for example -- that holds the private key that matches the public key of the certificate.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>Signing the certificate with a private key and placing the signature in the certificate ties the private key to the public key.</source>
          <target>Signing the certificate with a private key and placing the signature in the certificate ties the private key to the public key.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>Certificates can contain some other types of data.</source>
          <target>Certificates can contain some other types of data.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>For example, an X.509 certificate includes the format of the certificate, the serial number of the certificate, the algorithm used to sign the certificate, the name of the CA that issued the certificate, the name and public key of the entity requesting the certificate, and the CA's signature.</source>
          <target>For example, an X.509 certificate includes the format of the certificate, the serial number of the certificate, the algorithm used to sign the certificate, the name of the CA that issued the certificate, the name and public key of the entity requesting the certificate, and the CA's signature.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>1.2.7 Chaining certificates</source>
          <target>1.2.7 Chaining certificates</target>
        </segment>
      </unit>
      <unit id="195">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=321183)</data>
        </originalData>
        <segment state="initial">
          <source>From: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Certificate chains</pc>:</source>
          <target>From: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Certificate chains</pc>:</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>root ca is self-signed, others signed by root ca</source>
          <target>root ca is self-signed, others signed by root ca</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>Figure 2: Three-certificate chain</source>
          <target>Figure 2: Three-certificate chain</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>User certificates are often signed by a different private key, such as a private key of the CA.</source>
          <target>User certificates are often signed by a different private key, such as a private key of the CA.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>This constitutes a two-certificate chain.</source>
          <target>This constitutes a two-certificate chain.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>Verifying that a user certificate is genuine involves verifying its signature, which requires the public key of the CA, from its certificate.</source>
          <target>Verifying that a user certificate is genuine involves verifying its signature, which requires the public key of the CA, from its certificate.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>But before the public key of the CA can be used, the enclosing CA certificate needs to be verified.</source>
          <target>But before the public key of the CA can be used, the enclosing CA certificate needs to be verified.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>Because the CA certificate is self-signed, the CA public key is used to verify the certificate.</source>
          <target>Because the CA certificate is self-signed, the CA public key is used to verify the certificate.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>A user certificate need not be signed by the private key of the root CA.</source>
          <target>A user certificate need not be signed by the private key of the root CA.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>It could be signed by the private key of an intermediary whose certificate is signed by the private key of the CA.</source>
          <target>It could be signed by the private key of an intermediary whose certificate is signed by the private key of the CA.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>This is an instance of a three-certificate chain: user certificate, intermediary certificate, and CA certificate.</source>
          <target>This is an instance of a three-certificate chain: user certificate, intermediary certificate, and CA certificate.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>But more than one intermediary can be part of the chain, so certificate chains can be of any length.</source>
          <target>But more than one intermediary can be part of the chain, so certificate chains can be of any length.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>1.3 Secure Boot PKI requirements</source>
          <target>1.3 Secure Boot PKI requirements</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>The UEFI-defined root of trust consists of the Platform Key and any keys an OEM or ODM includes in the firmware core.</source>
          <target>The UEFI-defined root of trust consists of the Platform Key and any keys an OEM or ODM includes in the firmware core.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>Pre-UEFI security and a root of trust are not addressed by the UEFI Secure Boot process, but instead by National Institute of Standards and Technology (NIST), and Trusted Computing Group (TCG) publications referenced in this paper.</source>
          <target>Pre-UEFI security and a root of trust are not addressed by the UEFI Secure Boot process, but instead by National Institute of Standards and Technology (NIST), and Trusted Computing Group (TCG) publications referenced in this paper.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>1.3.1 Secure Boot requirements</source>
          <target>1.3.1 Secure Boot requirements</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>You’ll need to consider the following parameters for implementing Secure Boot:</source>
          <target>You’ll need to consider the following parameters for implementing Secure Boot:</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>Customer requirements</source>
          <target>Customer requirements</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>Windows HCK requirements</source>
          <target>Windows HCK requirements</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>Key generation and management requirements.</source>
          <target>Key generation and management requirements.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>You would need to pick hardware for Secure Boot key management like Hardware Security Modules (HSMs), consider special requirements on PCs to ship to governments and other agencies and finally the process of creating, populating and managing the life cycle of various Secure Boot keys.</source>
          <target>You would need to pick hardware for Secure Boot key management like Hardware Security Modules (HSMs), consider special requirements on PCs to ship to governments and other agencies and finally the process of creating, populating and managing the life cycle of various Secure Boot keys.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>1.3.2 Secure Boot related keys</source>
          <target>1.3.2 Secure Boot related keys</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>The keys used for Secure Boot are below:</source>
          <target>The keys used for Secure Boot are below:</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>pk, kek, db, dbx, and firmware key, winrt key</source>
          <target>pk, kek, db, dbx, and firmware key, winrt key</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>Figure 3: Keys related to Secure Boot</source>
          <target>Figure 3: Keys related to Secure Boot</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>Figure 3 above represents the signatures and keys in a PC with Secure Boot.</source>
          <target>Figure 3 above represents the signatures and keys in a PC with Secure Boot.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>The platform is secured through a platform key that the OEM installs in firmware during manufacturing.</source>
          <target>The platform is secured through a platform key that the OEM installs in firmware during manufacturing.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>Other keys are used by Secure Boot to protect access to databases that store keys to allow or disallow execution of firmware.</source>
          <target>Other keys are used by Secure Boot to protect access to databases that store keys to allow or disallow execution of firmware.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>The authorized database (db) contains public keys and certificates that represent trusted firmware components and operating system loaders.</source>
          <target>The authorized database (db) contains public keys and certificates that represent trusted firmware components and operating system loaders.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>The forbidden signature database (dbx) contains hashes of malicious and vulnerable components as well as compromised keys and certificates and blocks execution of those malicious components.</source>
          <target>The forbidden signature database (dbx) contains hashes of malicious and vulnerable components as well as compromised keys and certificates and blocks execution of those malicious components.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>The strength of these policies is based on signing firmware using Authenticode and Public Key Infrastructure (PKI).</source>
          <target>The strength of these policies is based on signing firmware using Authenticode and Public Key Infrastructure (PKI).</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>PKI is a well-established process for creating, managing, and revoking certificates that establish trust during information exchange.</source>
          <target>PKI is a well-established process for creating, managing, and revoking certificates that establish trust during information exchange.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>PKI is at the core of the security model for Secure Boot.</source>
          <target>PKI is at the core of the security model for Secure Boot.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>Below are more details on these keys.</source>
          <target>Below are more details on these keys.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>1.3.3 Platform Key (PK)</source>
          <target>1.3.3 Platform Key (PK)</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>As per section 27.5.1 of the UEFI 2.3.1 Errata C, the platform key establishes a trust relationship between the platform owner and the platform firmware.</source>
          <target>As per section 27.5.1 of the UEFI 2.3.1 Errata C, the platform key establishes a trust relationship between the platform owner and the platform firmware.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The platform owner enrolls the public half of the key (PKpub) into the platform firmware as specified in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Section 7.2.1 of the UEFI 2.3.1 Errata C</pc>. This step moves the platform into user mode from setup mode.</source>
          <target>The platform owner enrolls the public half of the key (PKpub) into the platform firmware as specified in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Section 7.2.1 of the UEFI 2.3.1 Errata C</pc>. This step moves the platform into user mode from setup mode.</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
        </originalData>
        <segment state="initial">
          <source>Microsoft recommends that the Platform Key be of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc> with public key algorithm RSA, public key length of 2048 bits, and signature algorithm sha256RSA.</source>
          <target>Microsoft recommends that the Platform Key be of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc> with public key algorithm RSA, public key length of 2048 bits, and signature algorithm sha256RSA.</target>
        </segment>
      </unit>
      <unit id="233">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
        </originalData>
        <segment state="initial">
          <source>The platform owner may use type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />RSA2048<ph dataRef="id5" id="ph3" />GUID</pc> if storage space is a concern.</source>
          <target>The platform owner may use type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />RSA2048<ph dataRef="id5" id="ph3" />GUID</pc> if storage space is a concern.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>Public keys are used to check signatures as described earlier in this document.</source>
          <target>Public keys are used to check signatures as described earlier in this document.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>The platform owner can later use the private half of the key (PKpriv):</source>
          <target>The platform owner can later use the private half of the key (PKpriv):</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>To change platform ownership you must put the firmware into UEFI defined <pc dataRefEnd="id2" dataRefStart="id1" id="p1">setup mode</pc> which disables Secure Boot.</source>
          <target>To change platform ownership you must put the firmware into UEFI defined <pc dataRefEnd="id2" dataRefStart="id1" id="p1">setup mode</pc> which disables Secure Boot.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>We recommend reverting to setup mode only if there is a need to do this during manufacturing.</source>
          <target>We recommend reverting to setup mode only if there is a need to do this during manufacturing.</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>1.3.3.1 To enroll or update a Key Exchange Key (KEK) Enrolling the Platform Key</source>
          <target>1.3.3.1 To enroll or update a Key Exchange Key (KEK) Enrolling the Platform Key</target>
        </segment>
      </unit>
      <unit id="239">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The platform owner enrolls the public half of the Platform Key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc>) by calling the UEFI Boot Service SetVariable() as specified in Section 7.2.1 and resetting the platform.</source>
          <target>The platform owner enrolls the public half of the Platform Key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc>) by calling the UEFI Boot Service SetVariable() as specified in Section 7.2.1 and resetting the platform.</target>
        </segment>
      </unit>
      <unit id="240">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If the platform is in setup mode, then the new <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc> shall be signed with its <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PKpriv</pc> counterpart.</source>
          <target>If the platform is in setup mode, then the new <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc> shall be signed with its <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PKpriv</pc> counterpart.</target>
        </segment>
      </unit>
      <unit id="241">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If the platform is in user mode, then the new <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc> must be signed with the current <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PKpriv</pc>.</source>
          <target>If the platform is in user mode, then the new <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc> must be signed with the current <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PKpriv</pc>.</target>
        </segment>
      </unit>
      <unit id="242">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
        </originalData>
        <segment state="initial">
          <source>If the PK is of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc>, then this must be signed by the immediate <pc dataRefEnd="id7" dataRefStart="id6" id="p2">PKpriv</pc>, not a private key of any certificate issued under the PK.</source>
          <target>If the PK is of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc>, then this must be signed by the immediate <pc dataRefEnd="id7" dataRefStart="id6" id="p2">PKpriv</pc>, not a private key of any certificate issued under the PK.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>1.3.3.2 Clearing the Platform Key</source>
          <target>1.3.3.2 Clearing the Platform Key</target>
        </segment>
      </unit>
      <unit id="244">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The platform owner clears the public half of the Platform Key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc>) by calling the UEFI Boot Ser¬vice SetVariable() with a variable size of 0 and resetting the platform.</source>
          <target>The platform owner clears the public half of the Platform Key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpub</pc>) by calling the UEFI Boot Ser¬vice SetVariable() with a variable size of 0 and resetting the platform.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>If the platform is in setup mode, then the empty variable does not need to be authenticated.</source>
          <target>If the platform is in setup mode, then the empty variable does not need to be authenticated.</target>
        </segment>
      </unit>
      <unit id="246">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
        </originalData>
        <segment state="initial">
          <source>If the platform is in user mode, then the empty variable must be signed with the current <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpriv</pc>; see Section 7.2(Variable Services) under <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UEFI specification</pc> 2.3.1 Errata C for details.</source>
          <target>If the platform is in user mode, then the empty variable must be signed with the current <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PKpriv</pc>; see Section 7.2(Variable Services) under <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UEFI specification</pc> 2.3.1 Errata C for details.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>It is strongly recommended that the production PKpriv never be used to sign a package to reset the platform since this allows Secure Boot to be disabled.</source>
          <target>It is strongly recommended that the production PKpriv never be used to sign a package to reset the platform since this allows Secure Boot to be disabled.</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>This is primarily a pre-production test scenario.</source>
          <target>This is primarily a pre-production test scenario.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>The platform key may also be cleared using a secure platform-specific method.</source>
          <target>The platform key may also be cleared using a secure platform-specific method.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>In this case, the global variable Setup Mode must also be updated to 1.</source>
          <target>In this case, the global variable Setup Mode must also be updated to 1.</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>image: pk determines setup mode or user mode</source>
          <target>image: pk determines setup mode or user mode</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source>Figure 4: Platform Key State diagram</source>
          <target>Figure 4: Platform Key State diagram</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>1.3.3.3 PK generation</source>
          <target>1.3.3.3 PK generation</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>As per UEFI recommendations, the public key must be stored in non-volatile storage which is tamper and delete resistant on the PC.</source>
          <target>As per UEFI recommendations, the public key must be stored in non-volatile storage which is tamper and delete resistant on the PC.</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source>The Private keys stay secure at Partner or in the OEM’s Security Office and only the public key is loaded onto the platform.</source>
          <target>The Private keys stay secure at Partner or in the OEM’s Security Office and only the public key is loaded onto the platform.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source>There are more details under section 2.2.1 and 2.3.</source>
          <target>There are more details under section 2.2.1 and 2.3.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>The number of PK generated is at the discretion of the Platform owner (OEM).</source>
          <target>The number of PK generated is at the discretion of the Platform owner (OEM).</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>These keys could be:</source>
          <target>These keys could be:</target>
        </segment>
      </unit>
      <unit id="259">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per PC</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per PC</pc>.</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>This may be required for government agencies, financial institutions, or other customers with high-security needs.</source>
          <target>This may be required for government agencies, financial institutions, or other customers with high-security needs.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>It may require additional storage and crypto processing power to generate private and public keys for large numbers of PCs.</source>
          <target>It may require additional storage and crypto processing power to generate private and public keys for large numbers of PCs.</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source>There are a few different HSM solutions available to manage large number of keys based on the HSM vendor.</source>
          <target>There are a few different HSM solutions available to manage large number of keys based on the HSM vendor.</target>
        </segment>
      </unit>
      <unit id="263">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=321184)</data>
        </originalData>
        <segment state="initial">
          <source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure Boot Key Generation Using HSM</pc>.</source>
          <target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure Boot Key Generation Using HSM</pc>.</target>
        </segment>
      </unit>
      <unit id="264">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per model</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per model</pc>.</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>The tradeoff here is that if a key is compromised all the machines within the same model would be vulnerable.</source>
          <target>The tradeoff here is that if a key is compromised all the machines within the same model would be vulnerable.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per product line</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per product line</pc>.</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source>If a key is compromised a whole product line would be vulnerable.</source>
          <target>If a key is compromised a whole product line would be vulnerable.</target>
        </segment>
      </unit>
      <unit id="268">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per OEM</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">One per OEM</pc>.</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>While this may be the simplest to set up, if the key is compromised, every PC you manufacture would be vulnerable.</source>
          <target>While this may be the simplest to set up, if the key is compromised, every PC you manufacture would be vulnerable.</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>To speed up operation on the factory floor, the PK and potentially other keys could be pre-generated and stored in a safe location.</source>
          <target>To speed up operation on the factory floor, the PK and potentially other keys could be pre-generated and stored in a safe location.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>These could be later retrieved and used in the assembly line.</source>
          <target>These could be later retrieved and used in the assembly line.</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source>Chapters 2 and 3 have more details.</source>
          <target>Chapters 2 and 3 have more details.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source>1.3.3.4 Rekeying the PK</source>
          <target>1.3.3.4 Rekeying the PK</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>This may be needed if the PK gets compromised or as a requirement by a customer that for security reasons may decide to enroll their own PK.</source>
          <target>This may be needed if the PK gets compromised or as a requirement by a customer that for security reasons may decide to enroll their own PK.</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source>Rekeying could be done either for a model or PC based on what method was selected to create PK.</source>
          <target>Rekeying could be done either for a model or PC based on what method was selected to create PK.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>All the newer PCs will get signed with the newly created PK.</source>
          <target>All the newer PCs will get signed with the newly created PK.</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source>Updating the PK on a production PC would require either a variable update signed with the existing PK that replaces the PK or a firmware update package.</source>
          <target>Updating the PK on a production PC would require either a variable update signed with the existing PK that replaces the PK or a firmware update package.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>An OEM could also create a SetVariable() package and distribute that with a simple application such as PowerShell that just changes the PK.</source>
          <target>An OEM could also create a SetVariable() package and distribute that with a simple application such as PowerShell that just changes the PK.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source>The firmware update package would be signed by the secure firmware update key and verified by firmware.</source>
          <target>The firmware update package would be signed by the secure firmware update key and verified by firmware.</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source>If doing a firmware update to update the PK, care should be taken to ensure the KEK, db, and dbx are preserved.</source>
          <target>If doing a firmware update to update the PK, care should be taken to ensure the KEK, db, and dbx are preserved.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>On all PCs, it is recommended to not use the PK as the secure firmware update key.</source>
          <target>On all PCs, it is recommended to not use the PK as the secure firmware update key.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>If the PKpriv is compromised then so is the secure firmware update key (since they are the same).</source>
          <target>If the PKpriv is compromised then so is the secure firmware update key (since they are the same).</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source>In this case the update to enroll a new PKpub might not be possible since the process of updating has also been compromised.</source>
          <target>In this case the update to enroll a new PKpub might not be possible since the process of updating has also been compromised.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source>On SOCs PCs, there is another reason to not use the PK as the secure firmware update key.</source>
          <target>On SOCs PCs, there is another reason to not use the PK as the secure firmware update key.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>This is because the secure firmware update key is permanently burnt into fuses on PCs that meet Windows Hardware Certification requirements.</source>
          <target>This is because the secure firmware update key is permanently burnt into fuses on PCs that meet Windows Hardware Certification requirements.</target>
        </segment>
      </unit>
      <unit id="286">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.4 Key Exchange Key (KEK)</pc>Key exchange keys establish a trust relationship between the operating system and the platform firmware.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.4 Key Exchange Key (KEK)</pc>Key exchange keys establish a trust relationship between the operating system and the platform firmware.</target>
        </segment>
      </unit>
      <unit id="287">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Each operating system (and potentially, each 3rd party application which need to communicate with platform firmware) enrolls a public key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">KEKpub</pc>) into the platform firmware.</source>
          <target>Each operating system (and potentially, each 3rd party application which need to communicate with platform firmware) enrolls a public key (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">KEKpub</pc>) into the platform firmware.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source>1.3.4.1 Enrolling Key Exchange Keys</source>
          <target>1.3.4.1 Enrolling Key Exchange Keys</target>
        </segment>
      </unit>
      <unit id="289">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#signaturedatabase)</data>
        </originalData>
        <segment state="initial">
          <source>Key exchange keys are stored in a signature database as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4 Signature Databases (Db and Dbx)</pc>.</source>
          <target>Key exchange keys are stored in a signature database as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4 Signature Databases (Db and Dbx)</pc>.</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source>The signature database is stored as an authenticated UEFI variable.</source>
          <target>The signature database is stored as an authenticated UEFI variable.</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">[</data>
          <data id="id7">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
          <data id="id8">\_</data>
          <data id="id9">\_</data>
          <data id="id10">\_</data>
        </originalData>
        <segment state="initial">
          <source>The platform owner enrolls the key exchange keys by either calling SetVariable() as specified in Section 7.2(Variable Services) under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C. with the EFI<ph dataRef="id3" id="ph1" />VARIABLE<ph dataRef="id4" id="ph2" />APPEND<ph dataRef="id5" id="ph3" />WRITE attribute set and the Data parameter containing the new key(s), or by reading the database using GetVariable(), appending the new key exchange key to the existing keys and then writing the database using SetVariable()as specified in Section 7.2(Variable Services) under <pc dataRefEnd="id7" dataRefStart="id6" id="p2">UEFI specification</pc> 2.3.1 Errata C without the EFI<ph dataRef="id8" id="ph4" />VARIABLE<ph dataRef="id9" id="ph5" />APPEND<ph dataRef="id10" id="ph6" />WRITE attribute set.</source>
          <target>The platform owner enrolls the key exchange keys by either calling SetVariable() as specified in Section 7.2(Variable Services) under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C. with the EFI<ph dataRef="id3" id="ph1" />VARIABLE<ph dataRef="id4" id="ph2" />APPEND<ph dataRef="id5" id="ph3" />WRITE attribute set and the Data parameter containing the new key(s), or by reading the database using GetVariable(), appending the new key exchange key to the existing keys and then writing the database using SetVariable()as specified in Section 7.2(Variable Services) under <pc dataRefEnd="id7" dataRefStart="id6" id="p2">UEFI specification</pc> 2.3.1 Errata C without the EFI<ph dataRef="id8" id="ph4" />VARIABLE<ph dataRef="id9" id="ph5" />APPEND<ph dataRef="id10" id="ph6" />WRITE attribute set.</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>If the platform is in setup mode, the signature database variable does not need to be signed but the parameters to the SetVariable() call shall still be prepared as specified for authenticated variables in Section 7.2.1.</source>
          <target>If the platform is in setup mode, the signature database variable does not need to be signed but the parameters to the SetVariable() call shall still be prepared as specified for authenticated variables in Section 7.2.1.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>If the platform is in user mode, the signature database must be signed with the current PKpriv</source>
          <target>If the platform is in user mode, the signature database must be signed with the current PKpriv</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>1.3.4.2 Clearing the KEK</source>
          <target>1.3.4.2 Clearing the KEK</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source>It is possible to “clear” (delete) the KEK.</source>
          <target>It is possible to “clear” (delete) the KEK.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>Note that if the PK is not installed on the platform, “clear” requests are not required to be signed.</source>
          <target>Note that if the PK is not installed on the platform, “clear” requests are not required to be signed.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>If they are signed, then to clear the KEK requires a PK-signed package, and to clear either db or dbx requires a package signed by any entity present in the KEK.</source>
          <target>If they are signed, then to clear the KEK requires a PK-signed package, and to clear either db or dbx requires a package signed by any entity present in the KEK.</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source>1.3.4.3 Microsoft KEK</source>
          <target>1.3.4.3 Microsoft KEK</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>The Microsoft KEK is required to enable revocation of bad images by updating the dbx and potentially for updating db to prepare for newer Windows signed images.</source>
          <target>The Microsoft KEK is required to enable revocation of bad images by updating the dbx and potentially for updating db to prepare for newer Windows signed images.</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source>Include the Microsoft Corporation KEK CA 2011 in the KEK database, with the following values:</source>
          <target>Include the Microsoft Corporation KEK CA 2011 in the KEK database, with the following values:</target>
        </segment>
      </unit>
      <unit id="301">
        <originalData>
          <data id="id1">`31 59 0b fd 89 c9 d7 4e d0 87 df ac 66 33 4b 39 31 25 4b 30`</data>
        </originalData>
        <segment state="initial">
          <source>SHA-1 cert hash: <ph dataRef="id1" id="ph1" />.</source>
          <target>SHA-1 cert hash: <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="302">
        <originalData>
          <data id="id1">`{77fa9abd-0359-4d32-bd60-28f4e78f784b}`</data>
        </originalData>
        <segment state="initial">
          <source>SignatureOwner GUID: <ph dataRef="id1" id="ph1" />.</source>
          <target>SignatureOwner GUID: <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="303">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">\_</data>
          <data id="id9">\_</data>
          <data id="id10">\_</data>
        </originalData>
        <segment state="initial">
          <source>Microsoft will provide the certificate to partners and it can be added either as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc> or an <pc dataRefEnd="id7" dataRefStart="id6" id="p2">EFI<ph dataRef="id8" id="ph4" />CERT<ph dataRef="id9" id="ph5" />RSA2048<ph dataRef="id10" id="ph6" />GUID</pc> type signature.</source>
          <target>Microsoft will provide the certificate to partners and it can be added either as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />CERT<ph dataRef="id4" id="ph2" />X509<ph dataRef="id5" id="ph3" />GUID</pc> or an <pc dataRefEnd="id7" dataRefStart="id6" id="p2">EFI<ph dataRef="id8" id="ph4" />CERT<ph dataRef="id9" id="ph5" />RSA2048<ph dataRef="id10" id="ph6" />GUID</pc> type signature.</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>The Microsoft KEK certificate can be downloaded from: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321185</pc>.</source>
          <target>The Microsoft KEK certificate can be downloaded from: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321185</pc>.</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.4.4 KEKDefault</pc> The platform vendor may provide a default set of Key Exchange Keys in the KEKDefault variable.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.4.4 KEKDefault</pc> The platform vendor may provide a default set of Key Exchange Keys in the KEKDefault variable.</target>
        </segment>
      </unit>
      <unit id="306">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
        </originalData>
        <segment state="initial">
          <source>Please reference <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> section 27.3.3 for more information.</source>
          <target>Please reference <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> section 27.3.3 for more information.</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source>1.3.4.5 OEM/3rd party KEK on non-Windows RT PCs</source>
          <target>1.3.4.5 OEM/3rd party KEK on non-Windows RT PCs</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source>Partners don’t need to have their own KEK.</source>
          <target>Partners don’t need to have their own KEK.</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source>On non-Windows RT PCs the OEM may have additional KEKs to allow additional OEM or a trusted 3rd party control of the db and dbx.</source>
          <target>On non-Windows RT PCs the OEM may have additional KEKs to allow additional OEM or a trusted 3rd party control of the db and dbx.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source>In that case you will need to store the private half of the KEK in a safe storage location.</source>
          <target>In that case you will need to store the private half of the KEK in a safe storage location.</target>
        </segment>
      </unit>
      <unit id="311">
        <segment state="initial">
          <source>The public half will be on the PC in UEFI defined KEK database.</source>
          <target>The public half will be on the PC in UEFI defined KEK database.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source>As per UEFI recommendations, the public key must be stored in non-volatile storage which is tamper and delete resistant on the PC.</source>
          <target>As per UEFI recommendations, the public key must be stored in non-volatile storage which is tamper and delete resistant on the PC.</target>
        </segment>
      </unit>
      <unit id="313">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.5 Secure Boot firmware update key</pc>The Secure firmware update key is used to sign the firmware when it needs to be updated.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.3.5 Secure Boot firmware update key</pc>The Secure firmware update key is used to sign the firmware when it needs to be updated.</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source>This key has to have a minimum key strength of RSA-2048.</source>
          <target>This key has to have a minimum key strength of RSA-2048.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>All firmware updates must be signed securely by the OEM, their trusted delegate such as the ODM or IBV (Independent BIOS Vendor), or by a secure signing service.</source>
          <target>All firmware updates must be signed securely by the OEM, their trusted delegate such as the ODM or IBV (Independent BIOS Vendor), or by a secure signing service.</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=321186)</data>
        </originalData>
        <segment state="initial">
          <source>As per <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NIST publication 800-147 Field Firmware Update</pc> must support all elements of guidelines:</source>
          <target>As per <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NIST publication 800-147 Field Firmware Update</pc> must support all elements of guidelines:</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>Any update to the firmware flash store must be signed by creator.</source>
          <target>Any update to the firmware flash store must be signed by creator.</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source>Firmware must check signature of the update.</source>
          <target>Firmware must check signature of the update.</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source>1.3.6 Creation of keys for Secure Firmware Update</source>
          <target>1.3.6 Creation of keys for Secure Firmware Update</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source>The same key will be used to sign all firmware updates since the public half will be residing on the PC.</source>
          <target>The same key will be used to sign all firmware updates since the public half will be residing on the PC.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source>You could also sign the firmware update with a key which chains to Secure Firmware update key.</source>
          <target>You could also sign the firmware update with a key which chains to Secure Firmware update key.</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source>There could be one key per PC like PK or one per model or one per product line.</source>
          <target>There could be one key per PC like PK or one per model or one per product line.</target>
        </segment>
      </unit>
      <unit id="323">
        <segment state="initial">
          <source>If there is one key per PC that would mean that millions of unique update packages will need to be generated.</source>
          <target>If there is one key per PC that would mean that millions of unique update packages will need to be generated.</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source>Please consider based on resource availability what method would work for you.</source>
          <target>Please consider based on resource availability what method would work for you.</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source>Having a key per model or product line is a good compromise.</source>
          <target>Having a key per model or product line is a good compromise.</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source>The Secure Firmware Update public key (or its hash to save space) would be stored in some protected storage on the platform – generally protected flash (PC) or one-time-programmable fuses (SOC).</source>
          <target>The Secure Firmware Update public key (or its hash to save space) would be stored in some protected storage on the platform – generally protected flash (PC) or one-time-programmable fuses (SOC).</target>
        </segment>
      </unit>
      <unit id="327">
        <segment state="initial">
          <source>If only the hash of this key is stored (to save space), then the firmware update will include the key, and the first stage of the update process will be verifying that the public key in the update matches the hash stored on the platform.</source>
          <target>If only the hash of this key is stored (to save space), then the firmware update will include the key, and the first stage of the update process will be verifying that the public key in the update matches the hash stored on the platform.</target>
        </segment>
      </unit>
      <unit id="328">
        <segment state="initial">
          <source>Capsules are a means by which the OS can pass data to UEFI environment across a reboot.</source>
          <target>Capsules are a means by which the OS can pass data to UEFI environment across a reboot.</target>
        </segment>
      </unit>
      <unit id="329">
        <segment state="initial">
          <source>Windows calls the UEFI UpdateCapsule() to deliver system and PC firmware updates.</source>
          <target>Windows calls the UEFI UpdateCapsule() to deliver system and PC firmware updates.</target>
        </segment>
      </unit>
      <unit id="330">
        <segment state="initial">
          <source>At boot time prior to calling ExitBootServices(),Windows will pass in any new firmware updates found in the Windows Driver Store into UpdateCapsule().</source>
          <target>At boot time prior to calling ExitBootServices(),Windows will pass in any new firmware updates found in the Windows Driver Store into UpdateCapsule().</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source>UEFI system firmware can use this process to update system and PC firmware.</source>
          <target>UEFI system firmware can use this process to update system and PC firmware.</target>
        </segment>
      </unit>
      <unit id="332">
        <segment state="initial">
          <source>By leveraging this Windows firmware support an OEM can rely on the same common format and process for updating firmware for both system and PC firmware.</source>
          <target>By leveraging this Windows firmware support an OEM can rely on the same common format and process for updating firmware for both system and PC firmware.</target>
        </segment>
      </unit>
      <unit id="333">
        <segment state="initial">
          <source>Firmware must implement the ACPI ESRT table in order to support UEFI UpdateCapsule() for Windows.</source>
          <target>Firmware must implement the ACPI ESRT table in order to support UEFI UpdateCapsule() for Windows.</target>
        </segment>
      </unit>
      <unit id="334">
        <segment state="initial">
          <source>For details on implementing support for the Windows UEFI Firmware Update Platform consult the following documentation: Windows UEFI Firmware Update Platform.</source>
          <target>For details on implementing support for the Windows UEFI Firmware Update Platform consult the following documentation: Windows UEFI Firmware Update Platform.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source>Update capsules can be in memory or on the disk.</source>
          <target>Update capsules can be in memory or on the disk.</target>
        </segment>
      </unit>
      <unit id="336">
        <segment state="initial">
          <source>Windows supports in memory updates.</source>
          <target>Windows supports in memory updates.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source>1.3.6.1 Capsule (Capsule-in-Memory)</source>
          <target>1.3.6.1 Capsule (Capsule-in-Memory)</target>
        </segment>
      </unit>
      <unit id="338">
        <segment state="initial">
          <source>Following is the flow of events for an In-memory update capsule to work.</source>
          <target>Following is the flow of events for an In-memory update capsule to work.</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source>A capsule is put in memory by an application in the OS</source>
          <target>A capsule is put in memory by an application in the OS</target>
        </segment>
      </unit>
      <unit id="340">
        <segment state="initial">
          <source>Mailbox event is set to inform BIOS of pending update</source>
          <target>Mailbox event is set to inform BIOS of pending update</target>
        </segment>
      </unit>
      <unit id="341">
        <segment state="initial">
          <source>PC reboots, verifies the capsule image and update is performed by the BIOS</source>
          <target>PC reboots, verifies the capsule image and update is performed by the BIOS</target>
        </segment>
      </unit>
      <unit id="342">
        <segment state="initial">
          <source>1.3.7 Workflow of a typical firmware update</source>
          <target>1.3.7 Workflow of a typical firmware update</target>
        </segment>
      </unit>
      <unit id="343">
        <segment state="initial">
          <source>Download and install the firmware driver.</source>
          <target>Download and install the firmware driver.</target>
        </segment>
      </unit>
      <unit id="344">
        <segment state="initial">
          <source>Reboot.</source>
          <target>Reboot.</target>
        </segment>
      </unit>
      <unit id="345">
        <segment state="initial">
          <source>OS Loader detects and verifies the firmware.</source>
          <target>OS Loader detects and verifies the firmware.</target>
        </segment>
      </unit>
      <unit id="346">
        <segment state="initial">
          <source>OS Loader passes a binary blob to UEFI.</source>
          <target>OS Loader passes a binary blob to UEFI.</target>
        </segment>
      </unit>
      <unit id="347">
        <segment state="initial">
          <source>UEFI performs the firmware update (This process is owned by the silicon vendor).</source>
          <target>UEFI performs the firmware update (This process is owned by the silicon vendor).</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source>OS Loader detection completes successfully.</source>
          <target>OS Loader detection completes successfully.</target>
        </segment>
      </unit>
      <unit id="349">
        <segment state="initial">
          <source>OS finishes booting.</source>
          <target>OS finishes booting.</target>
        </segment>
      </unit>
      <unit id="350">
        <segment state="initial">
          <source>1.4 Signature Databases (Db and Dbx)</source>
          <target>1.4 Signature Databases (Db and Dbx)</target>
        </segment>
      </unit>
      <unit id="351">
        <segment state="initial">
          <source>1.4.1 Allowed Signature database (db)</source>
          <target>1.4.1 Allowed Signature database (db)</target>
        </segment>
      </unit>
      <unit id="352">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
          <data id="id3">\_</data>
        </originalData>
        <segment state="initial">
          <source>The contents of the EFI <ph dataRef="id1" id="ph1" />IMAGE<ph dataRef="id2" id="ph2" />SECURITY<ph dataRef="id3" id="ph3" />DATABASE db control what images are trusted when verifying loaded images.</source>
          <target>The contents of the EFI <ph dataRef="id1" id="ph1" />IMAGE<ph dataRef="id2" id="ph2" />SECURITY<ph dataRef="id3" id="ph3" />DATABASE db control what images are trusted when verifying loaded images.</target>
        </segment>
      </unit>
      <unit id="353">
        <segment state="initial">
          <source>The database may contain multiple certificates, keys, and hashes in order to identify allowed images.</source>
          <target>The database may contain multiple certificates, keys, and hashes in order to identify allowed images.</target>
        </segment>
      </unit>
      <unit id="354">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">`58 0a 6f 4c c4 e4 b6 69 b9 eb dc 1b 2b 3e 08 7b 80 d0 67 8d`</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Windows Production PCA 2011</pc> with a SHA-1 Cert Hash of <ph dataRef="id3" id="ph1" /> must be included in db in order to allow the Windows OS Loader to load.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Windows Production PCA 2011</pc> with a SHA-1 Cert Hash of <ph dataRef="id3" id="ph1" /> must be included in db in order to allow the Windows OS Loader to load.</target>
        </segment>
      </unit>
      <unit id="355">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>The Windows CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321192</pc>.</source>
          <target>The Windows CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321192</pc>.</target>
        </segment>
      </unit>
      <unit id="356">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">`46 de f6 3b 5c e6 1c f8 ba 0d e2 e6 63 9c 10 19 d0 ed 14 f3`</data>
        </originalData>
        <segment state="initial">
          <source>On non-Windows RT PCs the OEM should consider including the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc> with a SHA-1 Certificate Hash of <ph dataRef="id3" id="ph1" />.</source>
          <target>On non-Windows RT PCs the OEM should consider including the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc> with a SHA-1 Certificate Hash of <ph dataRef="id3" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="357">
        <segment state="initial">
          <source>Signing UEFI drivers and applications with this certificate will allow UEFI drivers and applications from 3rd parties to run on the PC without requiring additional steps for the user.</source>
          <target>Signing UEFI drivers and applications with this certificate will allow UEFI drivers and applications from 3rd parties to run on the PC without requiring additional steps for the user.</target>
        </segment>
      </unit>
      <unit id="358">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>The UEFI CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321194</pc>.</source>
          <target>The UEFI CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321194</pc>.</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source>On non-Windows RT PCs the OEM may also have additional items in the db to allow other operating systems or OEM-approved UEFI drivers or apps, but these images must not compromise the security of the PC in any way.</source>
          <target>On non-Windows RT PCs the OEM may also have additional items in the db to allow other operating systems or OEM-approved UEFI drivers or apps, but these images must not compromise the security of the PC in any way.</target>
        </segment>
      </unit>
      <unit id="360">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4.2 DbDefault</pc>: The platform vendor may provide a default set of entries for the Signature Database in the dbDefault variable.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4.2 DbDefault</pc>: The platform vendor may provide a default set of entries for the Signature Database in the dbDefault variable.</target>
        </segment>
      </unit>
      <unit id="361">
        <segment state="initial">
          <source>For more information see section 27.5.3 in the UEFI specification.</source>
          <target>For more information see section 27.5.3 in the UEFI specification.</target>
        </segment>
      </unit>
      <unit id="362">
        <segment state="initial">
          <source>1.4.3 Forbidden Signature Database (dbx)</source>
          <target>1.4.3 Forbidden Signature Database (dbx)</target>
        </segment>
      </unit>
      <unit id="363">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
        </originalData>
        <segment state="initial">
          <source>The contents of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />IMAGE<ph dataRef="id4" id="ph2" />SIGNATURE<ph dataRef="id5" id="ph3" />DATABASE1</pc> dbx must be checked when verifying images before checking db and any matches must prevent the image from executing.</source>
          <target>The contents of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />IMAGE<ph dataRef="id4" id="ph2" />SIGNATURE<ph dataRef="id5" id="ph3" />DATABASE1</pc> dbx must be checked when verifying images before checking db and any matches must prevent the image from executing.</target>
        </segment>
      </unit>
      <unit id="364">
        <segment state="initial">
          <source>The database may contain multiple certificates, keys, and hashes in order to identify forbidden images.</source>
          <target>The database may contain multiple certificates, keys, and hashes in order to identify forbidden images.</target>
        </segment>
      </unit>
      <unit id="365">
        <originalData>
          <data id="id1">`0`</data>
        </originalData>
        <segment state="initial">
          <source>The Windows Hardware Certification Requirements state that a dbx must be present, so any dummy value, such as the SHA-256 hash of <ph dataRef="id1" id="ph1" />, may be used as a safe placeholder until such time as Microsoft begins delivering dbx updates.</source>
          <target>The Windows Hardware Certification Requirements state that a dbx must be present, so any dummy value, such as the SHA-256 hash of <ph dataRef="id1" id="ph1" />, may be used as a safe placeholder until such time as Microsoft begins delivering dbx updates.</target>
        </segment>
      </unit>
      <unit id="366">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4.4 DbxDefault</pc>: The platform vendor may provide a default set of entries for the Signature Database in the dbxDefault variable.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">1.4.4 DbxDefault</pc>: The platform vendor may provide a default set of entries for the Signature Database in the dbxDefault variable.</target>
        </segment>
      </unit>
      <unit id="367">
        <segment state="initial">
          <source>For more information see section 27.5.3 in the UEFI specification.</source>
          <target>For more information see section 27.5.3 in the UEFI specification.</target>
        </segment>
      </unit>
      <unit id="368">
        <segment state="initial">
          <source>1.5 Keys Required for Secure Boot on all PCs</source>
          <target>1.5 Keys Required for Secure Boot on all PCs</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source>Key/db Name</source>
          <target>Key/db Name</target>
        </segment>
      </unit>
      <unit id="370">
        <segment state="initial">
          <source>Variable</source>
          <target>Variable</target>
        </segment>
      </unit>
      <unit id="371">
        <segment state="initial">
          <source>Owner</source>
          <target>Owner</target>
        </segment>
      </unit>
      <unit id="372">
        <segment state="initial">
          <source>Notes</source>
          <target>Notes</target>
        </segment>
      </unit>
      <unit id="373">
        <segment state="initial">
          <source>PKpub</source>
          <target>PKpub</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source>PK</source>
          <target>PK</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source>OEM</source>
          <target>OEM</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source>PK – 1 only.</source>
          <target>PK – 1 only.</target>
        </segment>
      </unit>
      <unit id="377">
        <segment state="initial">
          <source>Must be RSA 2048 or stronger.</source>
          <target>Must be RSA 2048 or stronger.</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source>Microsoft Corporation KEK CA 2011</source>
          <target>Microsoft Corporation KEK CA 2011</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source>KEK</source>
          <target>KEK</target>
        </segment>
      </unit>
      <unit id="380">
        <segment state="initial">
          <source>Microsoft</source>
          <target>Microsoft</target>
        </segment>
      </unit>
      <unit id="381">
        <segment state="initial">
          <source>Allows updates to db and dbx:</source>
          <target>Allows updates to db and dbx:</target>
        </segment>
      </unit>
      <unit id="382">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=321185)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321185</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321185</pc>.</target>
        </segment>
      </unit>
      <unit id="383">
        <segment state="initial">
          <source>Microsoft Windows Production CA 2011</source>
          <target>Microsoft Windows Production CA 2011</target>
        </segment>
      </unit>
      <unit id="384">
        <segment state="initial">
          <source>db</source>
          <target>db</target>
        </segment>
      </unit>
      <unit id="385">
        <segment state="initial">
          <source>Microsoft</source>
          <target>Microsoft</target>
        </segment>
      </unit>
      <unit id="386">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=321192)</data>
        </originalData>
        <segment state="initial">
          <source>This CA in the Signature Database (db) allows Windows to boot: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321192</pc>.</source>
          <target>This CA in the Signature Database (db) allows Windows to boot: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321192</pc>.</target>
        </segment>
      </unit>
      <unit id="387">
        <segment state="initial">
          <source>Forbidden Signature Database</source>
          <target>Forbidden Signature Database</target>
        </segment>
      </unit>
      <unit id="388">
        <segment state="initial">
          <source>dbx</source>
          <target>dbx</target>
        </segment>
      </unit>
      <unit id="389">
        <segment state="initial">
          <source>Microsoft</source>
          <target>Microsoft</target>
        </segment>
      </unit>
      <unit id="390">
        <segment state="initial">
          <source>List of known bad Keys, CAs or images from Microsoft</source>
          <target>List of known bad Keys, CAs or images from Microsoft</target>
        </segment>
      </unit>
      <unit id="391">
        <segment state="initial">
          <source>Secure firmware update key</source>
          <target>Secure firmware update key</target>
        </segment>
      </unit>
      <unit id="392">
        <segment state="initial">
          <source>OEM</source>
          <target>OEM</target>
        </segment>
      </unit>
      <unit id="393">
        <segment state="initial">
          <source>Recommendation is to have this key be different from PK</source>
          <target>Recommendation is to have this key be different from PK</target>
        </segment>
      </unit>
      <unit id="394">
        <segment state="initial">
          <source>Table 1: Keys/db needed for Secure Boot</source>
          <target>Table 1: Keys/db needed for Secure Boot</target>
        </segment>
      </unit>
      <unit id="395">
        <segment state="initial">
          <source>1.5.1 Key recommended for non-Windows RT PCs</source>
          <target>1.5.1 Key recommended for non-Windows RT PCs</target>
        </segment>
      </unit>
      <unit id="396">
        <segment state="initial">
          <source>Key/db Name</source>
          <target>Key/db Name</target>
        </segment>
      </unit>
      <unit id="397">
        <segment state="initial">
          <source>Variable</source>
          <target>Variable</target>
        </segment>
      </unit>
      <unit id="398">
        <segment state="initial">
          <source>Owner</source>
          <target>Owner</target>
        </segment>
      </unit>
      <unit id="399">
        <segment state="initial">
          <source>Notes</source>
          <target>Notes</target>
        </segment>
      </unit>
      <unit id="400">
        <segment state="initial">
          <source>Microsoft UEFI driver signing CA</source>
          <target>Microsoft UEFI driver signing CA</target>
        </segment>
      </unit>
      <unit id="401">
        <segment state="initial">
          <source>db</source>
          <target>db</target>
        </segment>
      </unit>
      <unit id="402">
        <segment state="initial">
          <source>Microsoft</source>
          <target>Microsoft</target>
        </segment>
      </unit>
      <unit id="403">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=321194)</data>
        </originalData>
        <segment state="initial">
          <source>Microsoft signer for 3rd party UEFI drivers and Apps signed through the DevCenter program: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321194</pc>.</source>
          <target>Microsoft signer for 3rd party UEFI drivers and Apps signed through the DevCenter program: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/?LinkId=321194</pc>.</target>
        </segment>
      </unit>
      <unit id="404">
        <segment state="initial">
          <source>Table 2: Non-Windows RT Secure Boot keys</source>
          <target>Table 2: Non-Windows RT Secure Boot keys</target>
        </segment>
      </unit>
      <unit id="405">
        <segment state="initial">
          <source>1.5.2 Secure Boot PKI workflow</source>
          <target>1.5.2 Secure Boot PKI workflow</target>
        </segment>
      </unit>
      <unit id="406">
        <segment state="initial">
          <source>Generating a key:</source>
          <target>Generating a key:</target>
        </segment>
      </unit>
      <unit id="407">
        <segment state="initial">
          <source>Create keys: PK, Secure firmware update key, and other keys as needed.</source>
          <target>Create keys: PK, Secure firmware update key, and other keys as needed.</target>
        </segment>
      </unit>
      <unit id="408">
        <segment state="initial">
          <source>Create a backup of the PK, in case you need to rekey the PC, or if the original is lost.</source>
          <target>Create a backup of the PK, in case you need to rekey the PC, or if the original is lost.</target>
        </segment>
      </unit>
      <unit id="409">
        <segment state="initial">
          <source>Install the MS KEK, db, and empty dbx (unless otherwise specified) using PowerShell scripts and/or BIOS vendor firmware methods.</source>
          <target>Install the MS KEK, db, and empty dbx (unless otherwise specified) using PowerShell scripts and/or BIOS vendor firmware methods.</target>
        </segment>
      </unit>
      <unit id="410">
        <segment state="initial">
          <source>Update the firmware with pre-generated SecureFirmwareUpdateKey-public or hash (to save space).</source>
          <target>Update the firmware with pre-generated SecureFirmwareUpdateKey-public or hash (to save space).</target>
        </segment>
      </unit>
      <unit id="411">
        <segment state="initial">
          <source>Sign and install UEFI variable PK using PowerShell scripts and/or BIOS vendor firmware.</source>
          <target>Sign and install UEFI variable PK using PowerShell scripts and/or BIOS vendor firmware.</target>
        </segment>
      </unit>
      <unit id="412">
        <segment state="initial">
          <source>Run tests, including Windows HCK Secure Boot tests.</source>
          <target>Run tests, including Windows HCK Secure Boot tests.</target>
        </segment>
      </unit>
      <unit id="413">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=398265)</data>
        </originalData>
        <segment state="initial">
          <source>For example, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChipSec</pc> to analyze the security of the platform components.</source>
          <target>For example, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChipSec</pc> to analyze the security of the platform components.</target>
        </segment>
      </unit>
      <unit id="414">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=398260)</data>
          <data id="id3">[</data>
          <data id="id4">](http://go.microsoft.com/fwlink/?LinkId=398261)</data>
        </originalData>
        <segment state="initial">
          <source>Verify the state of Secure Boot variables by using PowerShell SecureBoot cmdlets, for example: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Confirm-SecureBootUEFI</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Get-SecureBootUEFI</pc>.</source>
          <target>Verify the state of Secure Boot variables by using PowerShell SecureBoot cmdlets, for example: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Confirm-SecureBootUEFI</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Get-SecureBootUEFI</pc>.</target>
        </segment>
      </unit>
      <unit id="415">
        <segment state="initial">
          <source>2. Key Management Solutions</source>
          <target>2. Key Management Solutions</target>
        </segment>
      </unit>
      <unit id="416">
        <segment state="initial">
          <source>Below are given some of the metrics we used for comparison.</source>
          <target>Below are given some of the metrics we used for comparison.</target>
        </segment>
      </unit>
      <unit id="417">
        <segment state="initial">
          <source>2.1 Metrics used</source>
          <target>2.1 Metrics used</target>
        </segment>
      </unit>
      <unit id="418">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
        </originalData>
        <segment state="initial">
          <source>The following metrics can help you select a HSM PC based on the requirements of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C and your needs.</source>
          <target>The following metrics can help you select a HSM PC based on the requirements of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C and your needs.</target>
        </segment>
      </unit>
      <unit id="419">
        <segment state="initial">
          <source>Public Key Infrastructure (PKI) related</source>
          <target>Public Key Infrastructure (PKI) related</target>
        </segment>
      </unit>
      <unit id="420">
        <segment state="initial">
          <source>Does it support RSA 2048 or higher?</source>
          <target>Does it support RSA 2048 or higher?</target>
        </segment>
      </unit>
      <unit id="421">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkID=220187)</data>
        </originalData>
        <segment state="initial">
          <source>- The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C recommends the keys to be RSA-2048 or better.</source>
          <target>- The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI specification</pc> 2.3.1 Errata C recommends the keys to be RSA-2048 or better.</target>
        </segment>
      </unit>
      <unit id="422">
        <segment state="initial">
          <source>Does it have the ability to generate keys and sign?</source>
          <target>Does it have the ability to generate keys and sign?</target>
        </segment>
      </unit>
      <unit id="423">
        <segment state="initial">
          <source>How many keys can it store?</source>
          <target>How many keys can it store?</target>
        </segment>
      </unit>
      <unit id="424">
        <segment state="initial">
          <source>Does it store keys on HSM or an attached server?</source>
          <target>Does it store keys on HSM or an attached server?</target>
        </segment>
      </unit>
      <unit id="425">
        <segment state="initial">
          <source>Authentication method for key retrieval.</source>
          <target>Authentication method for key retrieval.</target>
        </segment>
      </unit>
      <unit id="426">
        <segment state="initial">
          <source>Some PCs support multiple authentication entities to be present for key retrieval.</source>
          <target>Some PCs support multiple authentication entities to be present for key retrieval.</target>
        </segment>
      </unit>
      <unit id="427">
        <segment state="initial">
          <source>Pricing</source>
          <target>Pricing</target>
        </segment>
      </unit>
      <unit id="428">
        <segment state="initial">
          <source>What is the price point?</source>
          <target>What is the price point?</target>
        </segment>
      </unit>
      <unit id="429">
        <segment state="initial">
          <source>HSMs can range in price from $1,500 to $70,000 depending on available features.</source>
          <target>HSMs can range in price from $1,500 to $70,000 depending on available features.</target>
        </segment>
      </unit>
      <unit id="430">
        <segment state="initial">
          <source>Manufacturing environment</source>
          <target>Manufacturing environment</target>
        </segment>
      </unit>
      <unit id="431">
        <segment state="initial">
          <source>Speed of operation on factory floor.</source>
          <target>Speed of operation on factory floor.</target>
        </segment>
      </unit>
      <unit id="432">
        <segment state="initial">
          <source>Crypto processors can speed up key creation and access.</source>
          <target>Crypto processors can speed up key creation and access.</target>
        </segment>
      </unit>
      <unit id="433">
        <segment state="initial">
          <source>Ease of setup, deployment, maintenance.</source>
          <target>Ease of setup, deployment, maintenance.</target>
        </segment>
      </unit>
      <unit id="434">
        <segment state="initial">
          <source>Skillset and training required?</source>
          <target>Skillset and training required?</target>
        </segment>
      </unit>
      <unit id="435">
        <segment state="initial">
          <source>Network access for backup and High Availability</source>
          <target>Network access for backup and High Availability</target>
        </segment>
      </unit>
      <unit id="436">
        <segment state="initial">
          <source>Standards and Compliance</source>
          <target>Standards and Compliance</target>
        </segment>
      </unit>
      <unit id="437">
        <segment state="initial">
          <source>What level of FIPS compliance does it have?</source>
          <target>What level of FIPS compliance does it have?</target>
        </segment>
      </unit>
      <unit id="438">
        <segment state="initial">
          <source>Is it tamper resistant?</source>
          <target>Is it tamper resistant?</target>
        </segment>
      </unit>
      <unit id="439">
        <segment state="initial">
          <source>Support for other standards, for example, MS crypto APIs.</source>
          <target>Support for other standards, for example, MS crypto APIs.</target>
        </segment>
      </unit>
      <unit id="440">
        <segment state="initial">
          <source>Does it meet government and other agency requirements?</source>
          <target>Does it meet government and other agency requirements?</target>
        </segment>
      </unit>
      <unit id="441">
        <segment state="initial">
          <source>Reliability and disaster recovery</source>
          <target>Reliability and disaster recovery</target>
        </segment>
      </unit>
      <unit id="442">
        <segment state="initial">
          <source>Does it allow for Key Backup?</source>
          <target>Does it allow for Key Backup?</target>
        </segment>
      </unit>
      <unit id="443">
        <segment state="initial">
          <source>Backups can be stored both onsite in a safe location that is a different physical location than the CA computer and HSM and /or at an offsite location.</source>
          <target>Backups can be stored both onsite in a safe location that is a different physical location than the CA computer and HSM and /or at an offsite location.</target>
        </segment>
      </unit>
      <unit id="444">
        <segment state="initial">
          <source>Does it allow for High Availability for disaster recovery?</source>
          <target>Does it allow for High Availability for disaster recovery?</target>
        </segment>
      </unit>
      <unit id="445">
        <segment state="initial">
          <source>2.2 Key Management Options</source>
          <target>2.2 Key Management Options</target>
        </segment>
      </unit>
      <unit id="446">
        <segment state="initial">
          <source>2.2.1 Hardware Security Module (HSM)</source>
          <target>2.2.1 Hardware Security Module (HSM)</target>
        </segment>
      </unit>
      <unit id="447">
        <segment state="initial">
          <source>Based on the above criteria this is probably the most suitable and secure solution.</source>
          <target>Based on the above criteria this is probably the most suitable and secure solution.</target>
        </segment>
      </unit>
      <unit id="448">
        <segment state="initial">
          <source>Most HSM have FIPS 140-2 level 3 compliance.</source>
          <target>Most HSM have FIPS 140-2 level 3 compliance.</target>
        </segment>
      </unit>
      <unit id="449">
        <segment state="initial">
          <source>FIPS 140-2 level 3 compliance is strict on authentication and requires that keys are not exported or imported from the HSM.</source>
          <target>FIPS 140-2 level 3 compliance is strict on authentication and requires that keys are not exported or imported from the HSM.</target>
        </segment>
      </unit>
      <unit id="450">
        <segment state="initial">
          <source>They support multiple ways of key storage.</source>
          <target>They support multiple ways of key storage.</target>
        </segment>
      </unit>
      <unit id="451">
        <segment state="initial">
          <source>They could be stored either locally on the HSM itself or on the server attached to the HSM.</source>
          <target>They could be stored either locally on the HSM itself or on the server attached to the HSM.</target>
        </segment>
      </unit>
      <unit id="452">
        <segment state="initial">
          <source>On the server the keys are encrypted and stored and is preferable for solutions which requires lots of keys to be stored.</source>
          <target>On the server the keys are encrypted and stored and is preferable for solutions which requires lots of keys to be stored.</target>
        </segment>
      </unit>
      <unit id="453">
        <segment state="initial">
          <source>The cryptographic module security policy shall specify a physical security policy, including physical security mechanisms that are implemented in a cryptographic module such as, tamper-evident seals, locks, tamper response and zeroization switches, and alarms.</source>
          <target>The cryptographic module security policy shall specify a physical security policy, including physical security mechanisms that are implemented in a cryptographic module such as, tamper-evident seals, locks, tamper response and zeroization switches, and alarms.</target>
        </segment>
      </unit>
      <unit id="454">
        <segment state="initial">
          <source>It also allows specifying actions required by the operator(s) to ensure that physical security is maintained such as periodic inspection of tamper-evident seals or testing of tamper response and zeroization switches.</source>
          <target>It also allows specifying actions required by the operator(s) to ensure that physical security is maintained such as periodic inspection of tamper-evident seals or testing of tamper response and zeroization switches.</target>
        </segment>
      </unit>
      <unit id="455">
        <segment state="initial">
          <source>2.2.1.1 Network HSM</source>
          <target>2.2.1.1 Network HSM</target>
        </segment>
      </unit>
      <unit id="456">
        <segment state="initial">
          <source>This solution is the best in its class in terms of security, adherence to standards, key generation, storage and retrieval.</source>
          <target>This solution is the best in its class in terms of security, adherence to standards, key generation, storage and retrieval.</target>
        </segment>
      </unit>
      <unit id="457">
        <segment state="initial">
          <source>Most of these PCs support high availability and have ability to backup keys.</source>
          <target>Most of these PCs support high availability and have ability to backup keys.</target>
        </segment>
      </unit>
      <unit id="458">
        <segment state="initial">
          <source>The costs of these products can be in tens of thousands of dollars based on the extra services they offer.</source>
          <target>The costs of these products can be in tens of thousands of dollars based on the extra services they offer.</target>
        </segment>
      </unit>
      <unit id="459">
        <segment state="initial">
          <source>2.2.1.2 Standalone HSM</source>
          <target>2.2.1.2 Standalone HSM</target>
        </segment>
      </unit>
      <unit id="460">
        <segment state="initial">
          <source>These work great with standalone servers.</source>
          <target>These work great with standalone servers.</target>
        </segment>
      </unit>
      <unit id="461">
        <segment state="initial">
          <source>One can use Microsoft CAPI and CNG or any other secure API supported by HSM.</source>
          <target>One can use Microsoft CAPI and CNG or any other secure API supported by HSM.</target>
        </segment>
      </unit>
      <unit id="462">
        <segment state="initial">
          <source>These HSMs come in variety of form factors supporting USB, PCIe and PCMCIA buses.</source>
          <target>These HSMs come in variety of form factors supporting USB, PCIe and PCMCIA buses.</target>
        </segment>
      </unit>
      <unit id="463">
        <segment state="initial">
          <source>They optionally support key backup and high availability.</source>
          <target>They optionally support key backup and high availability.</target>
        </segment>
      </unit>
      <unit id="464">
        <segment state="initial">
          <source>2.2.2 Custom solutions providers</source>
          <target>2.2.2 Custom solutions providers</target>
        </segment>
      </unit>
      <unit id="465">
        <segment state="initial">
          <source>Public Key cryptography can be challenging and require understanding of cryptographic concepts which maybe new.</source>
          <target>Public Key cryptography can be challenging and require understanding of cryptographic concepts which maybe new.</target>
        </segment>
      </unit>
      <unit id="466">
        <segment state="initial">
          <source>There are custom solution providers who could help with the getting Secure Boot to work in the manufacturing environment.</source>
          <target>There are custom solution providers who could help with the getting Secure Boot to work in the manufacturing environment.</target>
        </segment>
      </unit>
      <unit id="467">
        <segment state="initial">
          <source>There are varieties of custom solutions offered by BIOS vendors, HSM companies and PKI consulting companies to get Secure Boot PKI working in the manufacturing environment.</source>
          <target>There are varieties of custom solutions offered by BIOS vendors, HSM companies and PKI consulting companies to get Secure Boot PKI working in the manufacturing environment.</target>
        </segment>
      </unit>
      <unit id="468">
        <segment state="initial">
          <source>Some of the providers are listed below:</source>
          <target>Some of the providers are listed below:</target>
        </segment>
      </unit>
      <unit id="469">
        <segment state="initial">
          <source>2.2.2.1 BIOS vendors</source>
          <target>2.2.2.1 BIOS vendors</target>
        </segment>
      </unit>
      <unit id="470">
        <segment state="initial">
          <source>There are some BIOS vendors which may be able to provide custom solutions.</source>
          <target>There are some BIOS vendors which may be able to provide custom solutions.</target>
        </segment>
      </unit>
      <unit id="471">
        <segment state="initial">
          <source>2.2.2.2 HSM vendors</source>
          <target>2.2.2.2 HSM vendors</target>
        </segment>
      </unit>
      <unit id="472">
        <segment state="initial">
          <source>Some HSM vendors may be able to provide custom consulting.</source>
          <target>Some HSM vendors may be able to provide custom consulting.</target>
        </segment>
      </unit>
      <unit id="473">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](secure-boot-key-generation-and-signing-using-hsm--example.md)</data>
        </originalData>
        <segment state="initial">
          <source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure Boot Key Generation and Signing Using HSM (Example)</pc>.</source>
          <target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure Boot Key Generation and Signing Using HSM (Example)</pc>.</target>
        </segment>
      </unit>
      <unit id="474">
        <segment state="initial">
          <source>2.2.3 Trusted Platform Module (TPM)</source>
          <target>2.2.3 Trusted Platform Module (TPM)</target>
        </segment>
      </unit>
      <unit id="475">
        <segment state="initial">
          <source>A Trusted Platform Module (TPM) is a hardware chip on the motherboard that stores cryptographic keys used for encryption.</source>
          <target>A Trusted Platform Module (TPM) is a hardware chip on the motherboard that stores cryptographic keys used for encryption.</target>
        </segment>
      </unit>
      <unit id="476">
        <segment state="initial">
          <source>Many computers include a TPM, but if the PC doesn’t include it, it is not feasible to add one.</source>
          <target>Many computers include a TPM, but if the PC doesn’t include it, it is not feasible to add one.</target>
        </segment>
      </unit>
      <unit id="477">
        <segment state="initial">
          <source>Once enabled, the Trusted Platform Module can help secure full disk encryption products such as Microsoft BitLocker capabilities.</source>
          <target>Once enabled, the Trusted Platform Module can help secure full disk encryption products such as Microsoft BitLocker capabilities.</target>
        </segment>
      </unit>
      <unit id="478">
        <segment state="initial">
          <source>It keeps hard drives locked, or sealed, until the PC completes a system verification or authentication process.</source>
          <target>It keeps hard drives locked, or sealed, until the PC completes a system verification or authentication process.</target>
        </segment>
      </unit>
      <unit id="479">
        <segment state="initial">
          <source>The TPM can generate, store, and protect keys used in the encryption and decryption process.</source>
          <target>The TPM can generate, store, and protect keys used in the encryption and decryption process.</target>
        </segment>
      </unit>
      <unit id="480">
        <segment state="initial">
          <source>The drawbacks of TPMs are that it may not have fast crypto processors to speed up processing in the manufacturing environment.</source>
          <target>The drawbacks of TPMs are that it may not have fast crypto processors to speed up processing in the manufacturing environment.</target>
        </segment>
      </unit>
      <unit id="481">
        <segment state="initial">
          <source>They also are not suitable for storing large number of keys.</source>
          <target>They also are not suitable for storing large number of keys.</target>
        </segment>
      </unit>
      <unit id="482">
        <segment state="initial">
          <source>Backup and high availability and standards compliance to FIPS 140-2 level 3 may not be available.</source>
          <target>Backup and high availability and standards compliance to FIPS 140-2 level 3 may not be available.</target>
        </segment>
      </unit>
      <unit id="483">
        <segment state="initial">
          <source>2.2.4 Smart Cards</source>
          <target>2.2.4 Smart Cards</target>
        </segment>
      </unit>
      <unit id="484">
        <segment state="initial">
          <source>A smart card can generate and store keys.</source>
          <target>A smart card can generate and store keys.</target>
        </segment>
      </unit>
      <unit id="485">
        <segment state="initial">
          <source>They do share some features which HSM support like authentication and tamper proofing, but they don’t include much key storage or backup.</source>
          <target>They do share some features which HSM support like authentication and tamper proofing, but they don’t include much key storage or backup.</target>
        </segment>
      </unit>
      <unit id="486">
        <segment state="initial">
          <source>They require manual intervention and may not be suitable for automation and use in production environment as the performance maybe low.</source>
          <target>They require manual intervention and may not be suitable for automation and use in production environment as the performance maybe low.</target>
        </segment>
      </unit>
      <unit id="487">
        <segment state="initial">
          <source>The drawbacks of Smart cards are similar to TPMs.</source>
          <target>The drawbacks of Smart cards are similar to TPMs.</target>
        </segment>
      </unit>
      <unit id="488">
        <segment state="initial">
          <source>They may not have fast crypto processors to speed up processing in the manufacturing environment.</source>
          <target>They may not have fast crypto processors to speed up processing in the manufacturing environment.</target>
        </segment>
      </unit>
      <unit id="489">
        <segment state="initial">
          <source>They also are not suitable for storing large number of keys.</source>
          <target>They also are not suitable for storing large number of keys.</target>
        </segment>
      </unit>
      <unit id="490">
        <segment state="initial">
          <source>Backup and high availability and standards compliance to FIPS 140-2 level 3 may not be available.</source>
          <target>Backup and high availability and standards compliance to FIPS 140-2 level 3 may not be available.</target>
        </segment>
      </unit>
      <unit id="491">
        <segment state="initial">
          <source>2.2.5 Software-centric approaches (NOT RECOMMENDED)</source>
          <target>2.2.5 Software-centric approaches (NOT RECOMMENDED)</target>
        </segment>
      </unit>
      <unit id="492">
        <segment state="initial">
          <source>Use crypto APIs for key management.</source>
          <target>Use crypto APIs for key management.</target>
        </segment>
      </unit>
      <unit id="493">
        <segment state="initial">
          <source>This may involve storing a key in a key container on an encrypted hard drive and possible for additional sandboxing and security use a Virtual machine.</source>
          <target>This may involve storing a key in a key container on an encrypted hard drive and possible for additional sandboxing and security use a Virtual machine.</target>
        </segment>
      </unit>
      <unit id="494">
        <segment state="initial">
          <source>These solutions are not as secure as using an HSM and expose a higher attack vector.</source>
          <target>These solutions are not as secure as using an HSM and expose a higher attack vector.</target>
        </segment>
      </unit>
      <unit id="495">
        <segment state="initial">
          <source>2.2.5.1 Makecert (NOT RECOMMENDED)</source>
          <target>2.2.5.1 Makecert (NOT RECOMMENDED)</target>
        </segment>
      </unit>
      <unit id="496">
        <segment state="initial">
          <source>Makecert is a Microsoft tool and can be used as follows for key generation.</source>
          <target>Makecert is a Microsoft tool and can be used as follows for key generation.</target>
        </segment>
      </unit>
      <unit id="497">
        <segment state="initial">
          <source>To make sure that the attack surface is minimized you may need to “air gap” the PC.</source>
          <target>To make sure that the attack surface is minimized you may need to “air gap” the PC.</target>
        </segment>
      </unit>
      <unit id="498">
        <segment state="initial">
          <source>The PC that has the PKpriv on should not be connected to the network.</source>
          <target>The PC that has the PKpriv on should not be connected to the network.</target>
        </segment>
      </unit>
      <unit id="499">
        <segment state="initial">
          <source>It should be in a secure location and ideally should at least use a smart card reader if not a real HSM.</source>
          <target>It should be in a secure location and ideally should at least use a smart card reader if not a real HSM.</target>
        </segment>
      </unit>
      <unit id="500">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=211849)</data>
        </originalData>
        <segment state="initial">
          <source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Certificate Creation Tool (Makecert.exe)</pc>.</source>
          <target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Certificate Creation Tool (Makecert.exe)</pc>.</target>
        </segment>
      </unit>
      <unit id="501">
        <segment state="initial">
          <source>This solution is not recommended.</source>
          <target>This solution is not recommended.</target>
        </segment>
      </unit>
      <unit id="502">
        <segment state="initial">
          <source>2.3 HSM Key generation and storage for Secure Boot keys</source>
          <target>2.3 HSM Key generation and storage for Secure Boot keys</target>
        </segment>
      </unit>
      <unit id="503">
        <segment state="initial">
          <source>2.3.1 Storing Private keys</source>
          <target>2.3.1 Storing Private keys</target>
        </segment>
      </unit>
      <unit id="504">
        <segment state="initial">
          <source>The space requirement for each RSA-2048 key is 2048 bits.</source>
          <target>The space requirement for each RSA-2048 key is 2048 bits.</target>
        </segment>
      </unit>
      <unit id="505">
        <segment state="initial">
          <source>The actual location of the storage of the keys depends on the solution chosen.</source>
          <target>The actual location of the storage of the keys depends on the solution chosen.</target>
        </segment>
      </unit>
      <unit id="506">
        <segment state="initial">
          <source>HSM are a good way of storing keys.</source>
          <target>HSM are a good way of storing keys.</target>
        </segment>
      </unit>
      <unit id="507">
        <segment state="initial">
          <source>The physical location of the PCs on the factory floor would need to be a protected area with limited user access like a secure cage.</source>
          <target>The physical location of the PCs on the factory floor would need to be a protected area with limited user access like a secure cage.</target>
        </segment>
      </unit>
      <unit id="508">
        <segment state="initial">
          <source>Depending on your requirements these keys could also be stored in a diverse geographical location or backed up in a different location.</source>
          <target>Depending on your requirements these keys could also be stored in a diverse geographical location or backed up in a different location.</target>
        </segment>
      </unit>
      <unit id="509">
        <segment state="initial">
          <source>The rekeying requirements for these keys could vary based on the customer (see Appendix A for Federal bridge certificate authority rekeying guidelines).</source>
          <target>The rekeying requirements for these keys could vary based on the customer (see Appendix A for Federal bridge certificate authority rekeying guidelines).</target>
        </segment>
      </unit>
      <unit id="510">
        <segment state="initial">
          <source>These could be done once per year.</source>
          <target>These could be done once per year.</target>
        </segment>
      </unit>
      <unit id="511">
        <segment state="initial">
          <source>You may need to have access to these keys for up to 30 years (depending on the rekeying requirements etc.).</source>
          <target>You may need to have access to these keys for up to 30 years (depending on the rekeying requirements etc.).</target>
        </segment>
      </unit>
      <unit id="512">
        <segment state="initial">
          <source>2.3.2 Retrieving the private Keys</source>
          <target>2.3.2 Retrieving the private Keys</target>
        </segment>
      </unit>
      <unit id="513">
        <segment state="initial">
          <source>The keys may need to be retrieved for many reasons.</source>
          <target>The keys may need to be retrieved for many reasons.</target>
        </segment>
      </unit>
      <unit id="514">
        <segment state="initial">
          <source>The PK may need to be retrieved to issue an updated PK due to it being compromised or to adhere to government /other agency regulations.</source>
          <target>The PK may need to be retrieved to issue an updated PK due to it being compromised or to adhere to government /other agency regulations.</target>
        </segment>
      </unit>
      <unit id="515">
        <segment state="initial">
          <source>KEKpri will be used to update the db and dbx.</source>
          <target>KEKpri will be used to update the db and dbx.</target>
        </segment>
      </unit>
      <unit id="516">
        <segment state="initial">
          <source>Secure firmware update key –pri will be used to sign newer updates.</source>
          <target>Secure firmware update key –pri will be used to sign newer updates.</target>
        </segment>
      </unit>
      <unit id="517">
        <segment state="initial">
          <source>2.3.3 Authentication</source>
          <target>2.3.3 Authentication</target>
        </segment>
      </unit>
      <unit id="518">
        <segment state="initial">
          <source>As per FIPS 140-2 authentication is based on level of access.</source>
          <target>As per FIPS 140-2 authentication is based on level of access.</target>
        </segment>
      </unit>
      <unit id="519">
        <segment state="initial">
          <source>Level 2</source>
          <target>Level 2</target>
        </segment>
      </unit>
      <unit id="520">
        <segment state="initial">
          <source>Security Level 2 requires, at a minimum, role-based authentication in which a cryptographic module authenticates the authorization of an operator to assume a specific role and perform a corresponding set of services.</source>
          <target>Security Level 2 requires, at a minimum, role-based authentication in which a cryptographic module authenticates the authorization of an operator to assume a specific role and perform a corresponding set of services.</target>
        </segment>
      </unit>
      <unit id="521">
        <segment state="initial">
          <source>Level 3</source>
          <target>Level 3</target>
        </segment>
      </unit>
      <unit id="522">
        <segment state="initial">
          <source>Security Level 3 requires identity-based authentication mechanisms, enhancing the security provided by the role-based authentication mechanisms specified for Security Level 2.</source>
          <target>Security Level 3 requires identity-based authentication mechanisms, enhancing the security provided by the role-based authentication mechanisms specified for Security Level 2.</target>
        </segment>
      </unit>
      <unit id="523">
        <segment state="initial">
          <source>A cryptographic module authenticates the identity of an operator and verifies that the identified operator is authorized to assume a specific role and perform a corresponding set of services.</source>
          <target>A cryptographic module authenticates the identity of an operator and verifies that the identified operator is authorized to assume a specific role and perform a corresponding set of services.</target>
        </segment>
      </unit>
      <unit id="524">
        <segment state="initial">
          <source>PCs like HSM’s support Security Level 3, which requires identity-based “k of m authentication”.</source>
          <target>PCs like HSM’s support Security Level 3, which requires identity-based “k of m authentication”.</target>
        </segment>
      </unit>
      <unit id="525">
        <segment state="initial">
          <source>This means k entities are given access to the HSM with a token but at a given point at least k out of the m tokens need to be present for authentication to work to get access to private keys from HSM.</source>
          <target>This means k entities are given access to the HSM with a token but at a given point at least k out of the m tokens need to be present for authentication to work to get access to private keys from HSM.</target>
        </segment>
      </unit>
      <unit id="526">
        <segment state="initial">
          <source>For example, you could have 3 out of 5 tokens should be authenticated to access HSM.</source>
          <target>For example, you could have 3 out of 5 tokens should be authenticated to access HSM.</target>
        </segment>
      </unit>
      <unit id="527">
        <segment state="initial">
          <source>Those members could be the security officers, transaction authorizer and/or members from Executive Management.</source>
          <target>Those members could be the security officers, transaction authorizer and/or members from Executive Management.</target>
        </segment>
      </unit>
      <unit id="528">
        <segment state="initial">
          <source>HSM Tokens</source>
          <target>HSM Tokens</target>
        </segment>
      </unit>
      <unit id="529">
        <segment state="initial">
          <source>You could have a policy on the HSM which require the token to be present:</source>
          <target>You could have a policy on the HSM which require the token to be present:</target>
        </segment>
      </unit>
      <unit id="530">
        <segment state="initial">
          <source>Locally</source>
          <target>Locally</target>
        </segment>
      </unit>
      <unit id="531">
        <segment state="initial">
          <source>Remotely</source>
          <target>Remotely</target>
        </segment>
      </unit>
      <unit id="532">
        <segment state="initial">
          <source>Configured to be automated</source>
          <target>Configured to be automated</target>
        </segment>
      </unit>
      <unit id="533">
        <segment state="initial">
          <source>As a good practice, please use a combination of token and per token password.</source>
          <target>As a good practice, please use a combination of token and per token password.</target>
        </segment>
      </unit>
      <unit id="534">
        <segment state="initial">
          <source>2.4 Secure Boot and 3rd party signing</source>
          <target>2.4 Secure Boot and 3rd party signing</target>
        </segment>
      </unit>
      <unit id="535">
        <segment state="initial">
          <source>2.4.1 UEFI driver signing</source>
          <target>2.4.1 UEFI driver signing</target>
        </segment>
      </unit>
      <unit id="536">
        <segment state="initial">
          <source>UEFI Drivers must be signed by a CA or key in the db as described elsewhere in the document, or have the hash of the driver image included in db.</source>
          <target>UEFI Drivers must be signed by a CA or key in the db as described elsewhere in the document, or have the hash of the driver image included in db.</target>
        </segment>
      </unit>
      <unit id="537">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Microsoft will be providing a UEFI driver signing service similar to the WHQL driver signing service using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc>.</source>
          <target>Microsoft will be providing a UEFI driver signing service similar to the WHQL driver signing service using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc>.</target>
        </segment>
      </unit>
      <unit id="538">
        <segment state="initial">
          <source>Any drivers signed by this will run seamlessly on any PCs that include the Microsoft UEFI CA.</source>
          <target>Any drivers signed by this will run seamlessly on any PCs that include the Microsoft UEFI CA.</target>
        </segment>
      </unit>
      <unit id="539">
        <segment state="initial">
          <source>It is also possible for an OEM to sign trusted drivers and include the OEM CA in the db, or to include hashes of the drivers in the db.</source>
          <target>It is also possible for an OEM to sign trusted drivers and include the OEM CA in the db, or to include hashes of the drivers in the db.</target>
        </segment>
      </unit>
      <unit id="540">
        <segment state="initial">
          <source>In all cases a UEFI driver (Option ROM) shall not execute if it is not trusted in the db.</source>
          <target>In all cases a UEFI driver (Option ROM) shall not execute if it is not trusted in the db.</target>
        </segment>
      </unit>
      <unit id="541">
        <segment state="initial">
          <source>Any drivers that are included in the system firmware image do not need to be re-verified.</source>
          <target>Any drivers that are included in the system firmware image do not need to be re-verified.</target>
        </segment>
      </unit>
      <unit id="542">
        <segment state="initial">
          <source>Being part of the overall system image provides sufficient assurance that the driver is trusted on the PC.</source>
          <target>Being part of the overall system image provides sufficient assurance that the driver is trusted on the PC.</target>
        </segment>
      </unit>
      <unit id="543">
        <segment state="initial">
          <source>Microsoft has this made available to anyone who wants to sign UEFI drivers.</source>
          <target>Microsoft has this made available to anyone who wants to sign UEFI drivers.</target>
        </segment>
      </unit>
      <unit id="544">
        <segment state="initial">
          <source>This certificate is part of the Windows HCK Secure Boot tests.</source>
          <target>This certificate is part of the Windows HCK Secure Boot tests.</target>
        </segment>
      </unit>
      <unit id="545">
        <segment state="initial">
          <source>2.4.2 Boot loaders</source>
          <target>2.4.2 Boot loaders</target>
        </segment>
      </unit>
      <unit id="546">
        <segment state="initial">
          <source>The Microsoft UEFI driver signing certificate can be used for signing other OSs.</source>
          <target>The Microsoft UEFI driver signing certificate can be used for signing other OSs.</target>
        </segment>
      </unit>
      <unit id="547">
        <segment state="initial">
          <source>For example, Fedora’s Linux boot loader will be signed by it.</source>
          <target>For example, Fedora’s Linux boot loader will be signed by it.</target>
        </segment>
      </unit>
      <unit id="548">
        <segment state="initial">
          <source>This solution doesn’t require any more certificates to be added to the key Db.</source>
          <target>This solution doesn’t require any more certificates to be added to the key Db.</target>
        </segment>
      </unit>
      <unit id="549">
        <segment state="initial">
          <source>In addition to being cost effective, it can be used for any Linux distribution.</source>
          <target>In addition to being cost effective, it can be used for any Linux distribution.</target>
        </segment>
      </unit>
      <unit id="550">
        <segment state="initial">
          <source>This solution would work for any hardware which supports Windows so it is useful for a wide range of hardware.</source>
          <target>This solution would work for any hardware which supports Windows so it is useful for a wide range of hardware.</target>
        </segment>
      </unit>
      <unit id="551">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>The UEFI-CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?LinkID=321194</pc>.</source>
          <target>The UEFI-CA can be downloaded from here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?LinkID=321194</pc>.</target>
        </segment>
      </unit>
      <unit id="552">
        <segment state="initial">
          <source>The following links have more information on Windows HCK UEFI signing and submission:</source>
          <target>The following links have more information on Windows HCK UEFI signing and submission:</target>
        </segment>
      </unit>
      <unit id="553">
        <segment state="initial">
          <source>Windows Dev Center Hardware Dashboard</source>
          <target>Windows Dev Center Hardware Dashboard</target>
        </segment>
      </unit>
      <unit id="554">
        <segment state="initial">
          <source>Windows Certification Dashboard Administration</source>
          <target>Windows Certification Dashboard Administration</target>
        </segment>
      </unit>
      <unit id="555">
        <segment state="initial">
          <source>UEFI Firmware Signing</source>
          <target>UEFI Firmware Signing</target>
        </segment>
      </unit>
      <unit id="556">
        <segment state="initial">
          <source>Windows Hardware Certification blog: UEFI signing CA update</source>
          <target>Windows Hardware Certification blog: UEFI signing CA update</target>
        </segment>
      </unit>
      <unit id="557">
        <segment state="initial">
          <source>3. Summary and Resources</source>
          <target>3. Summary and Resources</target>
        </segment>
      </unit>
      <unit id="558">
        <segment state="initial">
          <source>This section intends to summarize the above sections and show a step by step approach:</source>
          <target>This section intends to summarize the above sections and show a step by step approach:</target>
        </segment>
      </unit>
      <unit id="559">
        <segment state="initial">
          <source>Establish a secure CA or identify a partner to securely generate and store keys</source>
          <target>Establish a secure CA or identify a partner to securely generate and store keys</target>
        </segment>
      </unit>
      <unit id="560">
        <segment state="initial">
          <source>If you are not using a 3rd party solution:</source>
          <target>If you are not using a 3rd party solution:</target>
        </segment>
      </unit>
      <unit id="561">
        <segment state="initial">
          <source>Install and configure the HSM software on the HSM server.</source>
          <target>Install and configure the HSM software on the HSM server.</target>
        </segment>
      </unit>
      <unit id="562">
        <segment state="initial">
          <source>Check your HSM reference manual for installation instructions.</source>
          <target>Check your HSM reference manual for installation instructions.</target>
        </segment>
      </unit>
      <unit id="563">
        <segment state="initial">
          <source>The server will either be connected to a standalone or network HSM.</source>
          <target>The server will either be connected to a standalone or network HSM.</target>
        </segment>
      </unit>
      <unit id="564">
        <segment state="initial">
          <source>For info about HSM configuration, see Section 2.2.1, 2.3 and Appendix C.</source>
          <target>For info about HSM configuration, see Section 2.2.1, 2.3 and Appendix C.</target>
        </segment>
      </unit>
      <unit id="565">
        <segment state="initial">
          <source>Most HSMs offer FIPS 140-2 level 2 and 3 compliance.</source>
          <target>Most HSMs offer FIPS 140-2 level 2 and 3 compliance.</target>
        </segment>
      </unit>
      <unit id="566">
        <segment state="initial">
          <source>Configure the HSM for either level 2 or level 3 compliance.</source>
          <target>Configure the HSM for either level 2 or level 3 compliance.</target>
        </segment>
      </unit>
      <unit id="567">
        <segment state="initial">
          <source>Level 3 compliance has stricter requirements around authentication and key access and hence is more secure.</source>
          <target>Level 3 compliance has stricter requirements around authentication and key access and hence is more secure.</target>
        </segment>
      </unit>
      <unit id="568">
        <segment state="initial">
          <source>Level 3 is recommended.</source>
          <target>Level 3 is recommended.</target>
        </segment>
      </unit>
      <unit id="569">
        <segment state="initial">
          <source>Configure HSM for High Availability, Backup and Authentication.</source>
          <target>Configure HSM for High Availability, Backup and Authentication.</target>
        </segment>
      </unit>
      <unit id="570">
        <segment state="initial">
          <source>Check your HSM reference manual.</source>
          <target>Check your HSM reference manual.</target>
        </segment>
      </unit>
      <unit id="571">
        <segment state="initial">
          <source>Follow HSM provider guidelines on setting up HSM for High Availability and backup.</source>
          <target>Follow HSM provider guidelines on setting up HSM for High Availability and backup.</target>
        </segment>
      </unit>
      <unit id="572">
        <segment state="initial">
          <source>Also, Network HSMs typically have multiple network ports to segregate traffic; allowing a server to communicate with network HSMs on a network separate from the regular production network.</source>
          <target>Also, Network HSMs typically have multiple network ports to segregate traffic; allowing a server to communicate with network HSMs on a network separate from the regular production network.</target>
        </segment>
      </unit>
      <unit id="573">
        <segment state="initial">
          <source>Once team members who are part of the security team have been identified and tokens assigned to them.</source>
          <target>Once team members who are part of the security team have been identified and tokens assigned to them.</target>
        </segment>
      </unit>
      <unit id="574">
        <segment state="initial">
          <source>You will need to setup HSM hardware for k-of-m authentication.</source>
          <target>You will need to setup HSM hardware for k-of-m authentication.</target>
        </segment>
      </unit>
      <unit id="575">
        <segment state="initial">
          <source>Secure Boot Keys and certificate pre-generation.</source>
          <target>Secure Boot Keys and certificate pre-generation.</target>
        </segment>
      </unit>
      <unit id="576">
        <segment state="initial">
          <source>See Sections 1.3 to 1.5</source>
          <target>See Sections 1.3 to 1.5</target>
        </segment>
      </unit>
      <unit id="577">
        <segment state="initial">
          <source>Use HSM APIs to pre-generate (generate in advance) the PK and Firmware Update Key and certificates.</source>
          <target>Use HSM APIs to pre-generate (generate in advance) the PK and Firmware Update Key and certificates.</target>
        </segment>
      </unit>
      <unit id="578">
        <segment state="initial">
          <source>Required - PK (recommend 1 per model), Firmware Update key (recommend 1 per model), Microsoft KEK, Db, DbxNOTE: The Microsoft KEK, db, and dbx don’t have to be generated by the OEM and are mentioned for completeness.Optional - OEM/3rd party KEK db, dbx and any other keys which would go into OEM Db.</source>
          <target>Required - PK (recommend 1 per model), Firmware Update key (recommend 1 per model), Microsoft KEK, Db, DbxNOTE: The Microsoft KEK, db, and dbx don’t have to be generated by the OEM and are mentioned for completeness.Optional - OEM/3rd party KEK db, dbx and any other keys which would go into OEM Db.</target>
        </segment>
      </unit>
      <unit id="579">
        <segment state="initial">
          <source>Apply a Windows image to the PC.</source>
          <target>Apply a Windows image to the PC.</target>
        </segment>
      </unit>
      <unit id="580">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Install Microsoft db and dbx</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Install Microsoft db and dbx</pc>.</target>
        </segment>
      </unit>
      <unit id="581">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#securebootapis)</data>
        </originalData>
        <segment state="initial">
          <source>See Section 1.3.6 and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</source>
          <target>See Section 1.3.6 and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</target>
        </segment>
      </unit>
      <unit id="582">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Install the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Windows Production PCA 2011</pc> into db.</source>
          <target>Install the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Windows Production PCA 2011</pc> into db.</target>
        </segment>
      </unit>
      <unit id="583">
        <segment state="initial">
          <source>Install an empty dbx if Microsoft does not provide one.</source>
          <target>Install an empty dbx if Microsoft does not provide one.</target>
        </segment>
      </unit>
      <unit id="584">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="585">
        <segment state="initial">
          <source>Use PowerShell cmdlets which are part of the Windows HCK tests or use methods provided by BIOS vendor.</source>
          <target>Use PowerShell cmdlets which are part of the Windows HCK tests or use methods provided by BIOS vendor.</target>
        </segment>
      </unit>
      <unit id="586">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Install Microsoft KEK</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Install Microsoft KEK</pc>.</target>
        </segment>
      </unit>
      <unit id="587">
        <segment state="initial">
          <source>See Section 1.3.3.</source>
          <target>See Section 1.3.3.</target>
        </segment>
      </unit>
      <unit id="588">
        <segment state="initial">
          <source>Install Microsoft KEK into the UEFI KEK database</source>
          <target>Install Microsoft KEK into the UEFI KEK database</target>
        </segment>
      </unit>
      <unit id="589">
        <segment state="initial">
          <source>Caution</source>
          <target>Caution</target>
        </segment>
      </unit>
      <unit id="590">
        <segment state="initial">
          <source>Use PowerShell cmdlets which are part of the Windows HCK tests or use methods provided by BIOS vendor.</source>
          <target>Use PowerShell cmdlets which are part of the Windows HCK tests or use methods provided by BIOS vendor.</target>
        </segment>
      </unit>
      <unit id="591">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optional step - OEM/3rd party secure boot components</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optional step - OEM/3rd party secure boot components</pc>.</target>
        </segment>
      </unit>
      <unit id="592">
        <segment state="initial">
          <source>See Section 1.3.4 and 1.4.</source>
          <target>See Section 1.3.4 and 1.4.</target>
        </segment>
      </unit>
      <unit id="593">
        <segment state="initial">
          <source>Identify if you have need for creating a OEM/3rd party KEK, db and dbx.</source>
          <target>Identify if you have need for creating a OEM/3rd party KEK, db and dbx.</target>
        </segment>
      </unit>
      <unit id="594">
        <segment state="initial">
          <source>Sign OEM/3rd party db and dbx with OEM/3rd party KEK(generated earlier) using HSM API.</source>
          <target>Sign OEM/3rd party db and dbx with OEM/3rd party KEK(generated earlier) using HSM API.</target>
        </segment>
      </unit>
      <unit id="595">
        <segment state="initial">
          <source>Install OEM/3rd party KEK, db and dbx.</source>
          <target>Install OEM/3rd party KEK, db and dbx.</target>
        </segment>
      </unit>
      <unit id="596">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI driver signing</pc> – See Section 2.4.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI driver signing</pc> – See Section 2.4.</target>
        </segment>
      </unit>
      <unit id="597">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If supporting add-in cards or other UEFI drivers/apps/bootloaders, install <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc> into UEFI db.</source>
          <target>If supporting add-in cards or other UEFI drivers/apps/bootloaders, install <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft Corporation UEFI CA 2011</pc> into UEFI db.</target>
        </segment>
      </unit>
      <unit id="598">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure boot firmware update key</pc> - See Section 1.3.5.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Secure boot firmware update key</pc> - See Section 1.3.5.</target>
        </segment>
      </unit>
      <unit id="599">
        <segment state="initial">
          <source>Non-Windows RT PCs only: Install the Secure firmware update public key or its hash to save space.</source>
          <target>Non-Windows RT PCs only: Install the Secure firmware update public key or its hash to save space.</target>
        </segment>
      </unit>
      <unit id="600">
        <segment state="initial">
          <source>On SoC only, you may need to do something different, for example, burn Secure firmware update key: public or its hash.</source>
          <target>On SoC only, you may need to do something different, for example, burn Secure firmware update key: public or its hash.</target>
        </segment>
      </unit>
      <unit id="601">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Enabling Secure Boot</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Enabling Secure Boot</pc>.</target>
        </segment>
      </unit>
      <unit id="602">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#securebootapis)</data>
        </originalData>
        <segment state="initial">
          <source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</source>
          <target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</target>
        </segment>
      </unit>
      <unit id="603">
        <segment state="initial">
          <source>Install the OEM/ODM PKpub (certificate preferred, but key is okay) into the UEFI PK.</source>
          <target>Install the OEM/ODM PKpub (certificate preferred, but key is okay) into the UEFI PK.</target>
        </segment>
      </unit>
      <unit id="604">
        <segment state="initial">
          <source>Enroll the PK using Secure Boot API.</source>
          <target>Enroll the PK using Secure Boot API.</target>
        </segment>
      </unit>
      <unit id="605">
        <segment state="initial">
          <source>The PC should be now enabled for Secure Boot.</source>
          <target>The PC should be now enabled for Secure Boot.</target>
        </segment>
      </unit>
      <unit id="606">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="607">
        <segment state="initial">
          <source>If you install the PK at the end, the MS KEK, db, dbx don’t need to be signed – no SignerInfo must be present.</source>
          <target>If you install the PK at the end, the MS KEK, db, dbx don’t need to be signed – no SignerInfo must be present.</target>
        </segment>
      </unit>
      <unit id="608">
        <segment state="initial">
          <source>This is a shortcut.</source>
          <target>This is a shortcut.</target>
        </segment>
      </unit>
      <unit id="609">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Testing Secure Boot</pc>: Execute any proprietary tests and Windows HCK tests as per instructions.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Testing Secure Boot</pc>: Execute any proprietary tests and Windows HCK tests as per instructions.</target>
        </segment>
      </unit>
      <unit id="610">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#securebootapis)</data>
        </originalData>
        <segment state="initial">
          <source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</source>
          <target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Appendix B – Secure Boot APIs</pc>.</target>
        </segment>
      </unit>
      <unit id="611">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ship platform</pc>: The PKpriv will likely never be used again, keep it safe.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ship platform</pc>: The PKpriv will likely never be used again, keep it safe.</target>
        </segment>
      </unit>
      <unit id="612">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Servicing</pc>: Future firmware updates are securely signed with the Secure Firmware Update “private” key using the signing service.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Servicing</pc>: Future firmware updates are securely signed with the Secure Firmware Update “private” key using the signing service.</target>
        </segment>
      </unit>
      <unit id="613">
        <segment state="initial">
          <source>3.1 Resources</source>
          <target>3.1 Resources</target>
        </segment>
      </unit>
      <unit id="614">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>Security Strategies White Paper - <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321288</pc></source>
          <target>Security Strategies White Paper - <pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321288</pc></target>
        </segment>
      </unit>
      <unit id="615">
        <originalData>
          <data id="id1">&lt;</data>
          <data id="id2">&gt;</data>
        </originalData>
        <segment state="initial">
          <source>Windows HCK Submission -<pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321287</pc></source>
          <target>Windows HCK Submission -<pc dataRefEnd="id2" dataRefStart="id1" id="p1">http://go.microsoft.com/fwlink/p/?linkid=321287</pc></target>
        </segment>
      </unit>
      <unit id="616">
        <segment state="initial">
          <source>Appendix A – Secure Boot PKI checklist for manufacturing</source>
          <target>Appendix A – Secure Boot PKI checklist for manufacturing</target>
        </segment>
      </unit>
      <unit id="617">
        <segment state="initial">
          <source>Below is a high-level checklist summarizing the steps needed for enabling Secure Boot on non-Windows RT PCs.</source>
          <target>Below is a high-level checklist summarizing the steps needed for enabling Secure Boot on non-Windows RT PCs.</target>
        </segment>
      </unit>
      <unit id="618">
        <segment state="initial">
          <source>Setting up Secure Boot</source>
          <target>Setting up Secure Boot</target>
        </segment>
      </unit>
      <unit id="619">
        <segment state="initial">
          <source>Define security strategy (identify threats, define proactive and reactive strategy) as per the white paper in section 4.</source>
          <target>Define security strategy (identify threats, define proactive and reactive strategy) as per the white paper in section 4.</target>
        </segment>
      </unit>
      <unit id="620">
        <segment state="initial">
          <source>Identify security team as per the white paper in section 4.</source>
          <target>Identify security team as per the white paper in section 4.</target>
        </segment>
      </unit>
      <unit id="621">
        <segment state="initial">
          <source>Establish a secure CA or identify a partner (recommended solution) to securely generate and store keys.</source>
          <target>Establish a secure CA or identify a partner (recommended solution) to securely generate and store keys.</target>
        </segment>
      </unit>
      <unit id="622">
        <segment state="initial">
          <source>Identify policy for how frequently you will be rekeying keys.</source>
          <target>Identify policy for how frequently you will be rekeying keys.</target>
        </segment>
      </unit>
      <unit id="623">
        <segment state="initial">
          <source>This may depend on if you have any special customer requirements like governments or other agencies.</source>
          <target>This may depend on if you have any special customer requirements like governments or other agencies.</target>
        </segment>
      </unit>
      <unit id="624">
        <segment state="initial">
          <source>Have a contingency plan in case the Secure Boot Key is compromised.</source>
          <target>Have a contingency plan in case the Secure Boot Key is compromised.</target>
        </segment>
      </unit>
      <unit id="625">
        <segment state="initial">
          <source>Identify how many PK and other keys will you be generating as per section 1.3.3 and 1.5.</source>
          <target>Identify how many PK and other keys will you be generating as per section 1.3.3 and 1.5.</target>
        </segment>
      </unit>
      <unit id="626">
        <segment state="initial">
          <source>This will be based on customer base, key storage solution and security of PCs.</source>
          <target>This will be based on customer base, key storage solution and security of PCs.</target>
        </segment>
      </unit>
      <unit id="627">
        <segment state="initial">
          <source>You can skip steps 7-8 if you are using the recommended solution of using a 3rd party for key management.</source>
          <target>You can skip steps 7-8 if you are using the recommended solution of using a 3rd party for key management.</target>
        </segment>
      </unit>
      <unit id="628">
        <segment state="initial">
          <source>Procure server and hardware for key management.</source>
          <target>Procure server and hardware for key management.</target>
        </segment>
      </unit>
      <unit id="629">
        <segment state="initial">
          <source>– network or standalone HSM per section 2.2.1.</source>
          <target>– network or standalone HSM per section 2.2.1.</target>
        </segment>
      </unit>
      <unit id="630">
        <segment state="initial">
          <source>Consider whether you will need one or several HSMs for high availability and your key back up strategy.</source>
          <target>Consider whether you will need one or several HSMs for high availability and your key back up strategy.</target>
        </segment>
      </unit>
      <unit id="631">
        <segment state="initial">
          <source>Identify at least 3-4 team members who will have an authentication token for authentication on HSM.</source>
          <target>Identify at least 3-4 team members who will have an authentication token for authentication on HSM.</target>
        </segment>
      </unit>
      <unit id="632">
        <segment state="initial">
          <source>Use HSM or 3rd party to pre-generate Secure Boot-related keys and certificates.</source>
          <target>Use HSM or 3rd party to pre-generate Secure Boot-related keys and certificates.</target>
        </segment>
      </unit>
      <unit id="633">
        <segment state="initial">
          <source>The keys will depend on the PC type: SoC, Windows RT or non-Windows RT.</source>
          <target>The keys will depend on the PC type: SoC, Windows RT or non-Windows RT.</target>
        </segment>
      </unit>
      <unit id="634">
        <segment state="initial">
          <source>For more info, see Sections 1.3 through 1.5.</source>
          <target>For more info, see Sections 1.3 through 1.5.</target>
        </segment>
      </unit>
      <unit id="635">
        <segment state="initial">
          <source>Populate the firmware with the appropriate keys.</source>
          <target>Populate the firmware with the appropriate keys.</target>
        </segment>
      </unit>
      <unit id="636">
        <segment state="initial">
          <source>Enroll the Secure Boot Platform Key to enable Secure Boot.</source>
          <target>Enroll the Secure Boot Platform Key to enable Secure Boot.</target>
        </segment>
      </unit>
      <unit id="637">
        <segment state="initial">
          <source>See Appendix B for more details.</source>
          <target>See Appendix B for more details.</target>
        </segment>
      </unit>
      <unit id="638">
        <segment state="initial">
          <source>Execute any proprietary tests and HCK Secure Boot tests as per instructions.</source>
          <target>Execute any proprietary tests and HCK Secure Boot tests as per instructions.</target>
        </segment>
      </unit>
      <unit id="639">
        <segment state="initial">
          <source>See Appendix B for more details.</source>
          <target>See Appendix B for more details.</target>
        </segment>
      </unit>
      <unit id="640">
        <segment state="initial">
          <source>Ship the PC.</source>
          <target>Ship the PC.</target>
        </segment>
      </unit>
      <unit id="641">
        <segment state="initial">
          <source>The PKpriv will likely never be used again, keep it safe.</source>
          <target>The PKpriv will likely never be used again, keep it safe.</target>
        </segment>
      </unit>
      <unit id="642">
        <segment state="initial">
          <source>Servicing (Updating firmware)</source>
          <target>Servicing (Updating firmware)</target>
        </segment>
      </unit>
      <unit id="643">
        <segment state="initial">
          <source>You may need to update firmware for several reasons such as updating an UEFI component or fixing Secure Boot key compromise or periodic rekeying of Secure Boot keys.</source>
          <target>You may need to update firmware for several reasons such as updating an UEFI component or fixing Secure Boot key compromise or periodic rekeying of Secure Boot keys.</target>
        </segment>
      </unit>
      <unit id="644">
        <segment state="initial">
          <source>For more info, see Section 1.3.5 and section 1.3.6.</source>
          <target>For more info, see Section 1.3.5 and section 1.3.6.</target>
        </segment>
      </unit>
      <unit id="645">
        <segment state="initial">
          <source>Appendix B – Secure Boot APIs</source>
          <target>Appendix B – Secure Boot APIs</target>
        </segment>
      </unit>
      <unit id="646">
        <segment state="initial">
          <source>Secure Boot API</source>
          <target>Secure Boot API</target>
        </segment>
      </unit>
      <unit id="647">
        <segment state="initial">
          <source>The following APIs are related to UEFI/Secure Boot:</source>
          <target>The following APIs are related to UEFI/Secure Boot:</target>
        </segment>
      </unit>
      <unit id="648">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=398262)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetFirmwareEnvironmentVariableEx</pc>: Retrieves the value of the specified firmware environment variable.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetFirmwareEnvironmentVariableEx</pc>: Retrieves the value of the specified firmware environment variable.</target>
        </segment>
      </unit>
      <unit id="649">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=398263)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetFirmwareEnvironmentVariableEx</pc>: Sets the value of the specified firmware environment variable.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetFirmwareEnvironmentVariableEx</pc>: Sets the value of the specified firmware environment variable.</target>
        </segment>
      </unit>
      <unit id="650">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkId=398264)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetFirmwareType</pc>: Retrieves the firmware type.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetFirmwareType</pc>: Retrieves the firmware type.</target>
        </segment>
      </unit>
      <unit id="651">
        <segment state="initial">
          <source>Setting PK</source>
          <target>Setting PK</target>
        </segment>
      </unit>
      <unit id="652">
        <segment state="initial">
          <source>Use the Set-SecureBootUEFI cmdlet to turn on Secure Boot.</source>
          <target>Use the Set-SecureBootUEFI cmdlet to turn on Secure Boot.</target>
        </segment>
      </unit>
      <unit id="653">
        <segment state="initial">
          <source>After your code sets the PK, system enforcement of Secure Boot does not take effect until the next reboot.</source>
          <target>After your code sets the PK, system enforcement of Secure Boot does not take effect until the next reboot.</target>
        </segment>
      </unit>
      <unit id="654">
        <segment state="initial">
          <source>Prior to the reboot, your code could call GetFirmwareEnvironmentVariableEx() or the PowerShell cmdlet: Get-SecureBootUEFI to confirm the contents of the Secure Boot databases.</source>
          <target>Prior to the reboot, your code could call GetFirmwareEnvironmentVariableEx() or the PowerShell cmdlet: Get-SecureBootUEFI to confirm the contents of the Secure Boot databases.</target>
        </segment>
      </unit>
      <unit id="655">
        <segment state="initial">
          <source>Verification</source>
          <target>Verification</target>
        </segment>
      </unit>
      <unit id="656">
        <segment state="initial">
          <source>You can use Msinfo32.exe or PowerShell cmdlets to check Secure Boot variable state.</source>
          <target>You can use Msinfo32.exe or PowerShell cmdlets to check Secure Boot variable state.</target>
        </segment>
      </unit>
      <unit id="657">
        <segment state="initial">
          <source>There is no WMI interface.</source>
          <target>There is no WMI interface.</target>
        </segment>
      </unit>
      <unit id="658">
        <segment state="initial">
          <source>You could also test by having someone insert an incorrectly-signed bootable USB stick (for example, from the Windows HCK Secure Boot Manual Logo Test) and verify that it fails to boot.</source>
          <target>You could also test by having someone insert an incorrectly-signed bootable USB stick (for example, from the Windows HCK Secure Boot Manual Logo Test) and verify that it fails to boot.</target>
        </segment>
      </unit>
      <unit id="659">
        <segment state="initial">
          <source>Secure Boot Powershell Cmdlets</source>
          <target>Secure Boot Powershell Cmdlets</target>
        </segment>
      </unit>
      <unit id="660">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Confirm-SecureBootUEFI</pc>: Is UEFI Secure Boot “ON”, True or False?</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Confirm-SecureBootUEFI</pc>: Is UEFI Secure Boot “ON”, True or False?</target>
        </segment>
      </unit>
      <unit id="661">
        <segment state="initial">
          <source>SetupMode == 0 &amp;&amp; SecureBoot == 1</source>
          <target>SetupMode == 0 &amp;&amp; SecureBoot == 1</target>
        </segment>
      </unit>
      <unit id="662">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Set-SecureBootUEFI</pc>: Set or Append authenticated SecureBoot UEFI variables</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Set-SecureBootUEFI</pc>: Set or Append authenticated SecureBoot UEFI variables</target>
        </segment>
      </unit>
      <unit id="663">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Get-SecureBootUEFI</pc>: Get authenticated SecureBoot UEFI variable values</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Get-SecureBootUEFI</pc>: Get authenticated SecureBoot UEFI variable values</target>
        </segment>
      </unit>
      <unit id="664">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
          <data id="id7">\_</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Format-SecureBootUEFI</pc>: Creates EFI<ph dataRef="id3" id="ph1" />SIGNATURE<ph dataRef="id4" id="ph2" />LISTs &amp; EFI<ph dataRef="id5" id="ph3" />VARIABLE<ph dataRef="id6" id="ph4" />AUTHENTICATION<ph dataRef="id7" id="ph5" />2 serializations</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Format-SecureBootUEFI</pc>: Creates EFI<ph dataRef="id3" id="ph1" />SIGNATURE<ph dataRef="id4" id="ph2" />LISTs &amp; EFI<ph dataRef="id5" id="ph3" />VARIABLE<ph dataRef="id6" id="ph4" />AUTHENTICATION<ph dataRef="id7" id="ph5" />2 serializations</target>
        </segment>
      </unit>
      <unit id="665">
        <segment state="initial">
          <source>Windows HCK and Secure Boot Instructions</source>
          <target>Windows HCK and Secure Boot Instructions</target>
        </segment>
      </unit>
      <unit id="666">
        <segment state="initial">
          <source>The following steps apply to system tests and non-class driver PC tests.</source>
          <target>The following steps apply to system tests and non-class driver PC tests.</target>
        </segment>
      </unit>
      <unit id="667">
        <segment state="initial">
          <source>Disable Secure Boot protections.</source>
          <target>Disable Secure Boot protections.</target>
        </segment>
      </unit>
      <unit id="668">
        <segment state="initial">
          <source>Enter your BIOS configuration and disable Secure Boot.</source>
          <target>Enter your BIOS configuration and disable Secure Boot.</target>
        </segment>
      </unit>
      <unit id="669">
        <segment state="initial">
          <source>Install the HCK Client software.</source>
          <target>Install the HCK Client software.</target>
        </segment>
      </unit>
      <unit id="670">
        <segment state="initial">
          <source>Run all of the Windows HCK tests, except for the following:</source>
          <target>Run all of the Windows HCK tests, except for the following:</target>
        </segment>
      </unit>
      <unit id="671">
        <originalData>
          <data id="id1">\[</data>
        </originalData>
        <segment state="initial">
          <source>BitLocker TPM and Recovery password tests with PCR<ph dataRef="id1" id="ph1" />7</source>
          <target>BitLocker TPM and Recovery password tests with PCR<ph dataRef="id1" id="ph1" />7</target>
        </segment>
      </unit>
      <unit id="672">
        <segment state="initial">
          <source>BitLocker TPM and Recovery password tests for ARM PCs with Secure Boot</source>
          <target>BitLocker TPM and Recovery password tests for ARM PCs with Secure Boot</target>
        </segment>
      </unit>
      <unit id="673">
        <segment state="initial">
          <source>Secure Boot Logo Test</source>
          <target>Secure Boot Logo Test</target>
        </segment>
      </unit>
      <unit id="674">
        <segment state="initial">
          <source>Secure Boot Manual Logo Test</source>
          <target>Secure Boot Manual Logo Test</target>
        </segment>
      </unit>
      <unit id="675">
        <segment state="initial">
          <source>Enter your BIOS configuration, enable Secure Boot, and restore Secure Boot to the Default configuration.</source>
          <target>Enter your BIOS configuration, enable Secure Boot, and restore Secure Boot to the Default configuration.</target>
        </segment>
      </unit>
      <unit id="676">
        <segment state="initial">
          <source>Run the following BitLocker and Secure Boot tests:</source>
          <target>Run the following BitLocker and Secure Boot tests:</target>
        </segment>
      </unit>
      <unit id="677">
        <originalData>
          <data id="id1">\[</data>
        </originalData>
        <segment state="initial">
          <source>BitLocker TPM and Recovery password tests with PCR<ph dataRef="id1" id="ph1" />7</source>
          <target>BitLocker TPM and Recovery password tests with PCR<ph dataRef="id1" id="ph1" />7</target>
        </segment>
      </unit>
      <unit id="678">
        <segment state="initial">
          <source>BitLocker TPM and Recovery password tests for ARM PCs with Secure Boot</source>
          <target>BitLocker TPM and Recovery password tests for ARM PCs with Secure Boot</target>
        </segment>
      </unit>
      <unit id="679">
        <segment state="initial">
          <source>Secure Boot Logo Test (automated)</source>
          <target>Secure Boot Logo Test (automated)</target>
        </segment>
      </unit>
      <unit id="680">
        <segment state="initial">
          <source>Enter the BIOS configuration and clear the Secure Boot configuration.</source>
          <target>Enter the BIOS configuration and clear the Secure Boot configuration.</target>
        </segment>
      </unit>
      <unit id="681">
        <segment state="initial">
          <source>This restores the PC to Setup Mode by deleting PK and other keys.</source>
          <target>This restores the PC to Setup Mode by deleting PK and other keys.</target>
        </segment>
      </unit>
      <unit id="682">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="683">
        <segment state="initial">
          <source>Support for clearing is required for x86/x64 PCs.</source>
          <target>Support for clearing is required for x86/x64 PCs.</target>
        </segment>
      </unit>
      <unit id="684">
        <segment state="initial">
          <source>Run the Secure Boot Manual Logo Test.</source>
          <target>Run the Secure Boot Manual Logo Test.</target>
        </segment>
      </unit>
      <unit id="685">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="686">
        <segment state="initial">
          <source>Secure Boot requires Windows HCK signed or VeriSign drivers on non-Windows RT PCs</source>
          <target>Secure Boot requires Windows HCK signed or VeriSign drivers on non-Windows RT PCs</target>
        </segment>
      </unit>
      <unit id="687">
        <segment state="initial">
          <source>Windows HCK Secure Boot Logo Test (automated)</source>
          <target>Windows HCK Secure Boot Logo Test (automated)</target>
        </segment>
      </unit>
      <unit id="688">
        <segment state="initial">
          <source>This test will check for proper out-of-box Secure Boot configuration.</source>
          <target>This test will check for proper out-of-box Secure Boot configuration.</target>
        </segment>
      </unit>
      <unit id="689">
        <segment state="initial">
          <source>This includes:</source>
          <target>This includes:</target>
        </segment>
      </unit>
      <unit id="690">
        <segment state="initial">
          <source>Secure Boot is Enabled.</source>
          <target>Secure Boot is Enabled.</target>
        </segment>
      </unit>
      <unit id="691">
        <segment state="initial">
          <source>The PK is not a known, test PK.</source>
          <target>The PK is not a known, test PK.</target>
        </segment>
      </unit>
      <unit id="692">
        <segment state="initial">
          <source>KEK contains the production Microsoft KEK.</source>
          <target>KEK contains the production Microsoft KEK.</target>
        </segment>
      </unit>
      <unit id="693">
        <segment state="initial">
          <source>db contains the production Windows CA.</source>
          <target>db contains the production Windows CA.</target>
        </segment>
      </unit>
      <unit id="694">
        <segment state="initial">
          <source>dbx present.</source>
          <target>dbx present.</target>
        </segment>
      </unit>
      <unit id="695">
        <segment state="initial">
          <source>Many 1kB variables are created/deleted.</source>
          <target>Many 1kB variables are created/deleted.</target>
        </segment>
      </unit>
      <unit id="696">
        <segment state="initial">
          <source>A 32kB variable is created/deleted.</source>
          <target>A 32kB variable is created/deleted.</target>
        </segment>
      </unit>
      <unit id="697">
        <segment state="initial">
          <source>Windows HCK Secure Boot manual test folder layout</source>
          <target>Windows HCK Secure Boot manual test folder layout</target>
        </segment>
      </unit>
      <unit id="698">
        <segment state="initial">
          <source>The Windows HCK Secure Boot Manual Logo test folder layout is described below:</source>
          <target>The Windows HCK Secure Boot Manual Logo test folder layout is described below:</target>
        </segment>
      </unit>
      <unit id="699">
        <segment state="initial">
          <source>folder has the following:</source>
          <target>folder has the following:</target>
        </segment>
      </unit>
      <unit id="700">
        <segment state="initial">
          <source>Manufacturing and Servicing Test</source>
          <target>Manufacturing and Servicing Test</target>
        </segment>
      </unit>
      <unit id="701">
        <segment state="initial">
          <source>Programmatically Enable Secure Boot in test configuration</source>
          <target>Programmatically Enable Secure Boot in test configuration</target>
        </segment>
      </unit>
      <unit id="702">
        <segment state="initial">
          <source>Servicing Tests</source>
          <target>Servicing Tests</target>
        </segment>
      </unit>
      <unit id="703">
        <segment state="initial">
          <source>Append a cert to db, verify function</source>
          <target>Append a cert to db, verify function</target>
        </segment>
      </unit>
      <unit id="704">
        <segment state="initial">
          <source>Append a hash to dbx, verify function</source>
          <target>Append a hash to dbx, verify function</target>
        </segment>
      </unit>
      <unit id="705">
        <segment state="initial">
          <source>Append a cert to dbx, verify function</source>
          <target>Append a cert to dbx, verify function</target>
        </segment>
      </unit>
      <unit id="706">
        <segment state="initial">
          <source>Append 600+ hashes to dbx, verify size</source>
          <target>Append 600+ hashes to dbx, verify size</target>
        </segment>
      </unit>
      <unit id="707">
        <segment state="initial">
          <source>Programmatically change the PK</source>
          <target>Programmatically change the PK</target>
        </segment>
      </unit>
      <unit id="708">
        <segment state="initial">
          <source>folder has scripts which show the following:</source>
          <target>folder has scripts which show the following:</target>
        </segment>
      </unit>
      <unit id="709">
        <segment state="initial">
          <source>How test certificates were created</source>
          <target>How test certificates were created</target>
        </segment>
      </unit>
      <unit id="710">
        <segment state="initial">
          <source>The test certificates and private keys are included</source>
          <target>The test certificates and private keys are included</target>
        </segment>
      </unit>
      <unit id="711">
        <segment state="initial">
          <source>How all of the tests were created</source>
          <target>How all of the tests were created</target>
        </segment>
      </unit>
      <unit id="712">
        <segment state="initial">
          <source>Turning certificates and hashes into signed packages</source>
          <target>Turning certificates and hashes into signed packages</target>
        </segment>
      </unit>
      <unit id="713">
        <segment state="initial">
          <source>You can run this yourself, substitute your own certificates</source>
          <target>You can run this yourself, substitute your own certificates</target>
        </segment>
      </unit>
      <unit id="714">
        <segment state="initial">
          <source>folder has all of the certificates you need to boot Windows:</source>
          <target>folder has all of the certificates you need to boot Windows:</target>
        </segment>
      </unit>
      <unit id="715">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="716">
        <originalData>
          <data id="id1">\\</data>
          <data id="id2">\\</data>
        </originalData>
        <segment state="initial">
          <source>Please don’t use the methodology used in “ManualTests<ph dataRef="id1" id="ph1" />generate<ph dataRef="id2" id="ph2" />TestCerts” to generate keys and certificates.</source>
          <target>Please don’t use the methodology used in “ManualTests<ph dataRef="id1" id="ph1" />generate<ph dataRef="id2" id="ph2" />TestCerts” to generate keys and certificates.</target>
        </segment>
      </unit>
      <unit id="717">
        <segment state="initial">
          <source>This is meant for Windows HCK test purposes only.</source>
          <target>This is meant for Windows HCK test purposes only.</target>
        </segment>
      </unit>
      <unit id="718">
        <segment state="initial">
          <source>It uses keys which are stored on disk which is very insecure and not recommended.</source>
          <target>It uses keys which are stored on disk which is very insecure and not recommended.</target>
        </segment>
      </unit>
      <unit id="719">
        <segment state="initial">
          <source>This is not meant for use in a production environment.</source>
          <target>This is not meant for use in a production environment.</target>
        </segment>
      </unit>
      <unit id="720">
        <segment state="initial">
          <source>folder has scripts which you can leverage for installation of Secure Boot on production PCs.</source>
          <target>folder has scripts which you can leverage for installation of Secure Boot on production PCs.</target>
        </segment>
      </unit>
      <unit id="721">
        <originalData>
          <data id="id1">\\</data>
          <data id="id2">\\</data>
          <data id="id3">\\</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
        </originalData>
        <segment state="initial">
          <source>The “ManualTests<ph dataRef="id1" id="ph1" />generate<ph dataRef="id2" id="ph2" />tests<ph dataRef="id3" id="ph3" />subcreate<ph dataRef="id4" id="ph4" />outofbox<ph dataRef="id5" id="ph5" />example.ps1” demonstrates how these examples were generated and have “TODO” sections when a partner can substitute their PK and other metadata.</source>
          <target>The “ManualTests<ph dataRef="id1" id="ph1" />generate<ph dataRef="id2" id="ph2" />tests<ph dataRef="id3" id="ph3" />subcreate<ph dataRef="id4" id="ph4" />outofbox<ph dataRef="id5" id="ph5" />example.ps1” demonstrates how these examples were generated and have “TODO” sections when a partner can substitute their PK and other metadata.</target>
        </segment>
      </unit>
      <unit id="722">
        <segment state="initial">
          <source>Windows HCK UEFI signing and submission</source>
          <target>Windows HCK UEFI signing and submission</target>
        </segment>
      </unit>
      <unit id="723">
        <segment state="initial">
          <source>The following links have more information:</source>
          <target>The following links have more information:</target>
        </segment>
      </unit>
      <unit id="724">
        <segment state="initial">
          <source>Hardware Developer Center Dashboard</source>
          <target>Hardware Developer Center Dashboard</target>
        </segment>
      </unit>
      <unit id="725">
        <segment state="initial">
          <source>UEFI Firmware Signing</source>
          <target>UEFI Firmware Signing</target>
        </segment>
      </unit>
      <unit id="726">
        <segment state="initial">
          <source>Windows Certification Dashboard Administration</source>
          <target>Windows Certification Dashboard Administration</target>
        </segment>
      </unit>
      <unit id="727">
        <segment state="initial">
          <source>Windows Hardware Certification blog: Microsoft UEFI CA Signing policy updates</source>
          <target>Windows Hardware Certification blog: Microsoft UEFI CA Signing policy updates</target>
        </segment>
      </unit>
      <unit id="728">
        <segment state="initial">
          <source>Appendix C – Federal Bridge Certification Authority Certificate Policy Assurance Mappings</source>
          <target>Appendix C – Federal Bridge Certification Authority Certificate Policy Assurance Mappings</target>
        </segment>
      </unit>
      <unit id="729">
        <segment state="initial">
          <source>Rudimentary</source>
          <target>Rudimentary</target>
        </segment>
      </unit>
      <unit id="730">
        <segment state="initial">
          <source>This level provides the lowest degree of assurance concerning identity of the individual.</source>
          <target>This level provides the lowest degree of assurance concerning identity of the individual.</target>
        </segment>
      </unit>
      <unit id="731">
        <segment state="initial">
          <source>One of the primary functions of this level is to provide data integrity to the information being signed.</source>
          <target>One of the primary functions of this level is to provide data integrity to the information being signed.</target>
        </segment>
      </unit>
      <unit id="732">
        <segment state="initial">
          <source>This level is relevant to environments in which the risk of malicious activity is considered to be low.</source>
          <target>This level is relevant to environments in which the risk of malicious activity is considered to be low.</target>
        </segment>
      </unit>
      <unit id="733">
        <segment state="initial">
          <source>It is not suitable for transactions requiring authentication, and is generally insufficient for transactions requiring confidentiality, but may be used for the latter where certificates having higher levels of assurance are unavailable.</source>
          <target>It is not suitable for transactions requiring authentication, and is generally insufficient for transactions requiring confidentiality, but may be used for the latter where certificates having higher levels of assurance are unavailable.</target>
        </segment>
      </unit>
      <unit id="734">
        <segment state="initial">
          <source>Basic</source>
          <target>Basic</target>
        </segment>
      </unit>
      <unit id="735">
        <segment state="initial">
          <source>This level provides a basic level of assurance relevant to environments where there are risks and consequences of data compromise, but they are not considered to be of major significance.</source>
          <target>This level provides a basic level of assurance relevant to environments where there are risks and consequences of data compromise, but they are not considered to be of major significance.</target>
        </segment>
      </unit>
      <unit id="736">
        <segment state="initial">
          <source>This may include access to private information where the likelihood of malicious access is not high.</source>
          <target>This may include access to private information where the likelihood of malicious access is not high.</target>
        </segment>
      </unit>
      <unit id="737">
        <segment state="initial">
          <source>It is assumed at this security level that users are not likely to be malicious.</source>
          <target>It is assumed at this security level that users are not likely to be malicious.</target>
        </segment>
      </unit>
      <unit id="738">
        <segment state="initial">
          <source>Medium</source>
          <target>Medium</target>
        </segment>
      </unit>
      <unit id="739">
        <segment state="initial">
          <source>This level is relevant to environments where risks and consequences of data compromise are moderate.</source>
          <target>This level is relevant to environments where risks and consequences of data compromise are moderate.</target>
        </segment>
      </unit>
      <unit id="740">
        <segment state="initial">
          <source>This may include transactions having substantial monetary value or risk of fraud, or involving access to private information where the likelihood of malicious access is substantial.</source>
          <target>This may include transactions having substantial monetary value or risk of fraud, or involving access to private information where the likelihood of malicious access is substantial.</target>
        </segment>
      </unit>
      <unit id="741">
        <segment state="initial">
          <source>High</source>
          <target>High</target>
        </segment>
      </unit>
      <unit id="742">
        <segment state="initial">
          <source>This level is appropriate for use where the threats to data are high, or the consequences of the failure of security services are high.</source>
          <target>This level is appropriate for use where the threats to data are high, or the consequences of the failure of security services are high.</target>
        </segment>
      </unit>
      <unit id="743">
        <segment state="initial">
          <source>This may include very high value transactions or high levels of fraud risk.</source>
          <target>This may include very high value transactions or high levels of fraud risk.</target>
        </segment>
      </unit>
      <unit id="744">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="745">
        <segment state="initial">
          <source>Secure Boot Key Generation and Signing Using HSM (Example)</source>
          <target>Secure Boot Key Generation and Signing Using HSM (Example)</target>
        </segment>
      </unit>
      <unit id="746">
        <segment state="initial">
          <source>UEFI Validation Option ROM Validation Guidance</source>
          <target>UEFI Validation Option ROM Validation Guidance</target>
        </segment>
      </unit>
      <unit id="747">
        <segment state="initial">
          <source>Secure Boot Overview</source>
          <target>Secure Boot Overview</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>