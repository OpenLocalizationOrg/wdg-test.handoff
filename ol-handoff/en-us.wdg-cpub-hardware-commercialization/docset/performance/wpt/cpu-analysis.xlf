<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationtype">Human Translation</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">docset\performance\wpt\cpu-analysis.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">02b81e2652520b142d9e4c564893bd906b5b47aa</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-48076a9</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>CPU Analysis</source>
          <target>CPU Analysis</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>CPU Analysis</source>
          <target>CPU Analysis</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>CPU Analysis</source>
          <target>CPU Analysis</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>This guide provides detailed techniques that you can use to investigate Central Processing Units (CPU)-related issues that impact assessment metrics.</source>
          <target>This guide provides detailed techniques that you can use to investigate Central Processing Units (CPU)-related issues that impact assessment metrics.</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>The individual metric or issue sections in the assessment-specific analysis guides identify common problems for investigation.</source>
          <target>The individual metric or issue sections in the assessment-specific analysis guides identify common problems for investigation.</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>This guide provides techniques and tools that you can use to investigate those problems.</source>
          <target>This guide provides techniques and tools that you can use to investigate those problems.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>The techniques in this guide use the Windows Performance Analyzer (WPA) from the Windows Performance Toolkit (WPT).</source>
          <target>The techniques in this guide use the Windows Performance Analyzer (WPA) from the Windows Performance Toolkit (WPT).</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://insider.windows.com/)</data>
        </originalData>
        <segment state="initial">
          <source>The WPT is part of the Windows Assessment and Deployment Kit (Windows ADK) and it can be downloaded from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Insider Program</pc>.</source>
          <target>The WPT is part of the Windows Assessment and Deployment Kit (Windows ADK) and it can be downloaded from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Insider Program</pc>.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](windows-performance-toolkit-technical-reference.md)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Performance Toolkit Technical Reference</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Performance Toolkit Technical Reference</pc>.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>This guide is organized into the following three sections:</source>
          <target>This guide is organized into the following three sections:</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>Background</source>
          <target>Background</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>This section describes how CPU resources are managed in Windows 10.</source>
          <target>This section describes how CPU resources are managed in Windows 10.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>Windows ADK Tools</source>
          <target>Windows ADK Tools</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>This section explains how to view and interpret CPU information in the Windows ADK Toolkit.</source>
          <target>This section explains how to view and interpret CPU information in the Windows ADK Toolkit.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>Techniques</source>
          <target>Techniques</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>This section contains a collection of techniques that you can use to investigate and solve common problems that are related to CPU performance.</source>
          <target>This section contains a collection of techniques that you can use to investigate and solve common problems that are related to CPU performance.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>Background</source>
          <target>Background</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>This section contains simple descriptions and a basic discussion on CPU performance.</source>
          <target>This section contains simple descriptions and a basic discussion on CPU performance.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>For a more comprehensive study on this topic, we recommend the book Windows Internals, Fifth Edition.</source>
          <target>For a more comprehensive study on this topic, we recommend the book Windows Internals, Fifth Edition.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Modern computers can contain multiple CPUs that are installed in separate sockets.</source>
          <target>Modern computers can contain multiple CPUs that are installed in separate sockets.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>Each CPU can host multiple physical processor cores, each capable of processing one or two separate instruction streams simultaneously.</source>
          <target>Each CPU can host multiple physical processor cores, each capable of processing one or two separate instruction streams simultaneously.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>These individual instruction stream processors are managed by the Windows operating system as logical processors.</source>
          <target>These individual instruction stream processors are managed by the Windows operating system as logical processors.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>In this guide, both processor and CPU refer to a logical processor — that is, a hardware device that the operating system can use to execute program instructions.</source>
          <target>In this guide, both processor and CPU refer to a logical processor — that is, a hardware device that the operating system can use to execute program instructions.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>Windows 10 actively manages processor hardware in two main ways: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">power management</pc>, to balance power consumption and performance; and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">usage</pc>, to balance the processing requirements of programs and drivers.</source>
          <target>Windows 10 actively manages processor hardware in two main ways: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">power management</pc>, to balance power consumption and performance; and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">usage</pc>, to balance the processing requirements of programs and drivers.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>Processor Power Management</source>
          <target>Processor Power Management</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>Processors do not always exist in an operating state.</source>
          <target>Processors do not always exist in an operating state.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>When no instructions are ready to execute, Windows will put a processor into a target idle state (or C-State), as determined by the Windows Power Manager.</source>
          <target>When no instructions are ready to execute, Windows will put a processor into a target idle state (or C-State), as determined by the Windows Power Manager.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Based on CPU usage patterns, a processor’s target C-state will be adjusted over time.</source>
          <target>Based on CPU usage patterns, a processor’s target C-state will be adjusted over time.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>Idle states are numbered states from C0 (active; not idle) through progressively lower-power states.</source>
          <target>Idle states are numbered states from C0 (active; not idle) through progressively lower-power states.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>These states include C1 (halted but the clock is still enabled), C2 (halted and the clock is disabled), and so forth.</source>
          <target>These states include C1 (halted but the clock is still enabled), C2 (halted and the clock is disabled), and so forth.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>The implementation of idle states is processor-specific.</source>
          <target>The implementation of idle states is processor-specific.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>However, a higher state number in all processors reflects lower power consumption, but also a longer wait time before the processor can return to instruction processing.</source>
          <target>However, a higher state number in all processors reflects lower power consumption, but also a longer wait time before the processor can return to instruction processing.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Time that is spent in idle states significantly affects energy use and battery life.</source>
          <target>Time that is spent in idle states significantly affects energy use and battery life.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Some processors can operate in performance (P-) and throttle (T-) states even when they are actively processing instructions.</source>
          <target>Some processors can operate in performance (P-) and throttle (T-) states even when they are actively processing instructions.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>P-states define the clock frequencies and voltage levels the processor supports.</source>
          <target>P-states define the clock frequencies and voltage levels the processor supports.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>T-states do not directly change the clock frequency, but can lower the effective clock speed by skipping processing activity on some fraction of clock ticks.</source>
          <target>T-states do not directly change the clock frequency, but can lower the effective clock speed by skipping processing activity on some fraction of clock ticks.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Together, the current P- and T- states determine the effective operating frequency of the processor.</source>
          <target>Together, the current P- and T- states determine the effective operating frequency of the processor.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Lower frequencies correspond to lower performance and lower power consumption.</source>
          <target>Lower frequencies correspond to lower performance and lower power consumption.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>The Windows Power Manager determines an appropriate P- and T- state for each processor, based on CPU usage patterns and system power policy.</source>
          <target>The Windows Power Manager determines an appropriate P- and T- state for each processor, based on CPU usage patterns and system power policy.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>Time that is spent in high-performance states versus low-performance states significantly affects energy use and battery life.</source>
          <target>Time that is spent in high-performance states versus low-performance states significantly affects energy use and battery life.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Processor Usage Management</source>
          <target>Processor Usage Management</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Windows uses three major abstractions to manage processor usage.</source>
          <target>Windows uses three major abstractions to manage processor usage.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>Processes</source>
          <target>Processes</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Threads</source>
          <target>Threads</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Deferred Procedure Calls (DPCs) and Interrupt Service Routines (ISRs)</source>
          <target>Deferred Procedure Calls (DPCs) and Interrupt Service Routines (ISRs)</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>Processes and Threads</source>
          <target>Processes and Threads</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>All user-mode programs in Windows run in the context of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">process</pc>.</source>
          <target>All user-mode programs in Windows run in the context of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">process</pc>.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>A process includes the following attributes and components:</source>
          <target>A process includes the following attributes and components:</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>A virtual address space</source>
          <target>A virtual address space</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>Priority class</source>
          <target>Priority class</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Loaded program modules</source>
          <target>Loaded program modules</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>Environment and configuration information</source>
          <target>Environment and configuration information</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>At least one thread</source>
          <target>At least one thread</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>Although processes contain the program modules, context and environment, they are not directly scheduled to run on a processor.</source>
          <target>Although processes contain the program modules, context and environment, they are not directly scheduled to run on a processor.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>Instead, threads that are owned by a process are scheduled to run on a processor.</source>
          <target>Instead, threads that are owned by a process are scheduled to run on a processor.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>A thread maintains execution context information.</source>
          <target>A thread maintains execution context information.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Almost all computation is managed as part of a thread.</source>
          <target>Almost all computation is managed as part of a thread.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>Thread activity fundamentally affects measurements and system performance.</source>
          <target>Thread activity fundamentally affects measurements and system performance.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>Because the number of processors in a system is limited, all threads cannot be run at the same time.</source>
          <target>Because the number of processors in a system is limited, all threads cannot be run at the same time.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>Windows implements processor time-sharing, which allows a thread to run for a period of time before the processor switches to another thread.</source>
          <target>Windows implements processor time-sharing, which allows a thread to run for a period of time before the processor switches to another thread.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The act of switching between threads is called a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">context-switch</pc> and it is performed by a Windows component called the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">dispatcher</pc>.</source>
          <target>The act of switching between threads is called a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">context-switch</pc> and it is performed by a Windows component called the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">dispatcher</pc>.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
          <data id="id7">*</data>
          <data id="id8">*</data>
        </originalData>
        <segment state="initial">
          <source>The dispatcher makes thread scheduling decisions based on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">priority</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ideal processor and affinity</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">quantum</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">state</pc>.</source>
          <target>The dispatcher makes thread scheduling decisions based on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">priority</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ideal processor and affinity</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">quantum</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">state</pc>.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>Priority</source>
          <target>Priority</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>Priority is a key factor in how the dispatcher selects which thread to run.</source>
          <target>Priority is a key factor in how the dispatcher selects which thread to run.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>Thread priority is an integer from 0 to 31.</source>
          <target>Thread priority is an integer from 0 to 31.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>If a thread is executable and has a higher priority than a currently running thread, the lower-priority thread is immediately preempted and the higher-priority thread is context-switched in.</source>
          <target>If a thread is executable and has a higher priority than a currently running thread, the lower-priority thread is immediately preempted and the higher-priority thread is context-switched in.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>When a thread is running or is ready to run, no lower-priority threads can run unless there are enough processors to run both threads at the same time, or unless the higher-priority thread is restricted to run on only a subset of available processors.</source>
          <target>When a thread is running or is ready to run, no lower-priority threads can run unless there are enough processors to run both threads at the same time, or unless the higher-priority thread is restricted to run on only a subset of available processors.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Threads have a base priority that can be temporarily elevated to higher priorities at certain times: for example, when the process owns the foreground window, or when an I/O completes.</source>
          <target>Threads have a base priority that can be temporarily elevated to higher priorities at certain times: for example, when the process owns the foreground window, or when an I/O completes.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Ideal Processor and Affinity</source>
          <target>Ideal Processor and Affinity</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>A thread’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ideal processor and affinity</pc> determine the processors on which a given thread is scheduled to run.</source>
          <target>A thread’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ideal processor and affinity</pc> determine the processors on which a given thread is scheduled to run.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>Each thread has an ideal processor that is set either by the program or automatically by Windows.</source>
          <target>Each thread has an ideal processor that is set either by the program or automatically by Windows.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Windows uses a round-robin methodology so that an approximately equal number of threads in each process are assigned to each processor.</source>
          <target>Windows uses a round-robin methodology so that an approximately equal number of threads in each process are assigned to each processor.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>When possible, Windows schedules a thread to run on its ideal processor; however, the thread can occasionally run on other processors.</source>
          <target>When possible, Windows schedules a thread to run on its ideal processor; however, the thread can occasionally run on other processors.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>A thread’s processor affinity restricts the processors on which a thread will run.</source>
          <target>A thread’s processor affinity restricts the processors on which a thread will run.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>This is a stronger restriction than the thread’s ideal processor attribute.</source>
          <target>This is a stronger restriction than the thread’s ideal processor attribute.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The program sets affinity by using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadAffinityMask</pc>.</source>
          <target>The program sets affinity by using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadAffinityMask</pc>.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>Affinity can prevent threads from ever running on particular processors.</source>
          <target>Affinity can prevent threads from ever running on particular processors.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>Quantum</source>
          <target>Quantum</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>Context switches are expensive operations.</source>
          <target>Context switches are expensive operations.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Windows generally allows each thread to run for a period of time that is called a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">quantum</pc> before it switches to another thread.</source>
          <target>Windows generally allows each thread to run for a period of time that is called a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">quantum</pc> before it switches to another thread.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>Quantum duration is designed to preserve apparent system responsiveness.</source>
          <target>Quantum duration is designed to preserve apparent system responsiveness.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>It maximizes throughput by minimizing the overhead of context switching.</source>
          <target>It maximizes throughput by minimizing the overhead of context switching.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>Quantum durations can vary between clients and servers.</source>
          <target>Quantum durations can vary between clients and servers.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>Quantum durations are typically longer on a server to maximize throughput at the expense of apparent responsiveness.</source>
          <target>Quantum durations are typically longer on a server to maximize throughput at the expense of apparent responsiveness.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>On client computers, Windows assigns shorter quantums overall, but provides a longer quantum to the thread associated with the current foreground window.</source>
          <target>On client computers, Windows assigns shorter quantums overall, but provides a longer quantum to the thread associated with the current foreground window.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>State</source>
          <target>State</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>Each thread exists in a particular execution state at any given time.</source>
          <target>Each thread exists in a particular execution state at any given time.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>Windows uses three states that are relevant to performance; these are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Running</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Waiting</pc>.</source>
          <target>Windows uses three states that are relevant to performance; these are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Running</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Waiting</pc>.</target>
        </segment>
      </unit>
      <unit id="189">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Threads that are currently being executed are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Running</pc> state.</source>
          <target>Threads that are currently being executed are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Running</pc> state.</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Threads that can execute but are currently not running are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready</pc> state.</source>
          <target>Threads that can execute but are currently not running are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready</pc> state.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Threads that cannot run because they are waiting for a particular event are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting</pc> state.</source>
          <target>Threads that cannot run because they are waiting for a particular event are in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting</pc> state.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>A state to state transition is shown in Figure 1 Thread State Transitions:</source>
          <target>A state to state transition is shown in Figure 1 Thread State Transitions:</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>figure 1 thread state transition</source>
          <target>figure 1 thread state transition</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>Figure 1 Thread State Transitions</source>
          <target>Figure 1 Thread State Transitions</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>Figure 1 Thread State Transitions is explained as follows:</source>
          <target>Figure 1 Thread State Transitions is explained as follows:</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>A thread in the Running state initiates a transition to the Waiting state by calling a wait function such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WaitForSingleObject</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sleep(<ph dataRef="id5" id="ph1" /> 0)</pc>.</source>
          <target>A thread in the Running state initiates a transition to the Waiting state by calling a wait function such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WaitForSingleObject</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sleep(<ph dataRef="id5" id="ph1" /> 0)</pc>.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>A running thread or kernel operation readies a thread in the Waiting state (for example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetEvent</pc> or timer expiration).</source>
          <target>A running thread or kernel operation readies a thread in the Waiting state (for example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetEvent</pc> or timer expiration).</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>If a processor is idle or if the readied thread has a higher priority than a currently running thread, the readied thread can switch directly to the Running state.</source>
          <target>If a processor is idle or if the readied thread has a higher priority than a currently running thread, the readied thread can switch directly to the Running state.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>Otherwise, it is put into the Ready state.</source>
          <target>Otherwise, it is put into the Ready state.</target>
        </segment>
      </unit>
      <unit id="200">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>A thread in the Ready state is scheduled for processing by the dispatcher when a running thread waits, yields <pc dataRefEnd="id2" dataRefStart="id1" id="p1">(Sleep(0))</pc>, or reaches the end of its quantum.</source>
          <target>A thread in the Ready state is scheduled for processing by the dispatcher when a running thread waits, yields <pc dataRefEnd="id2" dataRefStart="id1" id="p1">(Sleep(0))</pc>, or reaches the end of its quantum.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>A thread in the Running state is switched out and placed into the Ready state by the dispatcher when it is preempted by a higher priority thread, yields <pc dataRefEnd="id2" dataRefStart="id1" id="p1">(Sleep(0))</pc>, or when its quantum ends.</source>
          <target>A thread in the Running state is switched out and placed into the Ready state by the dispatcher when it is preempted by a higher priority thread, yields <pc dataRefEnd="id2" dataRefStart="id1" id="p1">(Sleep(0))</pc>, or when its quantum ends.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>A thread that exists in the Waiting state does not necessarily indicate a performance problem.</source>
          <target>A thread that exists in the Waiting state does not necessarily indicate a performance problem.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>Most threads spend significant time in the Waiting state, which allows processors to enter idle states and save energy.</source>
          <target>Most threads spend significant time in the Waiting state, which allows processors to enter idle states and save energy.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>Thread state becomes an important factor in performance only when a user is waiting for a thread to complete an operation.</source>
          <target>Thread state becomes an important factor in performance only when a user is waiting for a thread to complete an operation.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>DPCs and ISRs</source>
          <target>DPCs and ISRs</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>In addition to processing threads, processors respond to notifications from hardware devices such as network cards or timers.</source>
          <target>In addition to processing threads, processors respond to notifications from hardware devices such as network cards or timers.</target>
        </segment>
      </unit>
      <unit id="207">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>When a hardware device requires processor attention, it generates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">interrupt</pc>.</source>
          <target>When a hardware device requires processor attention, it generates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">interrupt</pc>.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>Windows responds to a hardware interrupt by suspending a currently running thread and executing the ISR that is associated with the interrupt.</source>
          <target>Windows responds to a hardware interrupt by suspending a currently running thread and executing the ISR that is associated with the interrupt.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>During the time that it is executing an ISR, a processor can be prevented from handling any other activity, including other interrupts.</source>
          <target>During the time that it is executing an ISR, a processor can be prevented from handling any other activity, including other interrupts.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>For this reason, ISRs must complete quickly or system performance can degrade.</source>
          <target>For this reason, ISRs must complete quickly or system performance can degrade.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>To decrease execution time, ISRs commonly schedule DPCs to perform work that must be done in response to an interrupt.</source>
          <target>To decrease execution time, ISRs commonly schedule DPCs to perform work that must be done in response to an interrupt.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>For each logical processor, Windows maintains a queue of scheduled DPCs.</source>
          <target>For each logical processor, Windows maintains a queue of scheduled DPCs.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>DPCs take priority over threads at any priority level.</source>
          <target>DPCs take priority over threads at any priority level.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>Before a processor returns to processing threads, it executes all of the DPCs in its queue.</source>
          <target>Before a processor returns to processing threads, it executes all of the DPCs in its queue.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>During the time that a processor is executing DPCs and ISRs, no threads can run on that processor.</source>
          <target>During the time that a processor is executing DPCs and ISRs, no threads can run on that processor.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>This property can lead to problems for threads that must perform work at a certain throughput or with precise timing, such as a thread that plays audio or video.</source>
          <target>This property can lead to problems for threads that must perform work at a certain throughput or with precise timing, such as a thread that plays audio or video.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>If the processor time that is used to execute DPCs and ISRs prevents these threads from receiving sufficient processing time, the thread might not achieve its required throughput or complete its work items on time.</source>
          <target>If the processor time that is used to execute DPCs and ISRs prevents these threads from receiving sufficient processing time, the thread might not achieve its required throughput or complete its work items on time.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>Windows ADK Tools</source>
          <target>Windows ADK Tools</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The Windows ADK writes hardware information and assessments to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">assessments results files</pc>.</source>
          <target>The Windows ADK writes hardware information and assessments to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">assessments results files</pc>.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>WPA provides detailed information about CPU usage in various graphs.</source>
          <target>WPA provides detailed information about CPU usage in various graphs.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>This section explains how to use the Windows ADK and WPA to collect, view, and analyze CPU performance data.</source>
          <target>This section explains how to use the Windows ADK and WPA to collect, view, and analyze CPU performance data.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>Windows ADK Assessment Results Files</source>
          <target>Windows ADK Assessment Results Files</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>Because Windows supports symmetric multiprocessing systems only, all information in this section applies to all installed CPUs and cores.</source>
          <target>Because Windows supports symmetric multiprocessing systems only, all information in this section applies to all installed CPUs and cores.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">`EcoSysInfo`</data>
          <data id="id2">`&lt;Processor&gt;&lt;Instance id=”0”&gt;`</data>
        </originalData>
        <segment state="initial">
          <source>Detailed CPU hardware information is available in the <ph dataRef="id1" id="ph1" /> section of an assessment result files under the <ph dataRef="id2" id="ph2" /> node.</source>
          <target>Detailed CPU hardware information is available in the <ph dataRef="id1" id="ph1" /> section of an assessment result files under the <ph dataRef="id2" id="ph2" /> node.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>For example:</source>
          <target>For example:</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>WPA Graphs</source>
          <target>WPA Graphs</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>After you load a trace into WPA, you can find processor hardware information under the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Trace/System Configuration/General</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Trace/System Configuration/PnP</pc> sections of the WPA UI.</source>
          <target>After you load a trace into WPA, you can find processor hardware information under the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Trace/System Configuration/General</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Trace/System Configuration/PnP</pc> sections of the WPA UI.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>All procedures in this guide occur in WPA.</source>
          <target>All procedures in this guide occur in WPA.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>CPU Idle States Graph</source>
          <target>CPU Idle States Graph</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If idle state information is collected in a trace, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Power/CPU Idle States</pc> graph will display in the WPA UI.</source>
          <target>If idle state information is collected in a trace, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Power/CPU Idle States</pc> graph will display in the WPA UI.</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>This graph always contains data on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc> idle state for each processor.</source>
          <target>This graph always contains data on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc> idle state for each processor.</target>
        </segment>
      </unit>
      <unit id="233">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The graph will also contain information on each processor’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Actual</pc> idle state if this state is supported by the processor.</source>
          <target>The graph will also contain information on each processor’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Actual</pc> idle state if this state is supported by the processor.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>Each row in the following table describes an idle state change for either the Target or Actual state of a processor.</source>
          <target>Each row in the following table describes an idle state change for either the Target or Actual state of a processor.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>The following columns are available for each row in the graph:</source>
          <target>The following columns are available for each row in the graph:</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source>Column</source>
          <target>Column</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>Details</source>
          <target>Details</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>CPU</source>
          <target>CPU</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>The processor that is affected by the state change.</source>
          <target>The processor that is affected by the state change.</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>Entry Time</source>
          <target>Entry Time</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>The time that the processor entered the idle state.</source>
          <target>The time that the processor entered the idle state.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>Exit Time</source>
          <target>Exit Time</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>The time that the processor exited the idle state.</source>
          <target>The time that the processor exited the idle state.</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source>Max:Duration(ms)</source>
          <target>Max:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>The time that is spent in the idle state (default aggregation:maximum).</source>
          <target>The time that is spent in the idle state (default aggregation:maximum).</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>Min:Duration(ms)</source>
          <target>Min:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>The time that is spent in the idle state (default aggregation:minimum).</source>
          <target>The time that is spent in the idle state (default aggregation:minimum).</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>Next State</source>
          <target>Next State</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>The state to which the processor transitioned after the current state.</source>
          <target>The state to which the processor transitioned after the current state.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>Prev State</source>
          <target>Prev State</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>The state from which the processor transitioned before the current state.</source>
          <target>The state from which the processor transitioned before the current state.</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source>State</source>
          <target>State</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>The current idle state.</source>
          <target>The current idle state.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>State (Numeric)</source>
          <target>State (Numeric)</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source>The current idle state as a number (for example, 0 for C0).</source>
          <target>The current idle state as a number (for example, 0 for C0).</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source>Sum:Duration(ms)</source>
          <target>Sum:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>The time that is spent in the idle state (default aggregation:sum).</source>
          <target>The time that is spent in the idle state (default aggregation:sum).</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>Table</source>
          <target>Table</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>Unused</source>
          <target>Unused</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="261">
        <originalData>
          <data id="id1">&lt;strong&gt;</data>
          <data id="id2">&lt;/strong&gt;</data>
          <data id="id3">&lt;strong&gt;</data>
          <data id="id4">&lt;/strong&gt;</data>
        </originalData>
        <segment state="initial">
          <source>Either <ph dataRef="id1" id="ph1" />Target<ph dataRef="id2" id="ph2" /> (for the Power Manager’s selected target state for the processor) or <ph dataRef="id3" id="ph3" />Actual<ph dataRef="id4" id="ph4" /> (for the actual idle state of the processor).</source>
          <target>Either <ph dataRef="id1" id="ph1" />Target<ph dataRef="id2" id="ph2" /> (for the Power Manager’s selected target state for the processor) or <ph dataRef="id3" id="ph3" />Actual<ph dataRef="id4" id="ph4" /> (for the actual idle state of the processor).</target>
        </segment>
      </unit>
      <unit id="262">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The default WPA profile provides two presets for this graph: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">State by Type, CPU</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">State Diagram by Type, CPU</pc>.</source>
          <target>The default WPA profile provides two presets for this graph: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">State by Type, CPU</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">State Diagram by Type, CPU</pc>.</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source>State by Type, CPU</source>
          <target>State by Type, CPU</target>
        </segment>
      </unit>
      <unit id="264">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The Target and Actual states of each CPU are graphed together with the state number on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Y</pc> axis in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">State by Type, CPU</pc> graph.</source>
          <target>The Target and Actual states of each CPU are graphed together with the state number on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Y</pc> axis in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">State by Type, CPU</pc> graph.</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>Figure 2 CPU Idle States State by Type, CPU shows the Actual state of the CPU as it fluctuates between Active and Target idle states.</source>
          <target>Figure 2 CPU Idle States State by Type, CPU shows the Actual state of the CPU as it fluctuates between Active and Target idle states.</target>
        </segment>
      </unit>
      <unit id="266">
        <segment state="initial">
          <source>figure 2 cpu idle states state by type cpu</source>
          <target>figure 2 cpu idle states state by type cpu</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source>Figure 2 CPU Idle States State by Type, CPU</source>
          <target>Figure 2 CPU Idle States State by Type, CPU</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source>State Diagram by Type, CPU</source>
          <target>State Diagram by Type, CPU</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>In this graph, the Target and Actual states of each CPU are presented in timeline format.</source>
          <target>In this graph, the Target and Actual states of each CPU are presented in timeline format.</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>Each state has a separate row in the timeline.</source>
          <target>Each state has a separate row in the timeline.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>Figure 3 CPU Idle States State Diagram by Type, CPU shows the same data as Figure 2 CPU Idle States State by Type, CPU, in a timeline view.</source>
          <target>Figure 3 CPU Idle States State Diagram by Type, CPU shows the same data as Figure 2 CPU Idle States State by Type, CPU, in a timeline view.</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source>figure 3 cpu idle states state diagram by type cpu</source>
          <target>figure 3 cpu idle states state diagram by type cpu</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source>Figure 3 CPU Idle States State Diagram by Type, CPU</source>
          <target>Figure 3 CPU Idle States State Diagram by Type, CPU</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>CPU Frequency Graph</source>
          <target>CPU Frequency Graph</target>
        </segment>
      </unit>
      <unit id="275">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If CPU frequency data was collected on a system that supports multiple P- or T-states, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Frequency</pc> graph will be available in the WPA UI.</source>
          <target>If CPU frequency data was collected on a system that supports multiple P- or T-states, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Frequency</pc> graph will be available in the WPA UI.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>Each row in the following table represents time at a particular frequency level for a processor.</source>
          <target>Each row in the following table represents time at a particular frequency level for a processor.</target>
        </segment>
      </unit>
      <unit id="277">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Frequency (MHz)</pc> column contains a limited number of frequencies that correspond to the P-states and T-states that are supported by the processor.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Frequency (MHz)</pc> column contains a limited number of frequencies that correspond to the P-states and T-states that are supported by the processor.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>The following columns are available for each row in the graph:</source>
          <target>The following columns are available for each row in the graph:</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source>Column</source>
          <target>Column</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source>Details</source>
          <target>Details</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>% Duration</source>
          <target>% Duration</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>Duration is expressed as a percentage of total CPU time over the currently visible time period.</source>
          <target>Duration is expressed as a percentage of total CPU time over the currently visible time period.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source>Count</source>
          <target>Count</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source>The number of frequency changes (always 1 for individual rows).</source>
          <target>The number of frequency changes (always 1 for individual rows).</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>CPU</source>
          <target>CPU</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source>The CPU that is affected by the frequency change.</source>
          <target>The CPU that is affected by the frequency change.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source>Entry Time</source>
          <target>Entry Time</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source>The time that the CPU entered the P-state.</source>
          <target>The time that the CPU entered the P-state.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source>Exit Time</source>
          <target>Exit Time</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source>The time that the CPU exited the P-state.</source>
          <target>The time that the CPU exited the P-state.</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source>Frequency (MHz)</source>
          <target>Frequency (MHz)</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>The frequency of the CPU during the time that it is in the P-state.</source>
          <target>The frequency of the CPU during the time that it is in the P-state.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>Max:Duration(ms)</source>
          <target>Max:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>The time that is spent in the P-state (default aggregation:maximum).</source>
          <target>The time that is spent in the P-state (default aggregation:maximum).</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source>Min:Duration(ms)</source>
          <target>Min:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>The time that is spent in the P-state (default aggregation:minimum).</source>
          <target>The time that is spent in the P-state (default aggregation:minimum).</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>Sum:Duration(ms)</source>
          <target>Sum:Duration(ms)</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source>The time that is spent in the P-state (default aggregation:sum).</source>
          <target>The time that is spent in the P-state (default aggregation:sum).</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>Table</source>
          <target>Table</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source>Unused</source>
          <target>Unused</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source>Additional information on the P-State.</source>
          <target>Additional information on the P-State.</target>
        </segment>
      </unit>
      <unit id="303">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The default profile defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Frequency by CPU</pc> preset for this graph.</source>
          <target>The default profile defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Frequency by CPU</pc> preset for this graph.</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source>Figure 4 CPU Frequency by CPU shows a CPU as it transitions between three P-states:</source>
          <target>Figure 4 CPU Frequency by CPU shows a CPU as it transitions between three P-states:</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source>figure 4 cpu frequency by cpu</source>
          <target>figure 4 cpu frequency by cpu</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source>Figure 4 CPU Frequency by CPU</source>
          <target>Figure 4 CPU Frequency by CPU</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source>CPU Usage (Sampled) Graph</source>
          <target>CPU Usage (Sampled) Graph</target>
        </segment>
      </unit>
      <unit id="308">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The data that is displayed in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph represents samples of CPU activity that are taken at a regular sampling interval.</source>
          <target>The data that is displayed in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph represents samples of CPU activity that are taken at a regular sampling interval.</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source>In most traces, this is one millisecond (1ms).</source>
          <target>In most traces, this is one millisecond (1ms).</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source>Each row in the table represents a single sample.</source>
          <target>Each row in the table represents a single sample.</target>
        </segment>
      </unit>
      <unit id="311">
        <segment state="initial">
          <source>The weight of the sample represents the significance of that sample, relative to other samples.</source>
          <target>The weight of the sample represents the significance of that sample, relative to other samples.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source>The weight is equal to the timestamp of the current sample minus the timestamp of the previous sample.</source>
          <target>The weight is equal to the timestamp of the current sample minus the timestamp of the previous sample.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source>The weight is not always exactly equal to the sampling interval because of fluctuations in system state and activity.</source>
          <target>The weight is not always exactly equal to the sampling interval because of fluctuations in system state and activity.</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source>Figure 5 CPU Sampling represents how data is collected:</source>
          <target>Figure 5 CPU Sampling represents how data is collected:</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>figure 5 cpu sampling</source>
          <target>figure 5 cpu sampling</target>
        </segment>
      </unit>
      <unit id="316">
        <segment state="initial">
          <source>Figure 5 CPU Sampling</source>
          <target>Figure 5 CPU Sampling</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>Any CPU activity that occurs between samples is not recorded by this sampling method.</source>
          <target>Any CPU activity that occurs between samples is not recorded by this sampling method.</target>
        </segment>
      </unit>
      <unit id="318">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Therefore, activities of very short duration such as DPCs and ISRs are not well represented in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Sampling</pc> graph.</source>
          <target>Therefore, activities of very short duration such as DPCs and ISRs are not well represented in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Sampling</pc> graph.</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source>The following columns are available for each row in the graph:</source>
          <target>The following columns are available for each row in the graph:</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source>Column</source>
          <target>Column</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source>Details</source>
          <target>Details</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source>% Weight</source>
          <target>% Weight</target>
        </segment>
      </unit>
      <unit id="323">
        <segment state="initial">
          <source>Weight is expressed as a percentage of total CPU time that is spent over the currently visible time range.</source>
          <target>Weight is expressed as a percentage of total CPU time that is spent over the currently visible time range.</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source>Address</source>
          <target>Address</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source>The memory address of the function that is at the bottom of the stack.</source>
          <target>The memory address of the function that is at the bottom of the stack.</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source>All Count</source>
          <target>All Count</target>
        </segment>
      </unit>
      <unit id="327">
        <segment state="initial">
          <source>The number of samples represented by a row.</source>
          <target>The number of samples represented by a row.</target>
        </segment>
      </unit>
      <unit id="328">
        <segment state="initial">
          <source>This number includes samples that are taken when a processor is idle.</source>
          <target>This number includes samples that are taken when a processor is idle.</target>
        </segment>
      </unit>
      <unit id="329">
        <segment state="initial">
          <source>For individual rows, this column is always 1.</source>
          <target>For individual rows, this column is always 1.</target>
        </segment>
      </unit>
      <unit id="330">
        <segment state="initial">
          <source>Count</source>
          <target>Count</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source>The number of samples represented by a row, excluding samples that are taken when a processor is idle.</source>
          <target>The number of samples represented by a row, excluding samples that are taken when a processor is idle.</target>
        </segment>
      </unit>
      <unit id="332">
        <segment state="initial">
          <source>For individual rows, this column is always 1 (or 0, for cases when the CPU was in a low power state).</source>
          <target>For individual rows, this column is always 1 (or 0, for cases when the CPU was in a low power state).</target>
        </segment>
      </unit>
      <unit id="333">
        <segment state="initial">
          <source>CPU</source>
          <target>CPU</target>
        </segment>
      </unit>
      <unit id="334">
        <segment state="initial">
          <source>The 0-based index of the CPU on which this sample was taken.</source>
          <target>The 0-based index of the CPU on which this sample was taken.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source>Display Name</source>
          <target>Display Name</target>
        </segment>
      </unit>
      <unit id="336">
        <segment state="initial">
          <source>The display name of the active process.</source>
          <target>The display name of the active process.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source>DPC/ISR</source>
          <target>DPC/ISR</target>
        </segment>
      </unit>
      <unit id="338">
        <segment state="initial">
          <source>Whether the sample measured regular CPU usage, a DPC/ISR, or a low power state.</source>
          <target>Whether the sample measured regular CPU usage, a DPC/ISR, or a low power state.</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source>Function</source>
          <target>Function</target>
        </segment>
      </unit>
      <unit id="340">
        <segment state="initial">
          <source>The function at the bottom of the stack.</source>
          <target>The function at the bottom of the stack.</target>
        </segment>
      </unit>
      <unit id="341">
        <segment state="initial">
          <source>Module</source>
          <target>Module</target>
        </segment>
      </unit>
      <unit id="342">
        <segment state="initial">
          <source>The module that contains the function at the bottom of the stack.</source>
          <target>The module that contains the function at the bottom of the stack.</target>
        </segment>
      </unit>
      <unit id="343">
        <segment state="initial">
          <source>Priority</source>
          <target>Priority</target>
        </segment>
      </unit>
      <unit id="344">
        <segment state="initial">
          <source>The priority of the running thread.</source>
          <target>The priority of the running thread.</target>
        </segment>
      </unit>
      <unit id="345">
        <segment state="initial">
          <source>Process</source>
          <target>Process</target>
        </segment>
      </unit>
      <unit id="346">
        <segment state="initial">
          <source>The image name of the process that owns the running code.</source>
          <target>The image name of the process that owns the running code.</target>
        </segment>
      </unit>
      <unit id="347">
        <segment state="initial">
          <source>Process Name</source>
          <target>Process Name</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source>The full name (including Process ID) of the process that owns the running code.</source>
          <target>The full name (including Process ID) of the process that owns the running code.</target>
        </segment>
      </unit>
      <unit id="349">
        <segment state="initial">
          <source>Stack</source>
          <target>Stack</target>
        </segment>
      </unit>
      <unit id="350">
        <segment state="initial">
          <source>The stack of the running thread.</source>
          <target>The stack of the running thread.</target>
        </segment>
      </unit>
      <unit id="351">
        <segment state="initial">
          <source>Thread ID</source>
          <target>Thread ID</target>
        </segment>
      </unit>
      <unit id="352">
        <segment state="initial">
          <source>The ID of the running thread.</source>
          <target>The ID of the running thread.</target>
        </segment>
      </unit>
      <unit id="353">
        <segment state="initial">
          <source>Thread Start Function</source>
          <target>Thread Start Function</target>
        </segment>
      </unit>
      <unit id="354">
        <segment state="initial">
          <source>The function with which the running thread started.</source>
          <target>The function with which the running thread started.</target>
        </segment>
      </unit>
      <unit id="355">
        <segment state="initial">
          <source>Thread Start Module</source>
          <target>Thread Start Module</target>
        </segment>
      </unit>
      <unit id="356">
        <segment state="initial">
          <source>The module that contains the Thread Start Function.</source>
          <target>The module that contains the Thread Start Function.</target>
        </segment>
      </unit>
      <unit id="357">
        <segment state="initial">
          <source>TimeStamp</source>
          <target>TimeStamp</target>
        </segment>
      </unit>
      <unit id="358">
        <segment state="initial">
          <source>The time that the sample was taken.</source>
          <target>The time that the sample was taken.</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source>Weight</source>
          <target>Weight</target>
        </segment>
      </unit>
      <unit id="360">
        <segment state="initial">
          <source>The time (in milliseconds) that is represented by the sample (that is, the time since the last sample).</source>
          <target>The time (in milliseconds) that is represented by the sample (that is, the time since the last sample).</target>
        </segment>
      </unit>
      <unit id="361">
        <segment state="initial">
          <source>The default profile provides the following presets for this graph:</source>
          <target>The default profile provides the following presets for this graph:</target>
        </segment>
      </unit>
      <unit id="362">
        <segment state="initial">
          <source>Utilization by CPU</source>
          <target>Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="363">
        <segment state="initial">
          <source>Utilization by Priority</source>
          <target>Utilization by Priority</target>
        </segment>
      </unit>
      <unit id="364">
        <segment state="initial">
          <source>Utilization by Process</source>
          <target>Utilization by Process</target>
        </segment>
      </unit>
      <unit id="365">
        <segment state="initial">
          <source>Utilization by Process and Thread</source>
          <target>Utilization by Process and Thread</target>
        </segment>
      </unit>
      <unit id="366">
        <segment state="initial">
          <source>Utilization by CPU</source>
          <target>Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="367">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage Utilization by CPU</pc> graph shows how work is distributed between processors.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage Utilization by CPU</pc> graph shows how work is distributed between processors.</target>
        </segment>
      </unit>
      <unit id="368">
        <segment state="initial">
          <source>Figure 6 CPU Usage Utilization by CPU shows this distribution for two CPUs:</source>
          <target>Figure 6 CPU Usage Utilization by CPU shows this distribution for two CPUs:</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source>figure 6 cpu usage utilization by cpu</source>
          <target>figure 6 cpu usage utilization by cpu</target>
        </segment>
      </unit>
      <unit id="370">
        <segment state="initial">
          <source>Figure 6 CPU Usage Utilization by CPU</source>
          <target>Figure 6 CPU Usage Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="371">
        <segment state="initial">
          <source>Utilization by Priority</source>
          <target>Utilization by Priority</target>
        </segment>
      </unit>
      <unit id="372">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> grouped by thread priority shows how high-priority threads impact lower-priority threads.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> grouped by thread priority shows how high-priority threads impact lower-priority threads.</target>
        </segment>
      </unit>
      <unit id="373">
        <segment state="initial">
          <source>Figure 7 CPU Usage (Sampled) Utilization by Priority displays this graph:</source>
          <target>Figure 7 CPU Usage (Sampled) Utilization by Priority displays this graph:</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source>figure 7 cpu usage sampled utilization by priority</source>
          <target>figure 7 cpu usage sampled utilization by priority</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source>Figure 7 CPU Usage (Sampled) Utilization by Priority</source>
          <target>Figure 7 CPU Usage (Sampled) Utilization by Priority</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source>Utilization by Process</source>
          <target>Utilization by Process</target>
        </segment>
      </unit>
      <unit id="377">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> that is grouped by process shows the relative usage of processes.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> that is grouped by process shows the relative usage of processes.</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source>Figure 8 CPU Usage (Sampled) Utilization by Process shows this preset.</source>
          <target>Figure 8 CPU Usage (Sampled) Utilization by Process shows this preset.</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source>In this sample graph, one process is shown to be consuming more CPU time than the other processes.</source>
          <target>In this sample graph, one process is shown to be consuming more CPU time than the other processes.</target>
        </segment>
      </unit>
      <unit id="380">
        <segment state="initial">
          <source>figure 8 cpu usage sampled utilization by process</source>
          <target>figure 8 cpu usage sampled utilization by process</target>
        </segment>
      </unit>
      <unit id="381">
        <segment state="initial">
          <source>Figure 8 CPU Usage (Sampled) Utilization by Process</source>
          <target>Figure 8 CPU Usage (Sampled) Utilization by Process</target>
        </segment>
      </unit>
      <unit id="382">
        <segment state="initial">
          <source>Utilization by Process and Thread</source>
          <target>Utilization by Process and Thread</target>
        </segment>
      </unit>
      <unit id="383">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> that is grouped by process and then grouped by thread shows the relative usage of processes and the threads in each process.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> that is grouped by process and then grouped by thread shows the relative usage of processes and the threads in each process.</target>
        </segment>
      </unit>
      <unit id="384">
        <segment state="initial">
          <source>Figure 9 CPU Usage (Sampled) Utilization by Process and Thread shows this preset.</source>
          <target>Figure 9 CPU Usage (Sampled) Utilization by Process and Thread shows this preset.</target>
        </segment>
      </unit>
      <unit id="385">
        <segment state="initial">
          <source>The threads of a single process are selected in this graph.</source>
          <target>The threads of a single process are selected in this graph.</target>
        </segment>
      </unit>
      <unit id="386">
        <segment state="initial">
          <source>figure 9 cpu usage sampled utilization by process</source>
          <target>figure 9 cpu usage sampled utilization by process</target>
        </segment>
      </unit>
      <unit id="387">
        <segment state="initial">
          <source>Figure 9 CPU Usage (Sampled) Utilization by Process and Thread</source>
          <target>Figure 9 CPU Usage (Sampled) Utilization by Process and Thread</target>
        </segment>
      </unit>
      <unit id="388">
        <segment state="initial">
          <source>CPU Usage (Precise) Graph</source>
          <target>CPU Usage (Precise) Graph</target>
        </segment>
      </unit>
      <unit id="389">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph records information that is associated with context switching events.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph records information that is associated with context switching events.</target>
        </segment>
      </unit>
      <unit id="390">
        <segment state="initial">
          <source>Each row represents a set of data that is associated with a single context switch; that is, when a thread started running.</source>
          <target>Each row represents a set of data that is associated with a single context switch; that is, when a thread started running.</target>
        </segment>
      </unit>
      <unit id="391">
        <segment state="initial">
          <source>Data is collected for the following event sequence:</source>
          <target>Data is collected for the following event sequence:</target>
        </segment>
      </unit>
      <unit id="392">
        <segment state="initial">
          <source>The new thread is switched out.</source>
          <target>The new thread is switched out.</target>
        </segment>
      </unit>
      <unit id="393">
        <segment state="initial">
          <source>The new thread is made ready to run by the readying thread.</source>
          <target>The new thread is made ready to run by the readying thread.</target>
        </segment>
      </unit>
      <unit id="394">
        <segment state="initial">
          <source>The new thread is switched in, thereby switching out an old thread.</source>
          <target>The new thread is switched in, thereby switching out an old thread.</target>
        </segment>
      </unit>
      <unit id="395">
        <segment state="initial">
          <source>The new thread is switched out again.</source>
          <target>The new thread is switched out again.</target>
        </segment>
      </unit>
      <unit id="396">
        <segment state="initial">
          <source>In Figure 10 CPU Usage Precise Diagram, time flows from left to right.</source>
          <target>In Figure 10 CPU Usage Precise Diagram, time flows from left to right.</target>
        </segment>
      </unit>
      <unit id="397">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The diagram labels correspond to column names in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph.</source>
          <target>The diagram labels correspond to column names in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph.</target>
        </segment>
      </unit>
      <unit id="398">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Labels for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Timestamp</pc> columns display at the top of the diagram, and labels for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Interval Duration</pc> columns display at the bottom of the diagram.</source>
          <target>Labels for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Timestamp</pc> columns display at the top of the diagram, and labels for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Interval Duration</pc> columns display at the bottom of the diagram.</target>
        </segment>
      </unit>
      <unit id="399">
        <segment state="initial">
          <source>figure 10 cpu usage precise diagram</source>
          <target>figure 10 cpu usage precise diagram</target>
        </segment>
      </unit>
      <unit id="400">
        <segment state="initial">
          <source>Figure 10 CPU Usage Precise Diagram</source>
          <target>Figure 10 CPU Usage Precise Diagram</target>
        </segment>
      </unit>
      <unit id="401">
        <segment state="initial">
          <source>Breaks in the timeline in Figure 10 CPU Usage Precise Diagram divide the timeline into regions that can occur simultaneously on different CPUs.</source>
          <target>Breaks in the timeline in Figure 10 CPU Usage Precise Diagram divide the timeline into regions that can occur simultaneously on different CPUs.</target>
        </segment>
      </unit>
      <unit id="402">
        <segment state="initial">
          <source>These timelines can overlap as long as the order of the numbered events is not modified.</source>
          <target>These timelines can overlap as long as the order of the numbered events is not modified.</target>
        </segment>
      </unit>
      <unit id="403">
        <segment state="initial">
          <source>For example, the Readying Thread can run on Processor-2 at the same time that a new thread is switched out and then back in on Processor-1).</source>
          <target>For example, the Readying Thread can run on Processor-2 at the same time that a new thread is switched out and then back in on Processor-1).</target>
        </segment>
      </unit>
      <unit id="404">
        <segment state="initial">
          <source>Information is recorded for the following four targets on the timeline:</source>
          <target>Information is recorded for the following four targets on the timeline:</target>
        </segment>
      </unit>
      <unit id="405">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">New thread</pc>, which is the thread that was switched in.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">New thread</pc>, which is the thread that was switched in.</target>
        </segment>
      </unit>
      <unit id="406">
        <segment state="initial">
          <source>It is the primary focus of this row in the graph.</source>
          <target>It is the primary focus of this row in the graph.</target>
        </segment>
      </unit>
      <unit id="407">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewPrev thread</pc>, which refers to the previous time that the new thread was switched in.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewPrev thread</pc>, which refers to the previous time that the new thread was switched in.</target>
        </segment>
      </unit>
      <unit id="408">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Readying thread</pc>, which is the thread that prepared the new thread to be processed.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Readying thread</pc>, which is the thread that prepared the new thread to be processed.</target>
        </segment>
      </unit>
      <unit id="409">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Old thread</pc>, which is the thread that was switched out when the new thread was switched in.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Old thread</pc>, which is the thread that was switched out when the new thread was switched in.</target>
        </segment>
      </unit>
      <unit id="410">
        <segment state="initial">
          <source>The data in the following table relates to each target thread:</source>
          <target>The data in the following table relates to each target thread:</target>
        </segment>
      </unit>
      <unit id="411">
        <segment state="initial">
          <source>Column</source>
          <target>Column</target>
        </segment>
      </unit>
      <unit id="412">
        <segment state="initial">
          <source>Details</source>
          <target>Details</target>
        </segment>
      </unit>
      <unit id="413">
        <segment state="initial">
          <source>% CPU Usage</source>
          <target>% CPU Usage</target>
        </segment>
      </unit>
      <unit id="414">
        <segment state="initial">
          <source>The CPU usage of the new thread after it is switched.</source>
          <target>The CPU usage of the new thread after it is switched.</target>
        </segment>
      </unit>
      <unit id="415">
        <segment state="initial">
          <source>This value is expressed as a percentage of total CPU time over the currently visible time period.</source>
          <target>This value is expressed as a percentage of total CPU time over the currently visible time period.</target>
        </segment>
      </unit>
      <unit id="416">
        <segment state="initial">
          <source>Count</source>
          <target>Count</target>
        </segment>
      </unit>
      <unit id="417">
        <segment state="initial">
          <source>The number of context switches that are represented by the row.</source>
          <target>The number of context switches that are represented by the row.</target>
        </segment>
      </unit>
      <unit id="418">
        <segment state="initial">
          <source>This is always 1 for individual rows.</source>
          <target>This is always 1 for individual rows.</target>
        </segment>
      </unit>
      <unit id="419">
        <segment state="initial">
          <source>Count:Waits</source>
          <target>Count:Waits</target>
        </segment>
      </unit>
      <unit id="420">
        <segment state="initial">
          <source>The number of waits that are represented by the row.</source>
          <target>The number of waits that are represented by the row.</target>
        </segment>
      </unit>
      <unit id="421">
        <segment state="initial">
          <source>This is always 1 for individual rows except when a thread is switched to an idle state; in this case, it is set to 0.</source>
          <target>This is always 1 for individual rows except when a thread is switched to an idle state; in this case, it is set to 0.</target>
        </segment>
      </unit>
      <unit id="422">
        <segment state="initial">
          <source>CPU</source>
          <target>CPU</target>
        </segment>
      </unit>
      <unit id="423">
        <segment state="initial">
          <source>The CPU on which the context switch occurred.</source>
          <target>The CPU on which the context switch occurred.</target>
        </segment>
      </unit>
      <unit id="424">
        <segment state="initial">
          <source>CPU Usage (ms)</source>
          <target>CPU Usage (ms)</target>
        </segment>
      </unit>
      <unit id="425">
        <segment state="initial">
          <source>The CPU usage of the new thread after the context switch.</source>
          <target>The CPU usage of the new thread after the context switch.</target>
        </segment>
      </unit>
      <unit id="426">
        <segment state="initial">
          <source>This is equal to the NewInSwitchTime, but is displayed in milliseconds.</source>
          <target>This is equal to the NewInSwitchTime, but is displayed in milliseconds.</target>
        </segment>
      </unit>
      <unit id="427">
        <segment state="initial">
          <source>IdealCpu</source>
          <target>IdealCpu</target>
        </segment>
      </unit>
      <unit id="428">
        <segment state="initial">
          <source>The ideal CPU selected by the scheduler for the new thread.</source>
          <target>The ideal CPU selected by the scheduler for the new thread.</target>
        </segment>
      </unit>
      <unit id="429">
        <segment state="initial">
          <source>LastSwitchOutTime (s)</source>
          <target>LastSwitchOutTime (s)</target>
        </segment>
      </unit>
      <unit id="430">
        <segment state="initial">
          <source>The previous time that the new thread was switched out.</source>
          <target>The previous time that the new thread was switched out.</target>
        </segment>
      </unit>
      <unit id="431">
        <segment state="initial">
          <source>NewInPri</source>
          <target>NewInPri</target>
        </segment>
      </unit>
      <unit id="432">
        <segment state="initial">
          <source>The priority of the new thread that is switched in.</source>
          <target>The priority of the new thread that is switched in.</target>
        </segment>
      </unit>
      <unit id="433">
        <segment state="initial">
          <source>NewInSwitchTime(s)</source>
          <target>NewInSwitchTime(s)</target>
        </segment>
      </unit>
      <unit id="434">
        <segment state="initial">
          <source>NextSwitchOutTime(s) minus SwitchInTime(s)</source>
          <target>NextSwitchOutTime(s) minus SwitchInTime(s)</target>
        </segment>
      </unit>
      <unit id="435">
        <segment state="initial">
          <source>NewOutPri</source>
          <target>NewOutPri</target>
        </segment>
      </unit>
      <unit id="436">
        <segment state="initial">
          <source>The priority of the new thread when it switches out.</source>
          <target>The priority of the new thread when it switches out.</target>
        </segment>
      </unit>
      <unit id="437">
        <segment state="initial">
          <source>NewPrevOutPri</source>
          <target>NewPrevOutPri</target>
        </segment>
      </unit>
      <unit id="438">
        <segment state="initial">
          <source>The priority of the new thread when it was previously switched out.</source>
          <target>The priority of the new thread when it was previously switched out.</target>
        </segment>
      </unit>
      <unit id="439">
        <segment state="initial">
          <source>NewPrevState</source>
          <target>NewPrevState</target>
        </segment>
      </unit>
      <unit id="440">
        <segment state="initial">
          <source>The state of the new thread after it was previously switched out.</source>
          <target>The state of the new thread after it was previously switched out.</target>
        </segment>
      </unit>
      <unit id="441">
        <segment state="initial">
          <source>NewPrevWaitMode</source>
          <target>NewPrevWaitMode</target>
        </segment>
      </unit>
      <unit id="442">
        <segment state="initial">
          <source>The Wait Mode of the new thread when it was previously switched out.</source>
          <target>The Wait Mode of the new thread when it was previously switched out.</target>
        </segment>
      </unit>
      <unit id="443">
        <segment state="initial">
          <source>NewPrevWaitReason</source>
          <target>NewPrevWaitReason</target>
        </segment>
      </unit>
      <unit id="444">
        <segment state="initial">
          <source>The reason that the new thread was switched out.</source>
          <target>The reason that the new thread was switched out.</target>
        </segment>
      </unit>
      <unit id="445">
        <segment state="initial">
          <source>NewPriDecr</source>
          <target>NewPriDecr</target>
        </segment>
      </unit>
      <unit id="446">
        <segment state="initial">
          <source>The priority boost that affects the thread.</source>
          <target>The priority boost that affects the thread.</target>
        </segment>
      </unit>
      <unit id="447">
        <segment state="initial">
          <source>NewProcess</source>
          <target>NewProcess</target>
        </segment>
      </unit>
      <unit id="448">
        <segment state="initial">
          <source>The process of the new thread.</source>
          <target>The process of the new thread.</target>
        </segment>
      </unit>
      <unit id="449">
        <segment state="initial">
          <source>NewProcess Name</source>
          <target>NewProcess Name</target>
        </segment>
      </unit>
      <unit id="450">
        <segment state="initial">
          <source>The name of the process of the new thread, including PID.</source>
          <target>The name of the process of the new thread, including PID.</target>
        </segment>
      </unit>
      <unit id="451">
        <segment state="initial">
          <source>NewQnt</source>
          <target>NewQnt</target>
        </segment>
      </unit>
      <unit id="452">
        <segment state="initial">
          <source>Unused.</source>
          <target>Unused.</target>
        </segment>
      </unit>
      <unit id="453">
        <segment state="initial">
          <source>NewState</source>
          <target>NewState</target>
        </segment>
      </unit>
      <unit id="454">
        <segment state="initial">
          <source>The state of the new thread after it is switched in.</source>
          <target>The state of the new thread after it is switched in.</target>
        </segment>
      </unit>
      <unit id="455">
        <segment state="initial">
          <source>NewThreadId</source>
          <target>NewThreadId</target>
        </segment>
      </unit>
      <unit id="456">
        <segment state="initial">
          <source>The thread ID of the new thread.</source>
          <target>The thread ID of the new thread.</target>
        </segment>
      </unit>
      <unit id="457">
        <segment state="initial">
          <source>NewThreadStack</source>
          <target>NewThreadStack</target>
        </segment>
      </unit>
      <unit id="458">
        <segment state="initial">
          <source>The stack of the new thread when it is switched in.</source>
          <target>The stack of the new thread when it is switched in.</target>
        </segment>
      </unit>
      <unit id="459">
        <segment state="initial">
          <source>NewThreadStartFunction</source>
          <target>NewThreadStartFunction</target>
        </segment>
      </unit>
      <unit id="460">
        <segment state="initial">
          <source>The start function of the new thread.</source>
          <target>The start function of the new thread.</target>
        </segment>
      </unit>
      <unit id="461">
        <segment state="initial">
          <source>NewThreadStartModule</source>
          <target>NewThreadStartModule</target>
        </segment>
      </unit>
      <unit id="462">
        <segment state="initial">
          <source>The start module of the new thread.</source>
          <target>The start module of the new thread.</target>
        </segment>
      </unit>
      <unit id="463">
        <segment state="initial">
          <source>NewWaitMode</source>
          <target>NewWaitMode</target>
        </segment>
      </unit>
      <unit id="464">
        <segment state="initial">
          <source>The wait mode of the new thread.</source>
          <target>The wait mode of the new thread.</target>
        </segment>
      </unit>
      <unit id="465">
        <segment state="initial">
          <source>NewWaitReason</source>
          <target>NewWaitReason</target>
        </segment>
      </unit>
      <unit id="466">
        <segment state="initial">
          <source>The reason that the new thread was switched out.</source>
          <target>The reason that the new thread was switched out.</target>
        </segment>
      </unit>
      <unit id="467">
        <segment state="initial">
          <source>NextSwitchOutTime(s)</source>
          <target>NextSwitchOutTime(s)</target>
        </segment>
      </unit>
      <unit id="468">
        <segment state="initial">
          <source>The time when the new thread was next switched out.</source>
          <target>The time when the new thread was next switched out.</target>
        </segment>
      </unit>
      <unit id="469">
        <segment state="initial">
          <source>OldInSwitchTime(s)</source>
          <target>OldInSwitchTime(s)</target>
        </segment>
      </unit>
      <unit id="470">
        <segment state="initial">
          <source>The time that the old thread was switched in before it was switched out.</source>
          <target>The time that the old thread was switched in before it was switched out.</target>
        </segment>
      </unit>
      <unit id="471">
        <segment state="initial">
          <source>OldOutPri</source>
          <target>OldOutPri</target>
        </segment>
      </unit>
      <unit id="472">
        <segment state="initial">
          <source>The priority of the old thread when it was switched out.</source>
          <target>The priority of the old thread when it was switched out.</target>
        </segment>
      </unit>
      <unit id="473">
        <segment state="initial">
          <source>OldProcess</source>
          <target>OldProcess</target>
        </segment>
      </unit>
      <unit id="474">
        <segment state="initial">
          <source>The process that owns the old thread.</source>
          <target>The process that owns the old thread.</target>
        </segment>
      </unit>
      <unit id="475">
        <segment state="initial">
          <source>OldProcess Name</source>
          <target>OldProcess Name</target>
        </segment>
      </unit>
      <unit id="476">
        <segment state="initial">
          <source>The name of the process that owns the old thread, including PID.</source>
          <target>The name of the process that owns the old thread, including PID.</target>
        </segment>
      </unit>
      <unit id="477">
        <segment state="initial">
          <source>OldQnt</source>
          <target>OldQnt</target>
        </segment>
      </unit>
      <unit id="478">
        <segment state="initial">
          <source>Unused.</source>
          <target>Unused.</target>
        </segment>
      </unit>
      <unit id="479">
        <segment state="initial">
          <source>OldState</source>
          <target>OldState</target>
        </segment>
      </unit>
      <unit id="480">
        <segment state="initial">
          <source>The state of the old thread after it is switched out.</source>
          <target>The state of the old thread after it is switched out.</target>
        </segment>
      </unit>
      <unit id="481">
        <segment state="initial">
          <source>OldThreadId</source>
          <target>OldThreadId</target>
        </segment>
      </unit>
      <unit id="482">
        <segment state="initial">
          <source>The thread ID of the old thread.</source>
          <target>The thread ID of the old thread.</target>
        </segment>
      </unit>
      <unit id="483">
        <segment state="initial">
          <source>OldThreadStartFunction</source>
          <target>OldThreadStartFunction</target>
        </segment>
      </unit>
      <unit id="484">
        <segment state="initial">
          <source>The start function of the old thread.</source>
          <target>The start function of the old thread.</target>
        </segment>
      </unit>
      <unit id="485">
        <segment state="initial">
          <source>OldThreadStartModule</source>
          <target>OldThreadStartModule</target>
        </segment>
      </unit>
      <unit id="486">
        <segment state="initial">
          <source>The start module of the old thread.</source>
          <target>The start module of the old thread.</target>
        </segment>
      </unit>
      <unit id="487">
        <segment state="initial">
          <source>OldWaitMode</source>
          <target>OldWaitMode</target>
        </segment>
      </unit>
      <unit id="488">
        <segment state="initial">
          <source>The wait mode of the old thread.</source>
          <target>The wait mode of the old thread.</target>
        </segment>
      </unit>
      <unit id="489">
        <segment state="initial">
          <source>OldWaitReason</source>
          <target>OldWaitReason</target>
        </segment>
      </unit>
      <unit id="490">
        <segment state="initial">
          <source>The reason that the old thread was switched out.</source>
          <target>The reason that the old thread was switched out.</target>
        </segment>
      </unit>
      <unit id="491">
        <segment state="initial">
          <source>PrevCState</source>
          <target>PrevCState</target>
        </segment>
      </unit>
      <unit id="492">
        <segment state="initial">
          <source>The previous CState of the processor.</source>
          <target>The previous CState of the processor.</target>
        </segment>
      </unit>
      <unit id="493">
        <segment state="initial">
          <source>If this is not 0 (Active), the processor was in an idle state before the new thread was context-switched in.</source>
          <target>If this is not 0 (Active), the processor was in an idle state before the new thread was context-switched in.</target>
        </segment>
      </unit>
      <unit id="494">
        <segment state="initial">
          <source>Ready(s)</source>
          <target>Ready(s)</target>
        </segment>
      </unit>
      <unit id="495">
        <segment state="initial">
          <source>SwitchInTime(s) minusReadyTime (s)</source>
          <target>SwitchInTime(s) minusReadyTime (s)</target>
        </segment>
      </unit>
      <unit id="496">
        <segment state="initial">
          <source>Readying ThreadId</source>
          <target>Readying ThreadId</target>
        </segment>
      </unit>
      <unit id="497">
        <segment state="initial">
          <source>The thread ID of the readying thread.</source>
          <target>The thread ID of the readying thread.</target>
        </segment>
      </unit>
      <unit id="498">
        <segment state="initial">
          <source>Readying ThreadStartFunction</source>
          <target>Readying ThreadStartFunction</target>
        </segment>
      </unit>
      <unit id="499">
        <segment state="initial">
          <source>The start function of the readying thread.</source>
          <target>The start function of the readying thread.</target>
        </segment>
      </unit>
      <unit id="500">
        <segment state="initial">
          <source>Readying ThreadStartModule</source>
          <target>Readying ThreadStartModule</target>
        </segment>
      </unit>
      <unit id="501">
        <segment state="initial">
          <source>The start module of the readying thread.</source>
          <target>The start module of the readying thread.</target>
        </segment>
      </unit>
      <unit id="502">
        <segment state="initial">
          <source>ReadyingProcess</source>
          <target>ReadyingProcess</target>
        </segment>
      </unit>
      <unit id="503">
        <segment state="initial">
          <source>The process that owns the readying thread.</source>
          <target>The process that owns the readying thread.</target>
        </segment>
      </unit>
      <unit id="504">
        <segment state="initial">
          <source>ReadyingProcess Name</source>
          <target>ReadyingProcess Name</target>
        </segment>
      </unit>
      <unit id="505">
        <segment state="initial">
          <source>The name of the process that owns the readying thread, including PID.</source>
          <target>The name of the process that owns the readying thread, including PID.</target>
        </segment>
      </unit>
      <unit id="506">
        <segment state="initial">
          <source>ReadyThreadStack</source>
          <target>ReadyThreadStack</target>
        </segment>
      </unit>
      <unit id="507">
        <segment state="initial">
          <source>The stack of the readying thread.</source>
          <target>The stack of the readying thread.</target>
        </segment>
      </unit>
      <unit id="508">
        <segment state="initial">
          <source>ReadyTime (s)</source>
          <target>ReadyTime (s)</target>
        </segment>
      </unit>
      <unit id="509">
        <segment state="initial">
          <source>The time when the new thread was readied.</source>
          <target>The time when the new thread was readied.</target>
        </segment>
      </unit>
      <unit id="510">
        <segment state="initial">
          <source>SwitchInTime(s)</source>
          <target>SwitchInTime(s)</target>
        </segment>
      </unit>
      <unit id="511">
        <segment state="initial">
          <source>The time when the new thread was switched in.</source>
          <target>The time when the new thread was switched in.</target>
        </segment>
      </unit>
      <unit id="512">
        <segment state="initial">
          <source>TimeSinceLast (s)</source>
          <target>TimeSinceLast (s)</target>
        </segment>
      </unit>
      <unit id="513">
        <segment state="initial">
          <source>SwitchInTime(s) minus LastSwitchOutTime (s)</source>
          <target>SwitchInTime(s) minus LastSwitchOutTime (s)</target>
        </segment>
      </unit>
      <unit id="514">
        <segment state="initial">
          <source>Waits (s)</source>
          <target>Waits (s)</target>
        </segment>
      </unit>
      <unit id="515">
        <segment state="initial">
          <source>ReadyTime (s) minus LastSwitchOutTime (s)</source>
          <target>ReadyTime (s) minus LastSwitchOutTime (s)</target>
        </segment>
      </unit>
      <unit id="516">
        <segment state="initial">
          <source>The default profile uses the following presets for this graph:</source>
          <target>The default profile uses the following presets for this graph:</target>
        </segment>
      </unit>
      <unit id="517">
        <segment state="initial">
          <source>Timeline by CPU</source>
          <target>Timeline by CPU</target>
        </segment>
      </unit>
      <unit id="518">
        <segment state="initial">
          <source>Timeline by Process, Thread</source>
          <target>Timeline by Process, Thread</target>
        </segment>
      </unit>
      <unit id="519">
        <segment state="initial">
          <source>Usage by Priority at Context Switch Begin</source>
          <target>Usage by Priority at Context Switch Begin</target>
        </segment>
      </unit>
      <unit id="520">
        <segment state="initial">
          <source>Utilization by CPU</source>
          <target>Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="521">
        <segment state="initial">
          <source>Utilization by Process, Thread</source>
          <target>Utilization by Process, Thread</target>
        </segment>
      </unit>
      <unit id="522">
        <segment state="initial">
          <source>Timeline by CPU</source>
          <target>Timeline by CPU</target>
        </segment>
      </unit>
      <unit id="523">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> on a per-CPU timeline shows how work is distributed among processors.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> on a per-CPU timeline shows how work is distributed among processors.</target>
        </segment>
      </unit>
      <unit id="524">
        <segment state="initial">
          <source>Figure 11 CPU Usage (Precise) Timeline by CPU displays the timeline on an eight-processor system:</source>
          <target>Figure 11 CPU Usage (Precise) Timeline by CPU displays the timeline on an eight-processor system:</target>
        </segment>
      </unit>
      <unit id="525">
        <segment state="initial">
          <source>figure 11 cpu usage precise timeline by cpu</source>
          <target>figure 11 cpu usage precise timeline by cpu</target>
        </segment>
      </unit>
      <unit id="526">
        <segment state="initial">
          <source>Figure 11 CPU Usage (Precise) Timeline by CPU</source>
          <target>Figure 11 CPU Usage (Precise) Timeline by CPU</target>
        </segment>
      </unit>
      <unit id="527">
        <segment state="initial">
          <source>Timeline by Process, Thread</source>
          <target>Timeline by Process, Thread</target>
        </segment>
      </unit>
      <unit id="528">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> on a per-process, per-thread timeline, shows which processes had threads running at certain times.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> on a per-process, per-thread timeline, shows which processes had threads running at certain times.</target>
        </segment>
      </unit>
      <unit id="529">
        <segment state="initial">
          <source>Figure 12 Usage (Precise) Timeline by Process, Thread shows this timeline across several processes:</source>
          <target>Figure 12 Usage (Precise) Timeline by Process, Thread shows this timeline across several processes:</target>
        </segment>
      </unit>
      <unit id="530">
        <segment state="initial">
          <source>figure 12 usage precise timeline by process thread</source>
          <target>figure 12 usage precise timeline by process thread</target>
        </segment>
      </unit>
      <unit id="531">
        <segment state="initial">
          <source>Figure 12 Usage (Precise) Timeline by Process, Thread</source>
          <target>Figure 12 Usage (Precise) Timeline by Process, Thread</target>
        </segment>
      </unit>
      <unit id="532">
        <segment state="initial">
          <source>Usage by Priority at Context Switch Begin</source>
          <target>Usage by Priority at Context Switch Begin</target>
        </segment>
      </unit>
      <unit id="533">
        <segment state="initial">
          <source>This graph identifies bursts of high-priority thread activity at each priority level.</source>
          <target>This graph identifies bursts of high-priority thread activity at each priority level.</target>
        </segment>
      </unit>
      <unit id="534">
        <segment state="initial">
          <source>Figure 13 CPU Usage (Precise) Usage by Priority at Context Switch Begin shows the distribution of priorities:</source>
          <target>Figure 13 CPU Usage (Precise) Usage by Priority at Context Switch Begin shows the distribution of priorities:</target>
        </segment>
      </unit>
      <unit id="535">
        <segment state="initial">
          <source>figure 13 cpu usage precise usage by priority at c</source>
          <target>figure 13 cpu usage precise usage by priority at c</target>
        </segment>
      </unit>
      <unit id="536">
        <segment state="initial">
          <source>Figure 13 CPU Usage (Precise) Usage by Priority at Context Switch Begin</source>
          <target>Figure 13 CPU Usage (Precise) Usage by Priority at Context Switch Begin</target>
        </segment>
      </unit>
      <unit id="537">
        <segment state="initial">
          <source>Utilization by CPU</source>
          <target>Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="538">
        <segment state="initial">
          <source>In this graph, CPU usage is grouped and graphed by CPU to show how work is distributed among processors.</source>
          <target>In this graph, CPU usage is grouped and graphed by CPU to show how work is distributed among processors.</target>
        </segment>
      </unit>
      <unit id="539">
        <segment state="initial">
          <source>Figure 14 CPU Usage (Precise) Utilization by CPU shows this graph for a system that has eight processors.</source>
          <target>Figure 14 CPU Usage (Precise) Utilization by CPU shows this graph for a system that has eight processors.</target>
        </segment>
      </unit>
      <unit id="540">
        <segment state="initial">
          <source>figure 14 cpu usage precise utilization by cpu</source>
          <target>figure 14 cpu usage precise utilization by cpu</target>
        </segment>
      </unit>
      <unit id="541">
        <segment state="initial">
          <source>Figure 14 CPU Usage (Precise) Utilization by CPU</source>
          <target>Figure 14 CPU Usage (Precise) Utilization by CPU</target>
        </segment>
      </unit>
      <unit id="542">
        <segment state="initial">
          <source>Utilization by Process, Thread</source>
          <target>Utilization by Process, Thread</target>
        </segment>
      </unit>
      <unit id="543">
        <segment state="initial">
          <source>In this graph, CPU usage is grouped first by process and then by thread.</source>
          <target>In this graph, CPU usage is grouped first by process and then by thread.</target>
        </segment>
      </unit>
      <unit id="544">
        <segment state="initial">
          <source>It shows the relative usage of processes and the threads in each process Figure 15 CPU Usage (Precise) Utilization by Process, Thread shows this distribution across multiple processes:</source>
          <target>It shows the relative usage of processes and the threads in each process Figure 15 CPU Usage (Precise) Utilization by Process, Thread shows this distribution across multiple processes:</target>
        </segment>
      </unit>
      <unit id="545">
        <segment state="initial">
          <source>figure 15 cpu usage precise utilization by process</source>
          <target>figure 15 cpu usage precise utilization by process</target>
        </segment>
      </unit>
      <unit id="546">
        <segment state="initial">
          <source>Figure 15 CPU Usage (Precise) Utilization by Process, Thread</source>
          <target>Figure 15 CPU Usage (Precise) Utilization by Process, Thread</target>
        </segment>
      </unit>
      <unit id="547">
        <segment state="initial">
          <source>DPC/ISR Graph</source>
          <target>DPC/ISR Graph</target>
        </segment>
      </unit>
      <unit id="548">
        <segment state="initial">
          <source>The DPC/ISR graph is the primary source for DPC/ISR information in WPA.</source>
          <target>The DPC/ISR graph is the primary source for DPC/ISR information in WPA.</target>
        </segment>
      </unit>
      <unit id="549">
        <segment state="initial">
          <source>Each row in the graph represents a fragment, which is a period of time during which a DPC or ISR ran uninterrupted.</source>
          <target>Each row in the graph represents a fragment, which is a period of time during which a DPC or ISR ran uninterrupted.</target>
        </segment>
      </unit>
      <unit id="550">
        <segment state="initial">
          <source>Data is collected at the start and end of fragments.</source>
          <target>Data is collected at the start and end of fragments.</target>
        </segment>
      </unit>
      <unit id="551">
        <segment state="initial">
          <source>Additional data is collected when a DPC/ISR is complete.</source>
          <target>Additional data is collected when a DPC/ISR is complete.</target>
        </segment>
      </unit>
      <unit id="552">
        <segment state="initial">
          <source>Figure 16 DPC/ISR Diagram shows how this works:</source>
          <target>Figure 16 DPC/ISR Diagram shows how this works:</target>
        </segment>
      </unit>
      <unit id="553">
        <segment state="initial">
          <source>figure 16 dpc isr diagram</source>
          <target>figure 16 dpc isr diagram</target>
        </segment>
      </unit>
      <unit id="554">
        <segment state="initial">
          <source>Figure 16 DPC/ISR Diagram</source>
          <target>Figure 16 DPC/ISR Diagram</target>
        </segment>
      </unit>
      <unit id="555">
        <segment state="initial">
          <source>Figure 16 DPC/ISR Diagram describes data that was collected during the following activities:</source>
          <target>Figure 16 DPC/ISR Diagram describes data that was collected during the following activities:</target>
        </segment>
      </unit>
      <unit id="556">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> starts to run.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> starts to run.</target>
        </segment>
      </unit>
      <unit id="557">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>A device interrupt that has a higher interrupt level than <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> causes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISR-B</pc> to interrupt <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DPC/ISR A</pc>, thereby ending the first fragment of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DPC/ISR-A</pc>.</source>
          <target>A device interrupt that has a higher interrupt level than <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> causes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISR-B</pc> to interrupt <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DPC/ISR A</pc>, thereby ending the first fragment of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DPC/ISR-A</pc>.</target>
        </segment>
      </unit>
      <unit id="558">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ISR-B</pc> completes and thereby ends the fragment of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISR-B</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ISR-B</pc> completes and thereby ends the fragment of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISR-B</pc>.</target>
        </segment>
      </unit>
      <unit id="559">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> resumes execution in a second fragment.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> resumes execution in a second fragment.</target>
        </segment>
      </unit>
      <unit id="560">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> completes, thereby ending the second fragment of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DPC/ISR-A</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> completes, thereby ending the second fragment of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DPC/ISR-A</pc>.</target>
        </segment>
      </unit>
      <unit id="561">
        <segment state="initial">
          <source>A row for each fragment is displayed in the data table.</source>
          <target>A row for each fragment is displayed in the data table.</target>
        </segment>
      </unit>
      <unit id="562">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The fragments for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> share identical information with non-fragment columns.</source>
          <target>The fragments for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR-A</pc> share identical information with non-fragment columns.</target>
        </segment>
      </unit>
      <unit id="563">
        <segment state="initial">
          <source>The columns for the DPC/ISR graph describe fragment-level information, or DPC/ISR level columns.</source>
          <target>The columns for the DPC/ISR graph describe fragment-level information, or DPC/ISR level columns.</target>
        </segment>
      </unit>
      <unit id="564">
        <segment state="initial">
          <source>Each fragment dissimilar data in fragment-level columns, and identical data in DPC/ISR columns.</source>
          <target>Each fragment dissimilar data in fragment-level columns, and identical data in DPC/ISR columns.</target>
        </segment>
      </unit>
      <unit id="565">
        <segment state="initial">
          <source>Column</source>
          <target>Column</target>
        </segment>
      </unit>
      <unit id="566">
        <segment state="initial">
          <source>Details</source>
          <target>Details</target>
        </segment>
      </unit>
      <unit id="567">
        <segment state="initial">
          <source>% Duration (Fragmented)</source>
          <target>% Duration (Fragmented)</target>
        </segment>
      </unit>
      <unit id="568">
        <segment state="initial">
          <source>Duration (fragmented) that is expressed as a percentage of total CPU time over the currently visible time period.</source>
          <target>Duration (fragmented) that is expressed as a percentage of total CPU time over the currently visible time period.</target>
        </segment>
      </unit>
      <unit id="569">
        <segment state="initial">
          <source>% Exclusive Duration</source>
          <target>% Exclusive Duration</target>
        </segment>
      </unit>
      <unit id="570">
        <segment state="initial">
          <source>Exclusive duration that is expressed as a percentage of total CPU time over the currently visible time period.</source>
          <target>Exclusive duration that is expressed as a percentage of total CPU time over the currently visible time period.</target>
        </segment>
      </unit>
      <unit id="571">
        <segment state="initial">
          <source>% Inclusive Duration</source>
          <target>% Inclusive Duration</target>
        </segment>
      </unit>
      <unit id="572">
        <segment state="initial">
          <source>Inclusive duration that is expressed as a percentage of total CPU time over the currently visible time period.</source>
          <target>Inclusive duration that is expressed as a percentage of total CPU time over the currently visible time period.</target>
        </segment>
      </unit>
      <unit id="573">
        <segment state="initial">
          <source>Address</source>
          <target>Address</target>
        </segment>
      </unit>
      <unit id="574">
        <segment state="initial">
          <source>The memory address of the DPC or ISR function.</source>
          <target>The memory address of the DPC or ISR function.</target>
        </segment>
      </unit>
      <unit id="575">
        <segment state="initial">
          <source>Count (DPCs/ISRs)</source>
          <target>Count (DPCs/ISRs)</target>
        </segment>
      </unit>
      <unit id="576">
        <segment state="initial">
          <source>The count of DPCs/ISRs that are represented by this row.</source>
          <target>The count of DPCs/ISRs that are represented by this row.</target>
        </segment>
      </unit>
      <unit id="577">
        <segment state="initial">
          <source>This is always 1 for rows that represent the final fragment of a DPC/ISR; otherwise, this count is 0.</source>
          <target>This is always 1 for rows that represent the final fragment of a DPC/ISR; otherwise, this count is 0.</target>
        </segment>
      </unit>
      <unit id="578">
        <segment state="initial">
          <source>Count (Fragments)</source>
          <target>Count (Fragments)</target>
        </segment>
      </unit>
      <unit id="579">
        <segment state="initial">
          <source>The number of fragments that are represented by the row.</source>
          <target>The number of fragments that are represented by the row.</target>
        </segment>
      </unit>
      <unit id="580">
        <segment state="initial">
          <source>This is always 1 for individual rows.</source>
          <target>This is always 1 for individual rows.</target>
        </segment>
      </unit>
      <unit id="581">
        <segment state="initial">
          <source>CPU</source>
          <target>CPU</target>
        </segment>
      </unit>
      <unit id="582">
        <segment state="initial">
          <source>The index of the logical processor on which the DPC or ISR ran.</source>
          <target>The index of the logical processor on which the DPC or ISR ran.</target>
        </segment>
      </unit>
      <unit id="583">
        <segment state="initial">
          <source>DPC Type</source>
          <target>DPC Type</target>
        </segment>
      </unit>
      <unit id="584">
        <segment state="initial">
          <source>For DPC, the type of DPC,- either Regular or Timer.</source>
          <target>For DPC, the type of DPC,- either Regular or Timer.</target>
        </segment>
      </unit>
      <unit id="585">
        <segment state="initial">
          <source>This value is blank for an ISR.</source>
          <target>This value is blank for an ISR.</target>
        </segment>
      </unit>
      <unit id="586">
        <segment state="initial">
          <source>DPC/ISR Enter Time (s)</source>
          <target>DPC/ISR Enter Time (s)</target>
        </segment>
      </unit>
      <unit id="587">
        <segment state="initial">
          <source>The time in the trace when the DPC/ISR started.</source>
          <target>The time in the trace when the DPC/ISR started.</target>
        </segment>
      </unit>
      <unit id="588">
        <segment state="initial">
          <source>DPC/ISR Exit Time (s)</source>
          <target>DPC/ISR Exit Time (s)</target>
        </segment>
      </unit>
      <unit id="589">
        <segment state="initial">
          <source>The time from the beginning of the trace to when the DPC/ISR completed.</source>
          <target>The time from the beginning of the trace to when the DPC/ISR completed.</target>
        </segment>
      </unit>
      <unit id="590">
        <segment state="initial">
          <source>Duration (Fragmented) (ms)</source>
          <target>Duration (Fragmented) (ms)</target>
        </segment>
      </unit>
      <unit id="591">
        <segment state="initial">
          <source>Fragment Exit Time (s) minus Fragment Enter Time (s) in milliseconds.</source>
          <target>Fragment Exit Time (s) minus Fragment Enter Time (s) in milliseconds.</target>
        </segment>
      </unit>
      <unit id="592">
        <segment state="initial">
          <source>Exclusive Duration (ms)</source>
          <target>Exclusive Duration (ms)</target>
        </segment>
      </unit>
      <unit id="593">
        <segment state="initial">
          <source>The sum of fragmented durations in ms.</source>
          <target>The sum of fragmented durations in ms.</target>
        </segment>
      </unit>
      <unit id="594">
        <segment state="initial">
          <source>for all fragments of this DPC/ISR.</source>
          <target>for all fragments of this DPC/ISR.</target>
        </segment>
      </unit>
      <unit id="595">
        <segment state="initial">
          <source>Fragment</source>
          <target>Fragment</target>
        </segment>
      </unit>
      <unit id="596">
        <originalData>
          <data id="id1">&lt;strong&gt;</data>
          <data id="id2">&lt;/strong&gt;</data>
          <data id="id3">&lt;strong&gt;</data>
          <data id="id4">&lt;/strong&gt;</data>
        </originalData>
        <segment state="initial">
          <source>If the DPC/ISR of this row had multiple fragments, this value is <ph dataRef="id1" id="ph1" />True<ph dataRef="id2" id="ph2" />; otherwise, it is <ph dataRef="id3" id="ph3" />False<ph dataRef="id4" id="ph4" />.</source>
          <target>If the DPC/ISR of this row had multiple fragments, this value is <ph dataRef="id1" id="ph1" />True<ph dataRef="id2" id="ph2" />; otherwise, it is <ph dataRef="id3" id="ph3" />False<ph dataRef="id4" id="ph4" />.</target>
        </segment>
      </unit>
      <unit id="597">
        <segment state="initial">
          <source>Fragment</source>
          <target>Fragment</target>
        </segment>
      </unit>
      <unit id="598">
        <originalData>
          <data id="id1">&lt;strong&gt;</data>
          <data id="id2">&lt;/strong&gt;</data>
          <data id="id3">&lt;strong&gt;</data>
          <data id="id4">&lt;/strong&gt;</data>
        </originalData>
        <segment state="initial">
          <source>If this was not the only fragment for this DPC/ISR, this value is <ph dataRef="id1" id="ph1" />True<ph dataRef="id2" id="ph2" />; otherwise, it is <ph dataRef="id3" id="ph3" />False<ph dataRef="id4" id="ph4" />.</source>
          <target>If this was not the only fragment for this DPC/ISR, this value is <ph dataRef="id1" id="ph1" />True<ph dataRef="id2" id="ph2" />; otherwise, it is <ph dataRef="id3" id="ph3" />False<ph dataRef="id4" id="ph4" />.</target>
        </segment>
      </unit>
      <unit id="599">
        <segment state="initial">
          <source>Fragment Enter Time (s)</source>
          <target>Fragment Enter Time (s)</target>
        </segment>
      </unit>
      <unit id="600">
        <segment state="initial">
          <source>The time that the fragment started to run.</source>
          <target>The time that the fragment started to run.</target>
        </segment>
      </unit>
      <unit id="601">
        <segment state="initial">
          <source>Fragment Exit Time (s)</source>
          <target>Fragment Exit Time (s)</target>
        </segment>
      </unit>
      <unit id="602">
        <segment state="initial">
          <source>The time that the fragment stopped running.</source>
          <target>The time that the fragment stopped running.</target>
        </segment>
      </unit>
      <unit id="603">
        <segment state="initial">
          <source>Function</source>
          <target>Function</target>
        </segment>
      </unit>
      <unit id="604">
        <segment state="initial">
          <source>The DPC or ISR function that ran.</source>
          <target>The DPC or ISR function that ran.</target>
        </segment>
      </unit>
      <unit id="605">
        <segment state="initial">
          <source>Inclusive Duration (ms)</source>
          <target>Inclusive Duration (ms)</target>
        </segment>
      </unit>
      <unit id="606">
        <segment state="initial">
          <source>DPC/ISR Exit Time (s) minus DPC/ISR Enter Time (s) in milliseconds.</source>
          <target>DPC/ISR Exit Time (s) minus DPC/ISR Enter Time (s) in milliseconds.</target>
        </segment>
      </unit>
      <unit id="607">
        <segment state="initial">
          <source>MessageIndex</source>
          <target>MessageIndex</target>
        </segment>
      </unit>
      <unit id="608">
        <segment state="initial">
          <source>The interrupt index for message-signaled interrupts.</source>
          <target>The interrupt index for message-signaled interrupts.</target>
        </segment>
      </unit>
      <unit id="609">
        <segment state="initial">
          <source>Module</source>
          <target>Module</target>
        </segment>
      </unit>
      <unit id="610">
        <segment state="initial">
          <source>The module that contains the DPC or ISR function.</source>
          <target>The module that contains the DPC or ISR function.</target>
        </segment>
      </unit>
      <unit id="611">
        <segment state="initial">
          <source>Return Value</source>
          <target>Return Value</target>
        </segment>
      </unit>
      <unit id="612">
        <segment state="initial">
          <source>The return value of the DPC/ISR</source>
          <target>The return value of the DPC/ISR</target>
        </segment>
      </unit>
      <unit id="613">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="614">
        <segment state="initial">
          <source>The type of event; this is- either DPC or Interrupt (ISR).</source>
          <target>The type of event; this is- either DPC or Interrupt (ISR).</target>
        </segment>
      </unit>
      <unit id="615">
        <segment state="initial">
          <source>Vector</source>
          <target>Vector</target>
        </segment>
      </unit>
      <unit id="616">
        <segment state="initial">
          <source>The value of the interrupt vector on the device.</source>
          <target>The value of the interrupt vector on the device.</target>
        </segment>
      </unit>
      <unit id="617">
        <segment state="initial">
          <source>The default profile uses the following presets for this graph:</source>
          <target>The default profile uses the following presets for this graph:</target>
        </segment>
      </unit>
      <unit id="618">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by CPU</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by CPU</target>
        </segment>
      </unit>
      <unit id="619">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by Module, Function</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by Module, Function</target>
        </segment>
      </unit>
      <unit id="620">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Timeline by Module, Function</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Timeline by Module, Function</target>
        </segment>
      </unit>
      <unit id="621">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by CPU</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by CPU</target>
        </segment>
      </unit>
      <unit id="622">
        <segment state="initial">
          <source>DPC/ISR events are aggregated by the CPU on which they ran and are sorted by duration.</source>
          <target>DPC/ISR events are aggregated by the CPU on which they ran and are sorted by duration.</target>
        </segment>
      </unit>
      <unit id="623">
        <segment state="initial">
          <source>This graph shows the allocation of DPC activity across CPUs.</source>
          <target>This graph shows the allocation of DPC activity across CPUs.</target>
        </segment>
      </unit>
      <unit id="624">
        <segment state="initial">
          <source>Figure 17 DPC/ISR Duration by CPU shows this graph for a system that has eight processors.</source>
          <target>Figure 17 DPC/ISR Duration by CPU shows this graph for a system that has eight processors.</target>
        </segment>
      </unit>
      <unit id="625">
        <segment state="initial">
          <source>figure 17 dpc isr duration by cpu</source>
          <target>figure 17 dpc isr duration by cpu</target>
        </segment>
      </unit>
      <unit id="626">
        <segment state="initial">
          <source>Figure 17 DPC/ISR Duration by CPU</source>
          <target>Figure 17 DPC/ISR Duration by CPU</target>
        </segment>
      </unit>
      <unit id="627">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by Module, Function</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Duration by Module, Function</target>
        </segment>
      </unit>
      <unit id="628">
        <segment state="initial">
          <source>DPC/ISR events are aggregated in this graph by the module and function of the DPC/ISR routines, and are sorted by duration.</source>
          <target>DPC/ISR events are aggregated in this graph by the module and function of the DPC/ISR routines, and are sorted by duration.</target>
        </segment>
      </unit>
      <unit id="629">
        <segment state="initial">
          <source>This shows which DPC/ISR routines consumed the most time Figure 18 DPC/ISR Duration by Module, Function shows a period of time that incurs DPC/ISR activity in two modules:</source>
          <target>This shows which DPC/ISR routines consumed the most time Figure 18 DPC/ISR Duration by Module, Function shows a period of time that incurs DPC/ISR activity in two modules:</target>
        </segment>
      </unit>
      <unit id="630">
        <segment state="initial">
          <source>figure 18 dpc isr duration by module function</source>
          <target>figure 18 dpc isr duration by module function</target>
        </segment>
      </unit>
      <unit id="631">
        <segment state="initial">
          <source>Figure 18 DPC/ISR Duration by Module, Function</source>
          <target>Figure 18 DPC/ISR Duration by Module, Function</target>
        </segment>
      </unit>
      <unit id="632">
        <originalData>
          <data id="id1">\]</data>
        </originalData>
        <segment state="initial">
          <source>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Timeline by Module, Function</source>
          <target>DPC,ISR,DPC/ISR<ph dataRef="id1" id="ph1" /> Timeline by Module, Function</target>
        </segment>
      </unit>
      <unit id="633">
        <segment state="initial">
          <source>DPC/ISR events are aggregated in this graph by the module and function of the DPC/ISR routines.</source>
          <target>DPC/ISR events are aggregated in this graph by the module and function of the DPC/ISR routines.</target>
        </segment>
      </unit>
      <unit id="634">
        <segment state="initial">
          <source>They are graphed as a timeline.</source>
          <target>They are graphed as a timeline.</target>
        </segment>
      </unit>
      <unit id="635">
        <segment state="initial">
          <source>This graph provides a detailed view of the time period over which DPCs/ISRs ran.</source>
          <target>This graph provides a detailed view of the time period over which DPCs/ISRs ran.</target>
        </segment>
      </unit>
      <unit id="636">
        <segment state="initial">
          <source>This graph can also show how single DPC/ISRs can be fragmented.</source>
          <target>This graph can also show how single DPC/ISRs can be fragmented.</target>
        </segment>
      </unit>
      <unit id="637">
        <segment state="initial">
          <source>Figure 19 DPC/ISR Timeline by Module, Function shows a timeline of activity in three modules:</source>
          <target>Figure 19 DPC/ISR Timeline by Module, Function shows a timeline of activity in three modules:</target>
        </segment>
      </unit>
      <unit id="638">
        <segment state="initial">
          <source>figure 19 dpc isr timeline by module function</source>
          <target>figure 19 dpc isr timeline by module function</target>
        </segment>
      </unit>
      <unit id="639">
        <segment state="initial">
          <source>Figure 19 DPC/ISR Timeline by Module, Function</source>
          <target>Figure 19 DPC/ISR Timeline by Module, Function</target>
        </segment>
      </unit>
      <unit id="640">
        <segment state="initial">
          <source>Stack Trees</source>
          <target>Stack Trees</target>
        </segment>
      </unit>
      <unit id="641">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>Stack trees are displayed in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (Precise)</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DPC/ISR</pc> tables in WPA, and in issues that are reported in assessment reports.</source>
          <target>Stack trees are displayed in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (Precise)</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DPC/ISR</pc> tables in WPA, and in issues that are reported in assessment reports.</target>
        </segment>
      </unit>
      <unit id="642">
        <segment state="initial">
          <source>Stack trees portray the call stacks that are associated with multiple events over a period of time.</source>
          <target>Stack trees portray the call stacks that are associated with multiple events over a period of time.</target>
        </segment>
      </unit>
      <unit id="643">
        <segment state="initial">
          <source>Each node in the tree represents a stack segment that is shared by a subset of the events.</source>
          <target>Each node in the tree represents a stack segment that is shared by a subset of the events.</target>
        </segment>
      </unit>
      <unit id="644">
        <segment state="initial">
          <source>The tree is constructed from the individual stacks and is shown in Figure 20 Stacks from Three Events:</source>
          <target>The tree is constructed from the individual stacks and is shown in Figure 20 Stacks from Three Events:</target>
        </segment>
      </unit>
      <unit id="645">
        <segment state="initial">
          <source>figure 20 stacks from three events</source>
          <target>figure 20 stacks from three events</target>
        </segment>
      </unit>
      <unit id="646">
        <segment state="initial">
          <source>Figure 20 Stacks from Three Events</source>
          <target>Figure 20 Stacks from Three Events</target>
        </segment>
      </unit>
      <unit id="647">
        <segment state="initial">
          <source>Figure 21 Common Segments Identified shows how common sequences are identified for this graph:</source>
          <target>Figure 21 Common Segments Identified shows how common sequences are identified for this graph:</target>
        </segment>
      </unit>
      <unit id="648">
        <segment state="initial">
          <source>figure 21 common segments identified</source>
          <target>figure 21 common segments identified</target>
        </segment>
      </unit>
      <unit id="649">
        <segment state="initial">
          <source>Figure 21 Common Segments Identified</source>
          <target>Figure 21 Common Segments Identified</target>
        </segment>
      </unit>
      <unit id="650">
        <segment state="initial">
          <source>Figure 22 Tree Built from Stacks shows how the common segments are combined to form the nodes of a tree:</source>
          <target>Figure 22 Tree Built from Stacks shows how the common segments are combined to form the nodes of a tree:</target>
        </segment>
      </unit>
      <unit id="651">
        <segment state="initial">
          <source>figure 22 tree built from stacks</source>
          <target>figure 22 tree built from stacks</target>
        </segment>
      </unit>
      <unit id="652">
        <segment state="initial">
          <source>Figure 22 Tree Built from Stacks</source>
          <target>Figure 22 Tree Built from Stacks</target>
        </segment>
      </unit>
      <unit id="653">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stacks</pc> column in the WPA UI contains an expander for each non-leaf node.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stacks</pc> column in the WPA UI contains an expander for each non-leaf node.</target>
        </segment>
      </unit>
      <unit id="654">
        <segment state="initial">
          <source>In assessment-reported issues, the tree is displayed together with the aggregate weights.</source>
          <target>In assessment-reported issues, the tree is displayed together with the aggregate weights.</target>
        </segment>
      </unit>
      <unit id="655">
        <segment state="initial">
          <source>Some branches can be removed from the graph if their weights do not meet a specified threshold.</source>
          <target>Some branches can be removed from the graph if their weights do not meet a specified threshold.</target>
        </segment>
      </unit>
      <unit id="656">
        <segment state="initial">
          <source>The sample stack below shows how the events represented above are displayed as part of an assessment-reported issue.</source>
          <target>The sample stack below shows how the events represented above are displayed as part of an assessment-reported issue.</target>
        </segment>
      </unit>
      <unit id="657">
        <originalData>
          <data id="id1">`&lt;itself&gt;`</data>
        </originalData>
        <segment state="initial">
          <source>The <ph dataRef="id1" id="ph1" /> node in a stack represents the time that a function itself is at the bottom of the stack.</source>
          <target>The <ph dataRef="id1" id="ph1" /> node in a stack represents the time that a function itself is at the bottom of the stack.</target>
        </segment>
      </unit>
      <unit id="658">
        <originalData>
          <data id="id1">`&lt;itself&gt;`</data>
        </originalData>
        <segment state="initial">
          <source>The <ph dataRef="id1" id="ph1" /> node does not include the time that is spent in functions that are called by the parent function.</source>
          <target>The <ph dataRef="id1" id="ph1" /> node does not include the time that is spent in functions that are called by the parent function.</target>
        </segment>
      </unit>
      <unit id="659">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>That duration is called the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">exclusive</pc> time spent in the function.</source>
          <target>That duration is called the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">exclusive</pc> time spent in the function.</target>
        </segment>
      </unit>
      <unit id="660">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Function1</pc> calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Function2</pc>.</source>
          <target>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Function1</pc> calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Function2</pc>.</target>
        </segment>
      </unit>
      <unit id="661">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Function2</pc> spent 2ms in a CPU-intensive loop and called another function that ran for 4ms.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Function2</pc> spent 2ms in a CPU-intensive loop and called another function that ran for 4ms.</target>
        </segment>
      </unit>
      <unit id="662">
        <segment state="initial">
          <source>This can be represented by the following stack:</source>
          <target>This can be represented by the following stack:</target>
        </segment>
      </unit>
      <unit id="663">
        <segment state="initial">
          <source>Techniques</source>
          <target>Techniques</target>
        </segment>
      </unit>
      <unit id="664">
        <segment state="initial">
          <source>This section describes a standard approach to performance analysis.</source>
          <target>This section describes a standard approach to performance analysis.</target>
        </segment>
      </unit>
      <unit id="665">
        <segment state="initial">
          <source>It provides techniques that you can use to investigate common CPU-related performance problems.</source>
          <target>It provides techniques that you can use to investigate common CPU-related performance problems.</target>
        </segment>
      </unit>
      <unit id="666">
        <segment state="initial">
          <source>Performance analysis is a four-step process:</source>
          <target>Performance analysis is a four-step process:</target>
        </segment>
      </unit>
      <unit id="667">
        <segment state="initial">
          <source>Define the scenario and the problem.</source>
          <target>Define the scenario and the problem.</target>
        </segment>
      </unit>
      <unit id="668">
        <segment state="initial">
          <source>Identify the components that are involved and the relevant time range.</source>
          <target>Identify the components that are involved and the relevant time range.</target>
        </segment>
      </unit>
      <unit id="669">
        <segment state="initial">
          <source>Create a model of what should have happened.</source>
          <target>Create a model of what should have happened.</target>
        </segment>
      </unit>
      <unit id="670">
        <segment state="initial">
          <source>Use the model to identify problems and investigate root causes.</source>
          <target>Use the model to identify problems and investigate root causes.</target>
        </segment>
      </unit>
      <unit id="671">
        <segment state="initial">
          <source>Define the Scenario and the Problem</source>
          <target>Define the Scenario and the Problem</target>
        </segment>
      </unit>
      <unit id="672">
        <segment state="initial">
          <source>The first step in performance analysis is to clearly define the scenario and the problem.</source>
          <target>The first step in performance analysis is to clearly define the scenario and the problem.</target>
        </segment>
      </unit>
      <unit id="673">
        <segment state="initial">
          <source>Many performance problems affect scenarios that are measured by assessment metrics.</source>
          <target>Many performance problems affect scenarios that are measured by assessment metrics.</target>
        </segment>
      </unit>
      <unit id="674">
        <segment state="initial">
          <source>For example:</source>
          <target>For example:</target>
        </segment>
      </unit>
      <unit id="675">
        <segment state="initial">
          <source>Scenario 1: A physical resource is not being fully utilized.</source>
          <target>Scenario 1: A physical resource is not being fully utilized.</target>
        </segment>
      </unit>
      <unit id="676">
        <segment state="initial">
          <source>For example, a server cannot fully utilize a network connection because it cannot encrypt packets quickly enough.</source>
          <target>For example, a server cannot fully utilize a network connection because it cannot encrypt packets quickly enough.</target>
        </segment>
      </unit>
      <unit id="677">
        <segment state="initial">
          <source>Scenario 2: A physical resource is being utilized more than it should be.</source>
          <target>Scenario 2: A physical resource is being utilized more than it should be.</target>
        </segment>
      </unit>
      <unit id="678">
        <segment state="initial">
          <source>For example, a system uses significant CPU resources during an idle period that uses battery power.</source>
          <target>For example, a system uses significant CPU resources during an idle period that uses battery power.</target>
        </segment>
      </unit>
      <unit id="679">
        <segment state="initial">
          <source>Scenario 3: Activities are not being completed at a required rate.</source>
          <target>Scenario 3: Activities are not being completed at a required rate.</target>
        </segment>
      </unit>
      <unit id="680">
        <segment state="initial">
          <source>For example, frames are dropped during video playback because the frames are not being decoded quickly enough.</source>
          <target>For example, frames are dropped during video playback because the frames are not being decoded quickly enough.</target>
        </segment>
      </unit>
      <unit id="681">
        <segment state="initial">
          <source>Scenario 4: An activity was delayed.</source>
          <target>Scenario 4: An activity was delayed.</target>
        </segment>
      </unit>
      <unit id="682">
        <segment state="initial">
          <source>For example, the user launched Internet Explorer but it took longer than expected to open a tab.</source>
          <target>For example, the user launched Internet Explorer but it took longer than expected to open a tab.</target>
        </segment>
      </unit>
      <unit id="683">
        <segment state="initial">
          <source>Scenarios 3 and 4 as they related to CPU resources are covered in this guide.</source>
          <target>Scenarios 3 and 4 as they related to CPU resources are covered in this guide.</target>
        </segment>
      </unit>
      <unit id="684">
        <segment state="initial">
          <source>Scenarios 1 and 2 are out of scope and are not covered.</source>
          <target>Scenarios 1 and 2 are out of scope and are not covered.</target>
        </segment>
      </unit>
      <unit id="685">
        <segment state="initial">
          <source>To analyze these problems, you can start with an ambiguous observation such as “it is too slow” and ask additional questions to identify the scenario and the exact problem.</source>
          <target>To analyze these problems, you can start with an ambiguous observation such as “it is too slow” and ask additional questions to identify the scenario and the exact problem.</target>
        </segment>
      </unit>
      <unit id="686">
        <segment state="initial">
          <source>Identify the Components and the Time Period</source>
          <target>Identify the Components and the Time Period</target>
        </segment>
      </unit>
      <unit id="687">
        <segment state="initial">
          <source>After the scenario and the problem are identified, you can identify the components that are involved and the time period of interest.</source>
          <target>After the scenario and the problem are identified, you can identify the components that are involved and the time period of interest.</target>
        </segment>
      </unit>
      <unit id="688">
        <segment state="initial">
          <source>The components include hardware resources, processes, and threads.</source>
          <target>The components include hardware resources, processes, and threads.</target>
        </segment>
      </unit>
      <unit id="689">
        <segment state="initial">
          <source>You can often find the time range of interest by identifying the associated activity in the analysis guide.</source>
          <target>You can often find the time range of interest by identifying the associated activity in the analysis guide.</target>
        </segment>
      </unit>
      <unit id="690">
        <segment state="initial">
          <source>An activity is an interval between a start event and a stop event that you can select and zoom into, in WPA.</source>
          <target>An activity is an interval between a start event and a stop event that you can select and zoom into, in WPA.</target>
        </segment>
      </unit>
      <unit id="691">
        <segment state="initial">
          <source>If an activity is not defined, you can find the time range by looking for specific generic events that are associated with the scenario, or by looking for changes in resource utilization that might mark the beginning and end of a scenario.</source>
          <target>If an activity is not defined, you can find the time range by looking for specific generic events that are associated with the scenario, or by looking for changes in resource utilization that might mark the beginning and end of a scenario.</target>
        </segment>
      </unit>
      <unit id="692">
        <segment state="initial">
          <source>For example, if the CPU was idle for two seconds and then fully utilized for four seconds and then idle again for two seconds, the four seconds of full utilization might be the area of interest in a trace that captures video playback.</source>
          <target>For example, if the CPU was idle for two seconds and then fully utilized for four seconds and then idle again for two seconds, the four seconds of full utilization might be the area of interest in a trace that captures video playback.</target>
        </segment>
      </unit>
      <unit id="693">
        <segment state="initial">
          <source>Create a Model</source>
          <target>Create a Model</target>
        </segment>
      </unit>
      <unit id="694">
        <segment state="initial">
          <source>To understand the root causes of a problem, you must have a model of what should have happened.</source>
          <target>To understand the root causes of a problem, you must have a model of what should have happened.</target>
        </segment>
      </unit>
      <unit id="695">
        <segment state="initial">
          <source>The model starts with the problem or any associated goal for the metric; for example, “This operation should have completed in less than 5 seconds.”</source>
          <target>The model starts with the problem or any associated goal for the metric; for example, “This operation should have completed in less than 5 seconds.”</target>
        </segment>
      </unit>
      <unit id="696">
        <segment state="initial">
          <source>A more complete model contains information about how the components should perform.</source>
          <target>A more complete model contains information about how the components should perform.</target>
        </segment>
      </unit>
      <unit id="697">
        <segment state="initial">
          <source>For example, what communication is expected between components?</source>
          <target>For example, what communication is expected between components?</target>
        </segment>
      </unit>
      <unit id="698">
        <segment state="initial">
          <source>What resource utilization is typical?</source>
          <target>What resource utilization is typical?</target>
        </segment>
      </unit>
      <unit id="699">
        <segment state="initial">
          <source>How long do operations usually take?</source>
          <target>How long do operations usually take?</target>
        </segment>
      </unit>
      <unit id="700">
        <segment state="initial">
          <source>Information for the model can often be found in the assessment analysis guide.</source>
          <target>Information for the model can often be found in the assessment analysis guide.</target>
        </segment>
      </unit>
      <unit id="701">
        <segment state="initial">
          <source>If that resource is not available, you can produce a trace from similar hardware and software that does not exhibit the performance problem, to create a model.</source>
          <target>If that resource is not available, you can produce a trace from similar hardware and software that does not exhibit the performance problem, to create a model.</target>
        </segment>
      </unit>
      <unit id="702">
        <segment state="initial">
          <source>Use the Model to Identify Problems, and then Investigate Root Causes</source>
          <target>Use the Model to Identify Problems, and then Investigate Root Causes</target>
        </segment>
      </unit>
      <unit id="703">
        <segment state="initial">
          <source>After you have a model, you can compare a trace to the model to identify problems.</source>
          <target>After you have a model, you can compare a trace to the model to identify problems.</target>
        </segment>
      </unit>
      <unit id="704">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&amp;lt;</data>
          <data id="id6">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>For example, a model for a particular activity called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Suspend Devices</pc> might suggest that the entire activity should complete in three seconds, while each instance of a sub-activity called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Suspend <ph dataRef="id5" id="ph1" />Device Name<ph dataRef="id6" id="ph2" /></pc> should take no more than 100ms.</source>
          <target>For example, a model for a particular activity called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Suspend Devices</pc> might suggest that the entire activity should complete in three seconds, while each instance of a sub-activity called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Suspend <ph dataRef="id5" id="ph1" />Device Name<ph dataRef="id6" id="ph2" /></pc> should take no more than 100ms.</target>
        </segment>
      </unit>
      <unit id="705">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>If two instances of the sub-activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Suspend <ph dataRef="id3" id="ph1" />Device Name<ph dataRef="id4" id="ph2" /></pc> each take 800ms, you should investigate those instances.</source>
          <target>If two instances of the sub-activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Suspend <ph dataRef="id3" id="ph1" />Device Name<ph dataRef="id4" id="ph2" /></pc> each take 800ms, you should investigate those instances.</target>
        </segment>
      </unit>
      <unit id="706">
        <segment state="initial">
          <source>Each deviation from the model can be analyzed to find a root cause.</source>
          <target>Each deviation from the model can be analyzed to find a root cause.</target>
        </segment>
      </unit>
      <unit id="707">
        <segment state="initial">
          <source>You should examine the state of the involved threads and look for common root causes.</source>
          <target>You should examine the state of the involved threads and look for common root causes.</target>
        </segment>
      </unit>
      <unit id="708">
        <segment state="initial">
          <source>A few major CPU-related root causes, for activities that do not complete at a required rate or are delayed, are described here:</source>
          <target>A few major CPU-related root causes, for activities that do not complete at a required rate or are delayed, are described here:</target>
        </segment>
      </unit>
      <unit id="709">
        <segment state="initial">
          <source>Direct CPU usage: The appropriate threads received full CPU resources but the required program did not execute quickly enough.</source>
          <target>Direct CPU usage: The appropriate threads received full CPU resources but the required program did not execute quickly enough.</target>
        </segment>
      </unit>
      <unit id="710">
        <segment state="initial">
          <source>This can be caused by a program malfunction or by slow hardware.</source>
          <target>This can be caused by a program malfunction or by slow hardware.</target>
        </segment>
      </unit>
      <unit id="711">
        <segment state="initial">
          <source>Thread Interference: A thread did not get enough running time because other threads were running instead.</source>
          <target>Thread Interference: A thread did not get enough running time because other threads were running instead.</target>
        </segment>
      </unit>
      <unit id="712">
        <segment state="initial">
          <source>In this case, the thread is considered to be starved or preempted.</source>
          <target>In this case, the thread is considered to be starved or preempted.</target>
        </segment>
      </unit>
      <unit id="713">
        <segment state="initial">
          <source>DPC/ISR Interference: Threads did not get enough running time because CPUs were busy processing DPCs or ISRs.</source>
          <target>DPC/ISR Interference: Threads did not get enough running time because CPUs were busy processing DPCs or ISRs.</target>
        </segment>
      </unit>
      <unit id="714">
        <segment state="initial">
          <source>In many cases, one of these root causes does not noticeably affect the thread, and the thread spends most of its time in a waiting state.</source>
          <target>In many cases, one of these root causes does not noticeably affect the thread, and the thread spends most of its time in a waiting state.</target>
        </segment>
      </unit>
      <unit id="715">
        <segment state="initial">
          <source>In this case, you must identify and investigate the event for which the thread is waiting.</source>
          <target>In this case, you must identify and investigate the event for which the thread is waiting.</target>
        </segment>
      </unit>
      <unit id="716">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>This recursive type of investigation is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">wait analysis</pc>, and it starts by identifying the critical path.</source>
          <target>This recursive type of investigation is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">wait analysis</pc>, and it starts by identifying the critical path.</target>
        </segment>
      </unit>
      <unit id="717">
        <segment state="initial">
          <source>Advanced Technique: Wait Analysis and the Critical Path</source>
          <target>Advanced Technique: Wait Analysis and the Critical Path</target>
        </segment>
      </unit>
      <unit id="718">
        <segment state="initial">
          <source>An activity is a network of operations, some sequential and some parallel, that flow from a start event to an end event.</source>
          <target>An activity is a network of operations, some sequential and some parallel, that flow from a start event to an end event.</target>
        </segment>
      </unit>
      <unit id="719">
        <segment state="initial">
          <source>Any start/end event pair in a trace can be viewed as an activity.</source>
          <target>Any start/end event pair in a trace can be viewed as an activity.</target>
        </segment>
      </unit>
      <unit id="720">
        <segment state="initial">
          <source>The longest path through this network of operations is known as the critical path.</source>
          <target>The longest path through this network of operations is known as the critical path.</target>
        </segment>
      </unit>
      <unit id="721">
        <segment state="initial">
          <source>Reducing the duration of any operation on the critical path directly reduces the duration of the overall activity, although it can also change the critical path.</source>
          <target>Reducing the duration of any operation on the critical path directly reduces the duration of the overall activity, although it can also change the critical path.</target>
        </segment>
      </unit>
      <unit id="722">
        <segment state="initial">
          <source>Figure 23 Activity Operations shows the activity of three threads.</source>
          <target>Figure 23 Activity Operations shows the activity of three threads.</target>
        </segment>
      </unit>
      <unit id="723">
        <segment state="initial">
          <source>Thread-1 sends the activity start event and then waits for Thread-2 and Thread-3 to complete their tasks.</source>
          <target>Thread-1 sends the activity start event and then waits for Thread-2 and Thread-3 to complete their tasks.</target>
        </segment>
      </unit>
      <unit id="724">
        <segment state="initial">
          <source>Thread-2 completes its task first, followed by Thread-3.</source>
          <target>Thread-2 completes its task first, followed by Thread-3.</target>
        </segment>
      </unit>
      <unit id="725">
        <segment state="initial">
          <source>When both threads have completed their tasks, Thread-1 is readied and completes the activity event.</source>
          <target>When both threads have completed their tasks, Thread-1 is readied and completes the activity event.</target>
        </segment>
      </unit>
      <unit id="726">
        <segment state="initial">
          <source>figure 23 activity operations</source>
          <target>figure 23 activity operations</target>
        </segment>
      </unit>
      <unit id="727">
        <segment state="initial">
          <source>Figure 23 Activity Operations</source>
          <target>Figure 23 Activity Operations</target>
        </segment>
      </unit>
      <unit id="728">
        <segment state="initial">
          <source>In this scenario, the critical path includes parts of Thread-3 and Thread-1.</source>
          <target>In this scenario, the critical path includes parts of Thread-3 and Thread-1.</target>
        </segment>
      </unit>
      <unit id="729">
        <segment state="initial">
          <source>These are traced in Figure 24 Critical Path.</source>
          <target>These are traced in Figure 24 Critical Path.</target>
        </segment>
      </unit>
      <unit id="730">
        <segment state="initial">
          <source>Because Thread-2 is not on the critical path, the time that it takes to complete its task does not affect the overall activity time.</source>
          <target>Because Thread-2 is not on the critical path, the time that it takes to complete its task does not affect the overall activity time.</target>
        </segment>
      </unit>
      <unit id="731">
        <segment state="initial">
          <source>figure 24 critical path</source>
          <target>figure 24 critical path</target>
        </segment>
      </unit>
      <unit id="732">
        <segment state="initial">
          <source>Figure 24 Critical Path</source>
          <target>Figure 24 Critical Path</target>
        </segment>
      </unit>
      <unit id="733">
        <segment state="initial">
          <source>The critical path is a low-level literal answer to the question of why an activity took as much time as it did.</source>
          <target>The critical path is a low-level literal answer to the question of why an activity took as much time as it did.</target>
        </segment>
      </unit>
      <unit id="734">
        <segment state="initial">
          <source>After key segments of critical path are known, they can be analyzed to find the problems that contribute to the overall delay.</source>
          <target>After key segments of critical path are known, they can be analyzed to find the problems that contribute to the overall delay.</target>
        </segment>
      </unit>
      <unit id="735">
        <segment state="initial">
          <source>General Approach to Finding the Critical Path</source>
          <target>General Approach to Finding the Critical Path</target>
        </segment>
      </unit>
      <unit id="736">
        <segment state="initial">
          <source>The first step to finding the critical path is to review the scenario model to understand the purpose and implementation of the activity.</source>
          <target>The first step to finding the critical path is to review the scenario model to understand the purpose and implementation of the activity.</target>
        </segment>
      </unit>
      <unit id="737">
        <segment state="initial">
          <source>Understanding an activity can help identify specific operations, processes, and threads that might be on the critical path.</source>
          <target>Understanding an activity can help identify specific operations, processes, and threads that might be on the critical path.</target>
        </segment>
      </unit>
      <unit id="738">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>For example, a delay in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Fast Startup Resume Explorer Init</pc> activity can be caused by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RunOnce</pc> applications and the Explorer initialization process, both of which require a significant amount of I/O.</source>
          <target>For example, a delay in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Fast Startup Resume Explorer Init</pc> activity can be caused by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RunOnce</pc> applications and the Explorer initialization process, both of which require a significant amount of I/O.</target>
        </segment>
      </unit>
      <unit id="739">
        <segment state="initial">
          <source>After you review the scenario model, check to see whether the assessment reported any issues for the affected activity.</source>
          <target>After you review the scenario model, check to see whether the assessment reported any issues for the affected activity.</target>
        </segment>
      </unit>
      <unit id="740">
        <segment state="initial">
          <source>Many times, an approximation of the critical path is included in assessment-reported delay issues.</source>
          <target>Many times, an approximation of the critical path is included in assessment-reported delay issues.</target>
        </segment>
      </unit>
      <unit id="741">
        <segment state="initial">
          <source>The critical path is shown as a sequence of waits and ready actions.</source>
          <target>The critical path is shown as a sequence of waits and ready actions.</target>
        </segment>
      </unit>
      <unit id="742">
        <segment state="initial">
          <source>It can be read from start to finish as a sequence of events, with the primary delayed segment of the critical path in the middle of the list.</source>
          <target>It can be read from start to finish as a sequence of events, with the primary delayed segment of the critical path in the middle of the list.</target>
        </segment>
      </unit>
      <unit id="743">
        <segment state="initial">
          <source>The last entry in the list is the action that readied the thread that completed the activity.</source>
          <target>The last entry in the list is the action that readied the thread that completed the activity.</target>
        </segment>
      </unit>
      <unit id="744">
        <segment state="initial">
          <source>If you must manually look for the critical path, we recommend that you identify the process and the thread that completed the activity and work backwards from the instant that the activity completed.</source>
          <target>If you must manually look for the critical path, we recommend that you identify the process and the thread that completed the activity and work backwards from the instant that the activity completed.</target>
        </segment>
      </unit>
      <unit id="745">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can identify the process and thread that started an activity, and the process and thread that completed an activity, through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph in WPA.</source>
          <target>You can identify the process and thread that started an activity, and the process and thread that completed an activity, through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph in WPA.</target>
        </segment>
      </unit>
      <unit id="746">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph displays when the trace is loaded through an assessment results XML file.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph displays when the trace is loaded through an assessment results XML file.</target>
        </segment>
      </unit>
      <unit id="747">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>To identify the process and the thread that are associated with a particular activity, expand the graph to the Activity of interest and then switch the view to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Graph+Table</pc>.</source>
          <target>To identify the process and the thread that are associated with a particular activity, expand the graph to the Activity of interest and then switch the view to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Graph+Table</pc>.</target>
        </segment>
      </unit>
      <unit id="748">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Set the graph mode to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Table</pc>.</source>
          <target>Set the graph mode to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Table</pc>.</target>
        </segment>
      </unit>
      <unit id="749">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start Process</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start Thread Id</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">End Process</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">End Thread Id</pc> columns display for each activity in the table.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start Process</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start Thread Id</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">End Process</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">End Thread Id</pc> columns display for each activity in the table.</target>
        </segment>
      </unit>
      <unit id="750">
        <segment state="initial">
          <source>After you know the start and end process, the thread, and the implementation of the activity, the critical path can be traced backwards.</source>
          <target>After you know the start and end process, the thread, and the implementation of the activity, the critical path can be traced backwards.</target>
        </segment>
      </unit>
      <unit id="751">
        <segment state="initial">
          <source>Start by analyzing the thread that completed the activity, to determine how that thread spent most of its time: running, ready, or waiting.</source>
          <target>Start by analyzing the thread that completed the activity, to determine how that thread spent most of its time: running, ready, or waiting.</target>
        </segment>
      </unit>
      <unit id="752">
        <segment state="initial">
          <source>Significant running time indicates that direct CPU usage might have contributed to the duration of the critical path.</source>
          <target>Significant running time indicates that direct CPU usage might have contributed to the duration of the critical path.</target>
        </segment>
      </unit>
      <unit id="753">
        <segment state="initial">
          <source>Time spent in ready mode indicates that other threads contribute to the duration of the critical path by preventing a thread on the critical path from executing.</source>
          <target>Time spent in ready mode indicates that other threads contribute to the duration of the critical path by preventing a thread on the critical path from executing.</target>
        </segment>
      </unit>
      <unit id="754">
        <segment state="initial">
          <source>Time spent waiting points to I/O, timers, or other threads and processes on the critical path for which the current thread was waiting.</source>
          <target>Time spent waiting points to I/O, timers, or other threads and processes on the critical path for which the current thread was waiting.</target>
        </segment>
      </unit>
      <unit id="755">
        <segment state="initial">
          <source>Each thread that readied the current thread is probably another link in the critical path, and can also be analyzed until the duration of the critical path is accounted for.</source>
          <target>Each thread that readied the current thread is probably another link in the critical path, and can also be analyzed until the duration of the critical path is accounted for.</target>
        </segment>
      </unit>
      <unit id="756">
        <segment state="initial">
          <source>Procedure: Finding the Critical Path in WPA</source>
          <target>Procedure: Finding the Critical Path in WPA</target>
        </segment>
      </unit>
      <unit id="757">
        <segment state="initial">
          <source>The following procedure assumes that you have identified an activity in the Activities graph for which you want to find the critical path.</source>
          <target>The following procedure assumes that you have identified an activity in the Activities graph for which you want to find the critical path.</target>
        </segment>
      </unit>
      <unit id="758">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can identify the process that completed the activity by hovering over the activity in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph.</source>
          <target>You can identify the process that completed the activity by hovering over the activity in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Activities</pc> graph.</target>
        </segment>
      </unit>
      <unit id="759">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph.</source>
          <target>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph.</target>
        </segment>
      </unit>
      <unit id="760">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Zoom to the affected activity, and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset.</source>
          <target>Zoom to the affected activity, and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="761">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Right-click the column headers and make the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (ms)</pc> columns visible.</source>
          <target>Right-click the column headers and make the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (ms)</pc> columns visible.</target>
        </segment>
      </unit>
      <unit id="762">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\[</data>
          <data id="id4">\]</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">\[</data>
          <data id="id8">\]</data>
        </originalData>
        <segment state="initial">
          <source>Remove the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready (us) <ph dataRef="id3" id="ph1" />Max<ph dataRef="id4" id="ph2" /></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p2">Waits (us) <ph dataRef="id7" id="ph3" />Max<ph dataRef="id8" id="ph4" /></pc> columns.</source>
          <target>Remove the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready (us) <ph dataRef="id3" id="ph1" />Max<ph dataRef="id4" id="ph2" /></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p2">Waits (us) <ph dataRef="id7" id="ph3" />Max<ph dataRef="id8" id="ph4" /></pc> columns.</target>
        </segment>
      </unit>
      <unit id="763">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">\[</data>
          <data id="id6">\]</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">\[</data>
          <data id="id10">\]</data>
        </originalData>
        <segment state="initial">
          <source>Expand the target process and sort it respectively by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us) <ph dataRef="id5" id="ph1" />Sum<ph dataRef="id6" id="ph2" /></pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p3">Waits (us) <ph dataRef="id9" id="ph3" />Sum<ph dataRef="id10" id="ph4" /></pc>.</source>
          <target>Expand the target process and sort it respectively by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us) <ph dataRef="id5" id="ph1" />Sum<ph dataRef="id6" id="ph2" /></pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p3">Waits (us) <ph dataRef="id9" id="ph3" />Sum<ph dataRef="id10" id="ph4" /></pc>.</target>
        </segment>
      </unit>
      <unit id="764">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Search for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadIds</pc> in the process that has the highest amount of time spent in Running, Ready, or Waiting state.</source>
          <target>Search for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadIds</pc> in the process that has the highest amount of time spent in Running, Ready, or Waiting state.</target>
        </segment>
      </unit>
      <unit id="765">
        <segment state="initial">
          <source>Threads that spend significant time in the Running or Ready states might represent direct CPU usage on the critical path.</source>
          <target>Threads that spend significant time in the Running or Ready states might represent direct CPU usage on the critical path.</target>
        </segment>
      </unit>
      <unit id="766">
        <segment state="initial">
          <source>Note their thread IDs.Threads that spend significant time in the Waiting state might be waiting on I/O, a timer, or on another thread in the critical path.</source>
          <target>Note their thread IDs.Threads that spend significant time in the Waiting state might be waiting on I/O, a timer, or on another thread in the critical path.</target>
        </segment>
      </unit>
      <unit id="767">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To discover what the threads were waiting for, expand the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadId</pc> group to display the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyThreadStack</pc>.</source>
          <target>To discover what the threads were waiting for, expand the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadId</pc> group to display the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyThreadStack</pc>.</target>
        </segment>
      </unit>
      <unit id="768">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\[</data>
          <data id="id4">\]</data>
        </originalData>
        <segment state="initial">
          <source>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" />Root<ph dataRef="id4" id="ph2" /></pc>.</source>
          <target>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" />Root<ph dataRef="id4" id="ph2" /></pc>.</target>
        </segment>
      </unit>
      <unit id="769">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Stacks that begin with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> are not related to another thread.</source>
          <target>Stacks that begin with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> are not related to another thread.</target>
        </segment>
      </unit>
      <unit id="770">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>To determine what the thread was waiting for in these stacks, expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> and view the functions on the child stack.</source>
          <target>To determine what the thread was waiting for in these stacks, expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> and view the functions on the child stack.</target>
        </segment>
      </unit>
      <unit id="771">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IopfCompleteRequest</pc> indicates that the readied thread was waiting for I/O.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IopfCompleteRequest</pc> indicates that the readied thread was waiting for I/O.</target>
        </segment>
      </unit>
      <unit id="772">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiTimerExpiration</pc> indicates that the readied thread was waiting for a timer.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiTimerExpiration</pc> indicates that the readied thread was waiting for a timer.</target>
        </segment>
      </unit>
      <unit id="773">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>Expand stacks that do not begin with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> until you see a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyingProcess</pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ReadyingThread</pc>.</source>
          <target>Expand stacks that do not begin with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiDispatchInterrupt</pc> until you see a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyingProcess</pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ReadyingThread</pc>.</target>
        </segment>
      </unit>
      <unit id="774">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If the process is already expanded, expand the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadId</pc> that corresponds to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyingThread</pc>.</source>
          <target>If the process is already expanded, expand the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewThreadId</pc> that corresponds to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyingThread</pc>.</target>
        </segment>
      </unit>
      <unit id="775">
        <segment state="initial">
          <source>Repeat this step until you find a thread that is running, ready, waiting for another reason, or waiting on a different process.</source>
          <target>Repeat this step until you find a thread that is running, ready, waiting for another reason, or waiting on a different process.</target>
        </segment>
      </unit>
      <unit id="776">
        <segment state="initial">
          <source>If the thread is waiting on a different process, repeat this procedure by using that process.</source>
          <target>If the thread is waiting on a different process, repeat this procedure by using that process.</target>
        </segment>
      </unit>
      <unit id="777">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="778">
        <segment state="initial">
          <source>This example presents a delay in the Fast Startup Resume Explorer Init activity.</source>
          <target>This example presents a delay in the Fast Startup Resume Explorer Init activity.</target>
        </segment>
      </unit>
      <unit id="779">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>A search in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Issues</pc> pane shows that seven delay-type issues are reported for this activity.</source>
          <target>A search in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Issues</pc> pane shows that seven delay-type issues are reported for this activity.</target>
        </segment>
      </unit>
      <unit id="780">
        <segment state="initial">
          <source>Each of these issues can be reviewed as a segment of the critical path.</source>
          <target>Each of these issues can be reviewed as a segment of the critical path.</target>
        </segment>
      </unit>
      <unit id="781">
        <segment state="initial">
          <source>The following key segments are identified:</source>
          <target>The following key segments are identified:</target>
        </segment>
      </unit>
      <unit id="782">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) is preempted for 2.1 seconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) is preempted for 2.1 seconds.</target>
        </segment>
      </unit>
      <unit id="783">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) uses 1 second of CPU time.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) uses 1 second of CPU time.</target>
        </segment>
      </unit>
      <unit id="784">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) flushes a registry hive for 544 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) flushes a registry hive for 544 milliseconds.</target>
        </segment>
      </unit>
      <unit id="785">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) sleeps for 513 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) sleeps for 513 milliseconds.</target>
        </segment>
      </unit>
      <unit id="786">
        <segment state="initial">
          <source>Threads 4052 and 4036 of Explorer.exe read from disk, causing a 461 millisecond delay.</source>
          <target>Threads 4052 and 4036 of Explorer.exe read from disk, causing a 461 millisecond delay.</target>
        </segment>
      </unit>
      <unit id="787">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) starves for 187 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) starves for 187 milliseconds.</target>
        </segment>
      </unit>
      <unit id="788">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe writes 3.5MB to disk, causing a 178 millisecond delay.</source>
          <target>Thread 3872 of process TestBootStrapper.exe writes 3.5MB to disk, causing a 178 millisecond delay.</target>
        </segment>
      </unit>
      <unit id="789">
        <segment state="initial">
          <source>The issues show that this activity was delayed by 5.2 seconds.</source>
          <target>The issues show that this activity was delayed by 5.2 seconds.</target>
        </segment>
      </unit>
      <unit id="790">
        <segment state="initial">
          <source>These delays contribute a large proportion of the activities overall 6.3 second duration.</source>
          <target>These delays contribute a large proportion of the activities overall 6.3 second duration.</target>
        </segment>
      </unit>
      <unit id="791">
        <segment state="initial">
          <source>The TestBootStrapper.exe application is primarily responsible for the delay, primarily because it preempted other processing tasks.</source>
          <target>The TestBootStrapper.exe application is primarily responsible for the delay, primarily because it preempted other processing tasks.</target>
        </segment>
      </unit>
      <unit id="792">
        <segment state="initial">
          <source>Investigate Issues in the Critical Path</source>
          <target>Investigate Issues in the Critical Path</target>
        </segment>
      </unit>
      <unit id="793">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Zoom to the affected region and add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (ms)</pc> columns.</source>
          <target>Zoom to the affected region and add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (ms)</pc> columns.</target>
        </segment>
      </unit>
      <unit id="794">
        <segment state="initial">
          <source>In this case, Explorer.exe is the process that completes the activity.</source>
          <target>In this case, Explorer.exe is the process that completes the activity.</target>
        </segment>
      </unit>
      <unit id="795">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">\[</data>
          <data id="id6">\]</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">\[</data>
          <data id="id10">\]</data>
        </originalData>
        <segment state="initial">
          <source>Expand the explorer.exe process and sort it respectively by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us) <ph dataRef="id5" id="ph1" />Sum<ph dataRef="id6" id="ph2" /></pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p3">Waits (us) <ph dataRef="id9" id="ph3" />Sum<ph dataRef="id10" id="ph4" /></pc>, as shown in the following figures:</source>
          <target>Expand the explorer.exe process and sort it respectively by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us) <ph dataRef="id5" id="ph1" />Sum<ph dataRef="id6" id="ph2" /></pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p3">Waits (us) <ph dataRef="id9" id="ph3" />Sum<ph dataRef="id10" id="ph4" /></pc>, as shown in the following figures:</target>
        </segment>
      </unit>
      <unit id="796">
        <segment state="initial">
          <source>figure 25 activity by cpu usage ms</source>
          <target>figure 25 activity by cpu usage ms</target>
        </segment>
      </unit>
      <unit id="797">
        <segment state="initial">
          <source>Figure 25 Activity by CPU Usage (ms)</source>
          <target>Figure 25 Activity by CPU Usage (ms)</target>
        </segment>
      </unit>
      <unit id="798">
        <segment state="initial">
          <source>figure 26 activity by ready us</source>
          <target>figure 26 activity by ready us</target>
        </segment>
      </unit>
      <unit id="799">
        <segment state="initial">
          <source>Figure 26 Activity by Ready (us)</source>
          <target>Figure 26 Activity by Ready (us)</target>
        </segment>
      </unit>
      <unit id="800">
        <segment state="initial">
          <source>figure 27 activity by waits us</source>
          <target>figure 27 activity by waits us</target>
        </segment>
      </unit>
      <unit id="801">
        <segment state="initial">
          <source>Figure 27 Activity by Waits (us)</source>
          <target>Figure 27 Activity by Waits (us)</target>
        </segment>
      </unit>
      <unit id="802">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc> column shows a top child row of 299 milliseconds.</source>
          <target>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (ms)</pc> column shows a top child row of 299 milliseconds.</target>
        </segment>
      </unit>
      <unit id="803">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\[</data>
          <data id="id4">\]</data>
        </originalData>
        <segment state="initial">
          <source>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready (us) <ph dataRef="id3" id="ph1" />Sum<ph dataRef="id4" id="ph2" /></pc> column shows a top child row of 46ms.</source>
          <target>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ready (us) <ph dataRef="id3" id="ph1" />Sum<ph dataRef="id4" id="ph2" /></pc> column shows a top child row of 46ms.</target>
        </segment>
      </unit>
      <unit id="804">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\[</data>
          <data id="id4">\]</data>
        </originalData>
        <segment state="initial">
          <source>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waits (us) <ph dataRef="id3" id="ph1" />Sum<ph dataRef="id4" id="ph2" /></pc> column shows a top child row of 5749 milliseconds and a second row of 4902 milliseconds.</source>
          <target>Sorting by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waits (us) <ph dataRef="id3" id="ph1" />Sum<ph dataRef="id4" id="ph2" /></pc> column shows a top child row of 5749 milliseconds and a second row of 4902 milliseconds.</target>
        </segment>
      </unit>
      <unit id="805">
        <segment state="initial">
          <source>Because these rows contribute significantly to the delay, you should investigate them further.</source>
          <target>Because these rows contribute significantly to the delay, you should investigate them further.</target>
        </segment>
      </unit>
      <unit id="806">
        <segment state="initial">
          <source>Expand the stacks to reveal the readying threads, as shown in the following figures:</source>
          <target>Expand the stacks to reveal the readying threads, as shown in the following figures:</target>
        </segment>
      </unit>
      <unit id="807">
        <segment state="initial">
          <source>readying process and readying thread</source>
          <target>readying process and readying thread</target>
        </segment>
      </unit>
      <unit id="808">
        <segment state="initial">
          <source>Figure 28 Readying Process and Readying Thread for a Thread</source>
          <target>Figure 28 Readying Process and Readying Thread for a Thread</target>
        </segment>
      </unit>
      <unit id="809">
        <segment state="initial">
          <source>figure 29 readying process and readying thread for</source>
          <target>figure 29 readying process and readying thread for</target>
        </segment>
      </unit>
      <unit id="810">
        <segment state="initial">
          <source>Figure 29 Readying Process and Readying Thread for another Thread</source>
          <target>Figure 29 Readying Process and Readying Thread for another Thread</target>
        </segment>
      </unit>
      <unit id="811">
        <segment state="initial">
          <source>In this example, the first thread spends most of its time waiting for the RunOnce.exe process to exit.</source>
          <target>In this example, the first thread spends most of its time waiting for the RunOnce.exe process to exit.</target>
        </segment>
      </unit>
      <unit id="812">
        <segment state="initial">
          <source>You should investigate why the RunOnce.exe process is taking so much time to complete.</source>
          <target>You should investigate why the RunOnce.exe process is taking so much time to complete.</target>
        </segment>
      </unit>
      <unit id="813">
        <segment state="initial">
          <source>The second thread is waiting on the first thread, and is probably an insignificant link in the same wait chain.</source>
          <target>The second thread is waiting on the first thread, and is probably an insignificant link in the same wait chain.</target>
        </segment>
      </unit>
      <unit id="814">
        <segment state="initial">
          <source>Repeat the steps in this procedure for RunOnce.exe.</source>
          <target>Repeat the steps in this procedure for RunOnce.exe.</target>
        </segment>
      </unit>
      <unit id="815">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The primary contributing column is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waits (us)</pc>, and it has four possible contributors.</source>
          <target>The primary contributing column is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waits (us)</pc>, and it has four possible contributors.</target>
        </segment>
      </unit>
      <unit id="816">
        <segment state="initial">
          <source>Expand each contributor to see that the first three contributors are each waiting on the fourth contributor.</source>
          <target>Expand each contributor to see that the first three contributors are each waiting on the fourth contributor.</target>
        </segment>
      </unit>
      <unit id="817">
        <segment state="initial">
          <source>This situation makes the first three contributors insignificant to the wait chain.</source>
          <target>This situation makes the first three contributors insignificant to the wait chain.</target>
        </segment>
      </unit>
      <unit id="818">
        <segment state="initial">
          <source>The fourth contributor is waiting on another process, TestBootStrapper.exe.</source>
          <target>The fourth contributor is waiting on another process, TestBootStrapper.exe.</target>
        </segment>
      </unit>
      <unit id="819">
        <segment state="initial">
          <source>This scenario is shown in Figure 30 Readying Process and Readying Thread for a Thread in RunOnce.exe:</source>
          <target>This scenario is shown in Figure 30 Readying Process and Readying Thread for a Thread in RunOnce.exe:</target>
        </segment>
      </unit>
      <unit id="820">
        <segment state="initial">
          <source>figure 30 readying process and readying thread for</source>
          <target>figure 30 readying process and readying thread for</target>
        </segment>
      </unit>
      <unit id="821">
        <segment state="initial">
          <source>Figure 30 Readying Process and Readying Thread for a Thread in RunOnce.exe</source>
          <target>Figure 30 Readying Process and Readying Thread for a Thread in RunOnce.exe</target>
        </segment>
      </unit>
      <unit id="822">
        <segment state="initial">
          <source>Repeat the steps in this procedure for TestBootStrapper.exe.</source>
          <target>Repeat the steps in this procedure for TestBootStrapper.exe.</target>
        </segment>
      </unit>
      <unit id="823">
        <segment state="initial">
          <source>The results are shown in the following three figures:</source>
          <target>The results are shown in the following three figures:</target>
        </segment>
      </unit>
      <unit id="824">
        <segment state="initial">
          <source>figure 31 threads by cpu usage ms</source>
          <target>figure 31 threads by cpu usage ms</target>
        </segment>
      </unit>
      <unit id="825">
        <segment state="initial">
          <source>Figure 31 Threads by CPU Usage (ms)</source>
          <target>Figure 31 Threads by CPU Usage (ms)</target>
        </segment>
      </unit>
      <unit id="826">
        <segment state="initial">
          <source>figure 32 threads by ready us</source>
          <target>figure 32 threads by ready us</target>
        </segment>
      </unit>
      <unit id="827">
        <segment state="initial">
          <source>Figure 32 Threads by Ready (us)</source>
          <target>Figure 32 Threads by Ready (us)</target>
        </segment>
      </unit>
      <unit id="828">
        <segment state="initial">
          <source>figure 33 threads by waits us</source>
          <target>figure 33 threads by waits us</target>
        </segment>
      </unit>
      <unit id="829">
        <segment state="initial">
          <source>Figure 33 Threads by Waits (us)</source>
          <target>Figure 33 Threads by Waits (us)</target>
        </segment>
      </unit>
      <unit id="830">
        <segment state="initial">
          <source>Thread 3872 spent approximately 1 second running, 2 seconds ready, and 1.3 seconds waiting.</source>
          <target>Thread 3872 spent approximately 1 second running, 2 seconds ready, and 1.3 seconds waiting.</target>
        </segment>
      </unit>
      <unit id="831">
        <segment state="initial">
          <source>Because this thread is also the readying thread for thread 3872, the running and ready times probably contribute to the delay.</source>
          <target>Because this thread is also the readying thread for thread 3872, the running and ready times probably contribute to the delay.</target>
        </segment>
      </unit>
      <unit id="832">
        <segment state="initial">
          <source>The assessment reports the following issues whose times match the delays:</source>
          <target>The assessment reports the following issues whose times match the delays:</target>
        </segment>
      </unit>
      <unit id="833">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) is preempted for 2.1 second.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) is preempted for 2.1 second.</target>
        </segment>
      </unit>
      <unit id="834">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) starves for 187 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) starves for 187 milliseconds.</target>
        </segment>
      </unit>
      <unit id="835">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) uses 1 second of CPU time.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) uses 1 second of CPU time.</target>
        </segment>
      </unit>
      <unit id="836">
        <segment state="initial">
          <source>To find other contributing issues, view the event for which thread 3872 was waiting.</source>
          <target>To find other contributing issues, view the event for which thread 3872 was waiting.</target>
        </segment>
      </unit>
      <unit id="837">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> to view contributors to the 1.3 seconds of waiting, as shown in Figure 34 Contributors to Wait Time:</source>
          <target>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> to view contributors to the 1.3 seconds of waiting, as shown in Figure 34 Contributors to Wait Time:</target>
        </segment>
      </unit>
      <unit id="838">
        <segment state="initial">
          <source>figure 34 contributors to wait time</source>
          <target>figure 34 contributors to wait time</target>
        </segment>
      </unit>
      <unit id="839">
        <segment state="initial">
          <source>Figure 34 Contributors to Wait Time</source>
          <target>Figure 34 Contributors to Wait Time</target>
        </segment>
      </unit>
      <unit id="840">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiRetireDpcList</pc> is typically I/O-related and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">KiTimerExpiration</pc> is a timer.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KiRetireDpcList</pc> is typically I/O-related and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">KiTimerExpiration</pc> is a timer.</target>
        </segment>
      </unit>
      <unit id="841">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You can view how the I/Os and timer were initiated by removing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and then viewing the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewThreadStack</pc>.</source>
          <target>You can view how the I/Os and timer were initiated by removing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadyThreadStack</pc> and then viewing the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewThreadStack</pc>.</target>
        </segment>
      </unit>
      <unit id="842">
        <segment state="initial">
          <source>This view shows three related functions, as shown in Figure 35 I/Os and Timer on NewThreadStack:</source>
          <target>This view shows three related functions, as shown in Figure 35 I/Os and Timer on NewThreadStack:</target>
        </segment>
      </unit>
      <unit id="843">
        <segment state="initial">
          <source>figure 35 ios and timer on newthreadstack</source>
          <target>figure 35 ios and timer on newthreadstack</target>
        </segment>
      </unit>
      <unit id="844">
        <segment state="initial">
          <source>Figure 35 I/Os and Timer on NewThreadStack</source>
          <target>Figure 35 I/Os and Timer on NewThreadStack</target>
        </segment>
      </unit>
      <unit id="845">
        <segment state="initial">
          <source>This view discloses the following details:</source>
          <target>This view discloses the following details:</target>
        </segment>
      </unit>
      <unit id="846">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) flushes a registry hive for 544 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) flushes a registry hive for 544 milliseconds.</target>
        </segment>
      </unit>
      <unit id="847">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe (3024) sleeps for 513 milliseconds.</source>
          <target>Thread 3872 of process TestBootStrapper.exe (3024) sleeps for 513 milliseconds.</target>
        </segment>
      </unit>
      <unit id="848">
        <segment state="initial">
          <source>Thread 3872 of process TestBootStrapper.exe writes 3.5MB to disk, thereby causing a 178 millisecond delay.</source>
          <target>Thread 3872 of process TestBootStrapper.exe writes 3.5MB to disk, thereby causing a 178 millisecond delay.</target>
        </segment>
      </unit>
      <unit id="849">
        <segment state="initial">
          <source>When you started to investigate the critical path, you analyzed the most significant wait cause in Explorer.exe and disregarded any parts of the critical path that occurred after that wait cause.</source>
          <target>When you started to investigate the critical path, you analyzed the most significant wait cause in Explorer.exe and disregarded any parts of the critical path that occurred after that wait cause.</target>
        </segment>
      </unit>
      <unit id="850">
        <segment state="initial">
          <source>To capture this previously disregarded section of the critical path, you must look at the timeline.</source>
          <target>To capture this previously disregarded section of the critical path, you must look at the timeline.</target>
        </segment>
      </unit>
      <unit id="851">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Add <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline by Process, Thread</pc> preset.</source>
          <target>Add <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline by Process, Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="852">
        <segment state="initial">
          <source>Filter to include only the processes identified as part of the critical path.</source>
          <target>Filter to include only the processes identified as part of the critical path.</target>
        </segment>
      </unit>
      <unit id="853">
        <segment state="initial">
          <source>The resulting graph is shown in Figure 36 Critical Path Timeline:</source>
          <target>The resulting graph is shown in Figure 36 Critical Path Timeline:</target>
        </segment>
      </unit>
      <unit id="854">
        <segment state="initial">
          <source>figure 36 critical path timeline</source>
          <target>figure 36 critical path timeline</target>
        </segment>
      </unit>
      <unit id="855">
        <segment state="initial">
          <source>Figure 36 Critical Path Timeline</source>
          <target>Figure 36 Critical Path Timeline</target>
        </segment>
      </unit>
      <unit id="856">
        <segment state="initial">
          <source>Figure 36 Critical Path Timeline shows that Explorer.exe performed more work after it stopped waiting for RunOnce.exe.</source>
          <target>Figure 36 Critical Path Timeline shows that Explorer.exe performed more work after it stopped waiting for RunOnce.exe.</target>
        </segment>
      </unit>
      <unit id="857">
        <segment state="initial">
          <source>Zoom to the time period after the previously-analyzed wait chain and perform another analysis.</source>
          <target>Zoom to the time period after the previously-analyzed wait chain and perform another analysis.</target>
        </segment>
      </unit>
      <unit id="858">
        <segment state="initial">
          <source>In this case, analysis reveals a large number of threads that are internal to Explorer.exe and no clear trace through the critical path.</source>
          <target>In this case, analysis reveals a large number of threads that are internal to Explorer.exe and no clear trace through the critical path.</target>
        </segment>
      </unit>
      <unit id="859">
        <segment state="initial">
          <source>In this case, further analysis is not likely to yield actionable insights.</source>
          <target>In this case, further analysis is not likely to yield actionable insights.</target>
        </segment>
      </unit>
      <unit id="860">
        <segment state="initial">
          <source>Direct CPU Usage</source>
          <target>Direct CPU Usage</target>
        </segment>
      </unit>
      <unit id="861">
        <segment state="initial">
          <source>Activities are often delayed because a thread on the critical path uses significant CPU time.</source>
          <target>Activities are often delayed because a thread on the critical path uses significant CPU time.</target>
        </segment>
      </unit>
      <unit id="862">
        <segment state="initial">
          <source>By using the thread state model, you can see that this problem is characterized by a thread on the critical path that spends an exceptional amount of time in the Running state.</source>
          <target>By using the thread state model, you can see that this problem is characterized by a thread on the critical path that spends an exceptional amount of time in the Running state.</target>
        </segment>
      </unit>
      <unit id="863">
        <segment state="initial">
          <source>On some hardware, this heavy CPU usage can contribute to delays.</source>
          <target>On some hardware, this heavy CPU usage can contribute to delays.</target>
        </segment>
      </unit>
      <unit id="864">
        <segment state="initial">
          <source>Problem Identification</source>
          <target>Problem Identification</target>
        </segment>
      </unit>
      <unit id="865">
        <segment state="initial">
          <source>Many assessments use heuristics to identify direct CPU usage-related problems.</source>
          <target>Many assessments use heuristics to identify direct CPU usage-related problems.</target>
        </segment>
      </unit>
      <unit id="866">
        <segment state="initial">
          <source>Significant CPU usage on the critical path is reported as an issue in the following form:</source>
          <target>Significant CPU usage on the critical path is reported as an issue in the following form:</target>
        </segment>
      </unit>
      <unit id="867">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>CPU use by process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> delays the impacted activity <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> seconds</source>
          <target>CPU use by process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> delays the impacted activity <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> seconds</target>
        </segment>
      </unit>
      <unit id="868">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is the process that is running, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> is the activity, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the time in seconds.</source>
          <target>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is the process that is running, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> is the activity, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the time in seconds.</target>
        </segment>
      </unit>
      <unit id="869">
        <segment state="initial">
          <source>If these issues are reported for an activity that incurs delays, direct CPU usage might be the cause.</source>
          <target>If these issues are reported for an activity that incurs delays, direct CPU usage might be the cause.</target>
        </segment>
      </unit>
      <unit id="870">
        <segment state="initial">
          <source>Investigate Direct CPU Usage</source>
          <target>Investigate Direct CPU Usage</target>
        </segment>
      </unit>
      <unit id="871">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can manually identify the problem by looking for individual CPUs that incur 100% CPU usage in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph.</source>
          <target>You can manually identify the problem by looking for individual CPUs that incur 100% CPU usage in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph.</target>
        </segment>
      </unit>
      <unit id="872">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Zoom to an area of interest in the graph and select the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process and Thread</pc> preset.</source>
          <target>Zoom to an area of interest in the graph and select the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process and Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="873">
        <segment state="initial">
          <source>By default, the table displays rows at the top that have the highest aggregate CPU usage.</source>
          <target>By default, the table displays rows at the top that have the highest aggregate CPU usage.</target>
        </segment>
      </unit>
      <unit id="874">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>These threads also display at the top of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph.</source>
          <target>These threads also display at the top of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph.</target>
        </segment>
      </unit>
      <unit id="875">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="876">
        <segment state="initial">
          <source>On a system that has multiple processors, a thread that uses 100% of a single processor will appear to be consuming 100/(number of logical processors).</source>
          <target>On a system that has multiple processors, a thread that uses 100% of a single processor will appear to be consuming 100/(number of logical processors).</target>
        </segment>
      </unit>
      <unit id="877">
        <segment state="initial">
          <source>On this kind of system, only the virtual idle thread (PID 0, TID 0) can show a greater processor utilization than 100/(number of logical processors).</source>
          <target>On this kind of system, only the virtual idle thread (PID 0, TID 0) can show a greater processor utilization than 100/(number of logical processors).</target>
        </segment>
      </unit>
      <unit id="878">
        <segment state="initial">
          <source>If the processes and threads that consume the most CPU correspond to any threads in the critical path, direct CPU usage is probably a factor.</source>
          <target>If the processes and threads that consume the most CPU correspond to any threads in the critical path, direct CPU usage is probably a factor.</target>
        </segment>
      </unit>
      <unit id="879">
        <segment state="initial">
          <source>Example of Assessment-Reported Direct CPU Usage issue</source>
          <target>Example of Assessment-Reported Direct CPU Usage issue</target>
        </segment>
      </unit>
      <unit id="880">
        <segment state="initial">
          <source>CPU use by the TestUM.exe process (4024) delays the impacted activity, Fast startup shutdown process TestIM.exe, for 2.1 seconds.</source>
          <target>CPU use by the TestUM.exe process (4024) delays the impacted activity, Fast startup shutdown process TestIM.exe, for 2.1 seconds.</target>
        </segment>
      </unit>
      <unit id="881">
        <segment state="initial">
          <source>This example is shown in Figure 37 Thread 3208:</source>
          <target>This example is shown in Figure 37 Thread 3208:</target>
        </segment>
      </unit>
      <unit id="882">
        <segment state="initial">
          <source>figure 37 thread 3208</source>
          <target>figure 37 thread 3208</target>
        </segment>
      </unit>
      <unit id="883">
        <segment state="initial">
          <source>Figure 37 Thread 3208</source>
          <target>Figure 37 Thread 3208</target>
        </segment>
      </unit>
      <unit id="884">
        <segment state="initial">
          <source>Investigation</source>
          <target>Investigation</target>
        </segment>
      </unit>
      <unit id="885">
        <segment state="initial">
          <source>After you discover that direct CPU usage contributes to a delay on the critical path, you must identify the specific modules and functions that contribute to the delay.</source>
          <target>After you discover that direct CPU usage contributes to a delay on the critical path, you must identify the specific modules and functions that contribute to the delay.</target>
        </segment>
      </unit>
      <unit id="886">
        <segment state="initial">
          <source>Technique: Review an Assessment-Reported Direct CPU Usage Issue</source>
          <target>Technique: Review an Assessment-Reported Direct CPU Usage Issue</target>
        </segment>
      </unit>
      <unit id="887">
        <segment state="initial">
          <source>You can expand an assessment-reported direct CPU usage issue to display the critical path that is impacted by the direct CPU usage.</source>
          <target>You can expand an assessment-reported direct CPU usage issue to display the critical path that is impacted by the direct CPU usage.</target>
        </segment>
      </unit>
      <unit id="888">
        <segment state="initial">
          <source>If you expand the node that is associated with the CPU usage, the stacks that are associated with the CPU usage and associated modules will display.</source>
          <target>If you expand the node that is associated with the CPU usage, the stacks that are associated with the CPU usage and associated modules will display.</target>
        </segment>
      </unit>
      <unit id="889">
        <segment state="initial">
          <source>This view is shown in Figure 38 Expanded CPU Usage Segment:</source>
          <target>This view is shown in Figure 38 Expanded CPU Usage Segment:</target>
        </segment>
      </unit>
      <unit id="890">
        <segment state="initial">
          <source>figure 38 expanded cpu usage segment</source>
          <target>figure 38 expanded cpu usage segment</target>
        </segment>
      </unit>
      <unit id="891">
        <segment state="initial">
          <source>Figure 38 Expanded CPU Usage Segment</source>
          <target>Figure 38 Expanded CPU Usage Segment</target>
        </segment>
      </unit>
      <unit id="892">
        <segment state="initial">
          <source>Technique: Manually Explore the Stacks of a Direct CPU Usage Issue</source>
          <target>Technique: Manually Explore the Stacks of a Direct CPU Usage Issue</target>
        </segment>
      </unit>
      <unit id="893">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If the assessment did not report an issue, or if you require additional verification, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph to manually collect information on the modules and functions that are involved in a CPU usage issue.</source>
          <target>If the assessment did not report an issue, or if you require additional verification, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph to manually collect information on the modules and functions that are involved in a CPU usage issue.</target>
        </segment>
      </unit>
      <unit id="894">
        <segment state="initial">
          <source>To do this, you must zoom to the area of interest and view the stacks that are sorted by CPU Usage.</source>
          <target>To do this, you must zoom to the area of interest and view the stacks that are sorted by CPU Usage.</target>
        </segment>
      </unit>
      <unit id="895">
        <segment state="initial">
          <source>Manually Explore the Stacks of a Direct CPU Usage Issue</source>
          <target>Manually Explore the Stacks of a Direct CPU Usage Issue</target>
        </segment>
      </unit>
      <unit id="896">
        <segment state="initial">
          <source>On the Trace menu, click Load Symbols.</source>
          <target>On the Trace menu, click Load Symbols.</target>
        </segment>
      </unit>
      <unit id="897">
        <segment state="initial">
          <source>Zoom the timeline to display only the portion of the critical path that is affected by the CPU issue.</source>
          <target>Zoom the timeline to display only the portion of the critical path that is affected by the CPU issue.</target>
        </segment>
      </unit>
      <unit id="898">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process and Thread</pc> preset.</source>
          <target>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process and Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="899">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stack</pc> column to the display, and then drag this column to the right of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thread ID</pc> (left of the bar).</source>
          <target>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stack</pc> column to the display, and then drag this column to the right of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thread ID</pc> (left of the bar).</target>
        </segment>
      </unit>
      <unit id="900">
        <segment state="initial">
          <source>Expand the process and thread to display the stack trees.</source>
          <target>Expand the process and thread to display the stack trees.</target>
        </segment>
      </unit>
      <unit id="901">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The rows in the stack are sorted in descending order by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">% Weight of CPU Usage</pc>.</source>
          <target>The rows in the stack are sorted in descending order by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">% Weight of CPU Usage</pc>.</target>
        </segment>
      </unit>
      <unit id="902">
        <segment state="initial">
          <source>This puts the most interesting stacks on top.</source>
          <target>This puts the most interesting stacks on top.</target>
        </segment>
      </unit>
      <unit id="903">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>As you expand the stacks, watch the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">% Weight</pc> column to make sure that your focus remains on the rows that have the highest usage.</source>
          <target>As you expand the stacks, watch the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">% Weight</pc> column to make sure that your focus remains on the rows that have the highest usage.</target>
        </segment>
      </unit>
      <unit id="904">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>To extract a copy of the stack, select all the rows, right-click, and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Copy Selection</pc>.</source>
          <target>To extract a copy of the stack, select all the rows, right-click, and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Copy Selection</pc>.</target>
        </segment>
      </unit>
      <unit id="905">
        <segment state="initial">
          <source>Resolution</source>
          <target>Resolution</target>
        </segment>
      </unit>
      <unit id="906">
        <segment state="initial">
          <source>You can apply remedies at both the configuration and component levels to resolve high CPU usage.</source>
          <target>You can apply remedies at both the configuration and component levels to resolve high CPU usage.</target>
        </segment>
      </unit>
      <unit id="907">
        <segment state="initial">
          <source>Direct CPU usage has higher impact on computers that have lower-end processors.</source>
          <target>Direct CPU usage has higher impact on computers that have lower-end processors.</target>
        </segment>
      </unit>
      <unit id="908">
        <segment state="initial">
          <source>In these cases, you can add more processing power to the computer.</source>
          <target>In these cases, you can add more processing power to the computer.</target>
        </segment>
      </unit>
      <unit id="909">
        <segment state="initial">
          <source>Or, you might be able to remove the problem modules from the critical path or from the system.</source>
          <target>Or, you might be able to remove the problem modules from the critical path or from the system.</target>
        </segment>
      </unit>
      <unit id="910">
        <segment state="initial">
          <source>If you can change the components, consider a redesign effort to achieve one of the following results:</source>
          <target>If you can change the components, consider a redesign effort to achieve one of the following results:</target>
        </segment>
      </unit>
      <unit id="911">
        <segment state="initial">
          <source>Remove the CPU-intensive code from the critical path</source>
          <target>Remove the CPU-intensive code from the critical path</target>
        </segment>
      </unit>
      <unit id="912">
        <segment state="initial">
          <source>Use more CPU-efficient algorithms</source>
          <target>Use more CPU-efficient algorithms</target>
        </segment>
      </unit>
      <unit id="913">
        <segment state="initial">
          <source>Defer or cache work</source>
          <target>Defer or cache work</target>
        </segment>
      </unit>
      <unit id="914">
        <segment state="initial">
          <source>Thread Interference</source>
          <target>Thread Interference</target>
        </segment>
      </unit>
      <unit id="915">
        <segment state="initial">
          <source>CPU usage by threads that are not on the critical path (and that might be unrelated to the activity), can cause threads that are on the critical path to be delayed.</source>
          <target>CPU usage by threads that are not on the critical path (and that might be unrelated to the activity), can cause threads that are on the critical path to be delayed.</target>
        </segment>
      </unit>
      <unit id="916">
        <segment state="initial">
          <source>The thread state model shows that this problem is characterized by threads on the critical path that spend an unusual amount of time in the Ready state.</source>
          <target>The thread state model shows that this problem is characterized by threads on the critical path that spend an unusual amount of time in the Ready state.</target>
        </segment>
      </unit>
      <unit id="917">
        <segment state="initial">
          <source>Problem Identification</source>
          <target>Problem Identification</target>
        </segment>
      </unit>
      <unit id="918">
        <segment state="initial">
          <source>Many assessments use heuristics to identify interference-related problems.</source>
          <target>Many assessments use heuristics to identify interference-related problems.</target>
        </segment>
      </unit>
      <unit id="919">
        <segment state="initial">
          <source>These are reported in one of the following two forms:</source>
          <target>These are reported in one of the following two forms:</target>
        </segment>
      </unit>
      <unit id="920">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is starved.</source>
          <target>Process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is starved.</target>
        </segment>
      </unit>
      <unit id="921">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The starvation causes a delay to the impacted activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">A</pc> of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x</pc> ms.</source>
          <target>The starvation causes a delay to the impacted activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">A</pc> of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x</pc> ms.</target>
        </segment>
      </unit>
      <unit id="922">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is preempted.</source>
          <target>Process <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is preempted.</target>
        </segment>
      </unit>
      <unit id="923">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The preemption causes a delay to the impacted activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">A</pc> of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x</pc> ms.</source>
          <target>The preemption causes a delay to the impacted activity <pc dataRefEnd="id2" dataRefStart="id1" id="p1">A</pc> of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x</pc> ms.</target>
        </segment>
      </unit>
      <unit id="924">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is the process, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> is the activity, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the time in ms.</source>
          <target>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">P</pc> is the process, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">A</pc> is the activity, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the time in ms.</target>
        </segment>
      </unit>
      <unit id="925">
        <segment state="initial">
          <source>The first form reflects interference from threads at the same priority level as the thread on the critical path.</source>
          <target>The first form reflects interference from threads at the same priority level as the thread on the critical path.</target>
        </segment>
      </unit>
      <unit id="926">
        <segment state="initial">
          <source>The second form reflects interference from threads that are at a higher priority level than the thread on the critical path.</source>
          <target>The second form reflects interference from threads that are at a higher priority level than the thread on the critical path.</target>
        </segment>
      </unit>
      <unit id="927">
        <segment state="initial">
          <source>If these types of issues are reported for a delayed activity, thread interference can be the cause.</source>
          <target>If these types of issues are reported for a delayed activity, thread interference can be the cause.</target>
        </segment>
      </unit>
      <unit id="928">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph to manually identify the problem.</source>
          <target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph to manually identify the problem.</target>
        </segment>
      </unit>
      <unit id="929">
        <segment state="initial">
          <source>Identify Thread Interference Issues</source>
          <target>Identify Thread Interference Issues</target>
        </segment>
      </unit>
      <unit id="930">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Zoom to the interval and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by CPU</pc> preset.</source>
          <target>Zoom to the interval and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by CPU</pc> preset.</target>
        </segment>
      </unit>
      <unit id="931">
        <segment state="initial">
          <source>A utilization of 100% across all CPUs indicates an interference issue.</source>
          <target>A utilization of 100% across all CPUs indicates an interference issue.</target>
        </segment>
      </unit>
      <unit id="932">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset and sort by the first <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us)</pc> column.</source>
          <target>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset and sort by the first <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Ready (us)</pc> column.</target>
        </segment>
      </unit>
      <unit id="933">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>(This is the column that includes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sum</pc> aggregation.)</source>
          <target>(This is the column that includes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sum</pc> aggregation.)</target>
        </segment>
      </unit>
      <unit id="934">
        <segment state="initial">
          <source>Expand the process of the activity that is affected and look at the Ready time for threads on the critical path.</source>
          <target>Expand the process of the activity that is affected and look at the Ready time for threads on the critical path.</target>
        </segment>
      </unit>
      <unit id="935">
        <segment state="initial">
          <source>This value is the maximum time that the delay can be reduced by resolving any thread Interference issue.</source>
          <target>This value is the maximum time that the delay can be reduced by resolving any thread Interference issue.</target>
        </segment>
      </unit>
      <unit id="936">
        <segment state="initial">
          <source>A value with a magnitude significant relative to the delay being investigated indicates that a thread interference problem exists.</source>
          <target>A value with a magnitude significant relative to the delay being investigated indicates that a thread interference problem exists.</target>
        </segment>
      </unit>
      <unit id="937">
        <segment state="initial">
          <source>Figure 39 CPU Utilization is Near 100% and Figure 40 Thread Interference Problem represent this scenario:</source>
          <target>Figure 39 CPU Utilization is Near 100% and Figure 40 Thread Interference Problem represent this scenario:</target>
        </segment>
      </unit>
      <unit id="938">
        <segment state="initial">
          <source>figure 39 cpu utilization is near 100%</source>
          <target>figure 39 cpu utilization is near 100%</target>
        </segment>
      </unit>
      <unit id="939">
        <segment state="initial">
          <source>Figure 39 CPU Utilization is Near 100%</source>
          <target>Figure 39 CPU Utilization is Near 100%</target>
        </segment>
      </unit>
      <unit id="940">
        <segment state="initial">
          <source>figure 40 thread interference problem</source>
          <target>figure 40 thread interference problem</target>
        </segment>
      </unit>
      <unit id="941">
        <segment state="initial">
          <source>Figure 40 Thread Interference Problem</source>
          <target>Figure 40 Thread Interference Problem</target>
        </segment>
      </unit>
      <unit id="942">
        <segment state="initial">
          <source>Investigation</source>
          <target>Investigation</target>
        </segment>
      </unit>
      <unit id="943">
        <segment state="initial">
          <source>After the issue is identified, you must determine why the affected thread spent so much time in the Ready state.</source>
          <target>After the issue is identified, you must determine why the affected thread spent so much time in the Ready state.</target>
        </segment>
      </unit>
      <unit id="944">
        <segment state="initial">
          <source>Technique: Determine Why a Thread Spent Time in the Ready State</source>
          <target>Technique: Determine Why a Thread Spent Time in the Ready State</target>
        </segment>
      </unit>
      <unit id="945">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph to determine why a thread spent time in the Ready state.</source>
          <target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph to determine why a thread spent time in the Ready state.</target>
        </segment>
      </unit>
      <unit id="946">
        <segment state="initial">
          <source>You must first determine whether the thread is restricted to certain processors.</source>
          <target>You must first determine whether the thread is restricted to certain processors.</target>
        </segment>
      </unit>
      <unit id="947">
        <segment state="initial">
          <source>Although you cannot directly obtain this information, you can examine the CPU usage history of a thread during periods of high CPU utilization.</source>
          <target>Although you cannot directly obtain this information, you can examine the CPU usage history of a thread during periods of high CPU utilization.</target>
        </segment>
      </unit>
      <unit id="948">
        <segment state="initial">
          <source>This is the period when threads tend to frequently switch between processors.</source>
          <target>This is the period when threads tend to frequently switch between processors.</target>
        </segment>
      </unit>
      <unit id="949">
        <segment state="initial">
          <source>Determine a Thread’s Processor Restrictions</source>
          <target>Determine a Thread’s Processor Restrictions</target>
        </segment>
      </unit>
      <unit id="950">
        <segment state="initial">
          <source>Zoom to the affected region.</source>
          <target>Zoom to the affected region.</target>
        </segment>
      </unit>
      <unit id="951">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by Process, Thread</pc> preset.</source>
          <target>Add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by Process, Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="952">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Advanced</pc> dialog to add a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Cpu</pc> column that has a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Unique Count</pc> aggregation mode to the right of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewThreadId</pc>.</source>
          <target>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Advanced</pc> dialog to add a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Cpu</pc> column that has a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Unique Count</pc> aggregation mode to the right of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewThreadId</pc>.</target>
        </segment>
      </unit>
      <unit id="953">
        <segment state="initial">
          <source>Filter the graph to show only the threads in which you are interested.</source>
          <target>Filter the graph to show only the threads in which you are interested.</target>
        </segment>
      </unit>
      <unit id="954">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The value in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cpu</pc> column reflects the number of processors on which the thread ran during the current time interval.</source>
          <target>The value in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cpu</pc> column reflects the number of processors on which the thread ran during the current time interval.</target>
        </segment>
      </unit>
      <unit id="955">
        <segment state="initial">
          <source>During periods of 100% CPU utilization, this number approximates the number of processors on which this thread is allowed to run.</source>
          <target>During periods of 100% CPU utilization, this number approximates the number of processors on which this thread is allowed to run.</target>
        </segment>
      </unit>
      <unit id="956">
        <segment state="initial">
          <source>If the value is less than the number of available processors, the thread is probably restricted to certain CPUs.</source>
          <target>If the value is less than the number of available processors, the thread is probably restricted to certain CPUs.</target>
        </segment>
      </unit>
      <unit id="957">
        <segment state="initial">
          <source>Figure 41 Restricted Threads provides an example of this graph:</source>
          <target>Figure 41 Restricted Threads provides an example of this graph:</target>
        </segment>
      </unit>
      <unit id="958">
        <segment state="initial">
          <source>figure 41 restricted threads</source>
          <target>figure 41 restricted threads</target>
        </segment>
      </unit>
      <unit id="959">
        <segment state="initial">
          <source>Figure 41 Restricted Threads</source>
          <target>Figure 41 Restricted Threads</target>
        </segment>
      </unit>
      <unit id="960">
        <segment state="initial">
          <source>After you know a thread’s processor restrictions, you can determine what preempted or starved the thread.</source>
          <target>After you know a thread’s processor restrictions, you can determine what preempted or starved the thread.</target>
        </segment>
      </unit>
      <unit id="961">
        <segment state="initial">
          <source>To do this, you must identify the intervals that the thread spent in the Ready state and then examine what other threads or processes were running during those intervals.</source>
          <target>To do this, you must identify the intervals that the thread spent in the Ready state and then examine what other threads or processes were running during those intervals.</target>
        </segment>
      </unit>
      <unit id="962">
        <segment state="initial">
          <source>Determine what Preempted or Starved the Thread</source>
          <target>Determine what Preempted or Starved the Thread</target>
        </segment>
      </unit>
      <unit id="963">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Construct a graph that shows when the thread was in the Ready state and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset.</source>
          <target>Construct a graph that shows when the thread was in the Ready state and apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Utilization by Process, Thread</pc> preset.</target>
        </segment>
      </unit>
      <unit id="964">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc>, and select the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Graph Configuration</pc> tab.</source>
          <target>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc>, and select the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Graph Configuration</pc> tab.</target>
        </segment>
      </unit>
      <unit id="965">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>Set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start Time</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyTime (s)</pc> and set the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Duration</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Ready (us)</pc>, as shown in Figure 42 Ready Time Columns.</source>
          <target>Set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start Time</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ReadyTime (s)</pc> and set the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Duration</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Ready (us)</pc>, as shown in Figure 42 Ready Time Columns.</target>
        </segment>
      </unit>
      <unit id="966">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OK</pc>.</source>
          <target>Click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OK</pc>.</target>
        </segment>
      </unit>
      <unit id="967">
        <segment state="initial">
          <source>figure 42 ready time columns</source>
          <target>figure 42 ready time columns</target>
        </segment>
      </unit>
      <unit id="968">
        <segment state="initial">
          <source>Figure 42 Ready Time Columns</source>
          <target>Figure 42 Ready Time Columns</target>
        </segment>
      </unit>
      <unit id="969">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">\[</data>
          <data id="id8">\]</data>
        </originalData>
        <segment state="initial">
          <source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, replace the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (%)</pc> column with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Ready (us) <ph dataRef="id7" id="ph1" />Sum<ph dataRef="id8" id="ph2" /></pc> column.</source>
          <target>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, replace the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (%)</pc> column with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Ready (us) <ph dataRef="id7" id="ph1" />Sum<ph dataRef="id8" id="ph2" /></pc> column.</target>
        </segment>
      </unit>
      <unit id="970">
        <segment state="initial">
          <source>Select the thread of interest to produce a graph that is similar to Figure 43 Ready Time Graph:</source>
          <target>Select the thread of interest to produce a graph that is similar to Figure 43 Ready Time Graph:</target>
        </segment>
      </unit>
      <unit id="971">
        <segment state="initial">
          <source>figure 43 ready time graph</source>
          <target>figure 43 ready time graph</target>
        </segment>
      </unit>
      <unit id="972">
        <segment state="initial">
          <source>Figure 43 Ready Time Graph</source>
          <target>Figure 43 Ready Time Graph</target>
        </segment>
      </unit>
      <unit id="973">
        <segment state="initial">
          <source>In this case, the thread spent significant time in the Ready state.</source>
          <target>In this case, the thread spent significant time in the Ready state.</target>
        </segment>
      </unit>
      <unit id="974">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To determine its typical priority, add an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Average</pc> aggregation to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> column.</source>
          <target>To determine its typical priority, add an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Average</pc> aggregation to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> column.</target>
        </segment>
      </unit>
      <unit id="975">
        <segment state="initial">
          <source>In this case, the thread’s average priority is exactly 8.</source>
          <target>In this case, the thread’s average priority is exactly 8.</target>
        </segment>
      </unit>
      <unit id="976">
        <segment state="initial">
          <source>This number indicates that it is probably a background thread that never receives priority elevations.</source>
          <target>This number indicates that it is probably a background thread that never receives priority elevations.</target>
        </segment>
      </unit>
      <unit id="977">
        <segment state="initial">
          <source>After the average priority is known, look at the CPU activity for the CPUs on which the thread is allowed to run.</source>
          <target>After the average priority is known, look at the CPU activity for the CPUs on which the thread is allowed to run.</target>
        </segment>
      </unit>
      <unit id="978">
        <segment state="initial">
          <source>In this case, the thread was determined to have affinity for CPU 1 only.</source>
          <target>In this case, the thread was determined to have affinity for CPU 1 only.</target>
        </segment>
      </unit>
      <unit id="979">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Add another <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by CPU</pc> preset.</source>
          <target>Add another <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Precise)</pc> graph and apply the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by CPU</pc> preset.</target>
        </segment>
      </unit>
      <unit id="980">
        <segment state="initial">
          <source>Select the relevant CPUs.</source>
          <target>Select the relevant CPUs.</target>
        </segment>
      </unit>
      <unit id="981">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Advanced</pc> view and add a filter for the priority that you found earlier to filter out that thread.</source>
          <target>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Advanced</pc> view and add a filter for the priority that you found earlier to filter out that thread.</target>
        </segment>
      </unit>
      <unit id="982">
        <segment state="initial">
          <source>This scenario is shown in Figure 44 Thread Filter:</source>
          <target>This scenario is shown in Figure 44 Thread Filter:</target>
        </segment>
      </unit>
      <unit id="983">
        <segment state="initial">
          <source>figure 44 thread filter</source>
          <target>figure 44 thread filter</target>
        </segment>
      </unit>
      <unit id="984">
        <segment state="initial">
          <source>Figure 44 Thread Filter</source>
          <target>Figure 44 Thread Filter</target>
        </segment>
      </unit>
      <unit id="985">
        <segment state="initial">
          <source>In Figure 45 CPU Usage, Ready Time, and Other Thread Activity, the top graph shows the CPU usage of thread 3548.</source>
          <target>In Figure 45 CPU Usage, Ready Time, and Other Thread Activity, the top graph shows the CPU usage of thread 3548.</target>
        </segment>
      </unit>
      <unit id="986">
        <segment state="initial">
          <source>The middle graph shows the time that the thread was ready, and the bottom graph shows activity on the CPUs on which the thread was allowed to run (in this case, Cpu1).</source>
          <target>The middle graph shows the time that the thread was ready, and the bottom graph shows activity on the CPUs on which the thread was allowed to run (in this case, Cpu1).</target>
        </segment>
      </unit>
      <unit id="987">
        <segment state="initial">
          <source>figure 45 cpu usage ready time and other thread ac</source>
          <target>figure 45 cpu usage ready time and other thread ac</target>
        </segment>
      </unit>
      <unit id="988">
        <segment state="initial">
          <source>Figure 45 CPU Usage, Ready Time, and Other Thread Activity</source>
          <target>Figure 45 CPU Usage, Ready Time, and Other Thread Activity</target>
        </segment>
      </unit>
      <unit id="989">
        <segment state="initial">
          <source>Zoom into a region where the thread was ready, but did not run, for most of the time during that interval.</source>
          <target>Zoom into a region where the thread was ready, but did not run, for most of the time during that interval.</target>
        </segment>
      </unit>
      <unit id="990">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> graph, add <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> to the left of the bar and examine the results.</source>
          <target>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage</pc> graph, add <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> to the left of the bar and examine the results.</target>
        </segment>
      </unit>
      <unit id="991">
        <segment state="initial">
          <source>Threads or processes that have priorities that are equal to the target thread priority show time that the thread was starved.</source>
          <target>Threads or processes that have priorities that are equal to the target thread priority show time that the thread was starved.</target>
        </segment>
      </unit>
      <unit id="992">
        <segment state="initial">
          <source>Threads or processes that have higher priority than the target thread priority show time that the thread was preempted.</source>
          <target>Threads or processes that have higher priority than the target thread priority show time that the thread was preempted.</target>
        </segment>
      </unit>
      <unit id="993">
        <segment state="initial">
          <source>You can calculate the total time that the thread was preempted by adding the times of all preemptive threads and actions.</source>
          <target>You can calculate the total time that the thread was preempted by adding the times of all preemptive threads and actions.</target>
        </segment>
      </unit>
      <unit id="994">
        <segment state="initial">
          <source>Figure 46 Usage by Priority When Target Thread was Ready shows that 730ms of the thread time were preempted, and 300ms of the thread time were starved.</source>
          <target>Figure 46 Usage by Priority When Target Thread was Ready shows that 730ms of the thread time were preempted, and 300ms of the thread time were starved.</target>
        </segment>
      </unit>
      <unit id="995">
        <segment state="initial">
          <source>(This figure is zoomed to a 1192ms interval.)</source>
          <target>(This figure is zoomed to a 1192ms interval.)</target>
        </segment>
      </unit>
      <unit id="996">
        <segment state="initial">
          <source>figure 46 usage by priority when target thread was</source>
          <target>figure 46 usage by priority when target thread was</target>
        </segment>
      </unit>
      <unit id="997">
        <segment state="initial">
          <source>Figure 46 Usage by Priority When Target Thread was Ready</source>
          <target>Figure 46 Usage by Priority When Target Thread was Ready</target>
        </segment>
      </unit>
      <unit id="998">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To determine which threads are responsible for the preemption and starvation of this thread, add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewProcess</pc> column to the right of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> column and review the priority levels at which processes were running.</source>
          <target>To determine which threads are responsible for the preemption and starvation of this thread, add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewProcess</pc> column to the right of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewInPri</pc> column and review the priority levels at which processes were running.</target>
        </segment>
      </unit>
      <unit id="999">
        <segment state="initial">
          <source>In this case, the preemption and starvation were primarily caused by another thread in the same process and by TestResidentApp.exe.</source>
          <target>In this case, the preemption and starvation were primarily caused by another thread in the same process and by TestResidentApp.exe.</target>
        </segment>
      </unit>
      <unit id="1000">
        <segment state="initial">
          <source>You can assume that these processes receive periodic priority elevations above their base priority.</source>
          <target>You can assume that these processes receive periodic priority elevations above their base priority.</target>
        </segment>
      </unit>
      <unit id="1001">
        <segment state="initial">
          <source>Resolution</source>
          <target>Resolution</target>
        </segment>
      </unit>
      <unit id="1002">
        <segment state="initial">
          <source>You can resolve preemption or starvation issues by changing the configuration or components.</source>
          <target>You can resolve preemption or starvation issues by changing the configuration or components.</target>
        </segment>
      </unit>
      <unit id="1003">
        <segment state="initial">
          <source>Consider the following remedies:</source>
          <target>Consider the following remedies:</target>
        </segment>
      </unit>
      <unit id="1004">
        <segment state="initial">
          <source>Remove the problematic processes from the system.</source>
          <target>Remove the problematic processes from the system.</target>
        </segment>
      </unit>
      <unit id="1005">
        <segment state="initial">
          <source>Adjust the base priority of the problematic processes…</source>
          <target>Adjust the base priority of the problematic processes…</target>
        </segment>
      </unit>
      <unit id="1006">
        <segment state="initial">
          <source>Change the time when the problematic processes run; for example, delay their start time to occur when the computer reboots.</source>
          <target>Change the time when the problematic processes run; for example, delay their start time to occur when the computer reboots.</target>
        </segment>
      </unit>
      <unit id="1007">
        <segment state="initial">
          <source>If the problem components can be changed, redesign them to be less CPU-intensive or to run at a lower priority.</source>
          <target>If the problem components can be changed, redesign them to be less CPU-intensive or to run at a lower priority.</target>
        </segment>
      </unit>
      <unit id="1008">
        <segment state="initial">
          <source>DPC/ISR Interference</source>
          <target>DPC/ISR Interference</target>
        </segment>
      </unit>
      <unit id="1009">
        <segment state="initial">
          <source>When excessive processor time is consumed by running DPCs and ISRs, there might not be enough available CPU time left to run threads.</source>
          <target>When excessive processor time is consumed by running DPCs and ISRs, there might not be enough available CPU time left to run threads.</target>
        </segment>
      </unit>
      <unit id="1010">
        <segment state="initial">
          <source>This situation can cause similar delays to thread interference.</source>
          <target>This situation can cause similar delays to thread interference.</target>
        </segment>
      </unit>
      <unit id="1011">
        <segment state="initial">
          <source>When threads must complete operations at a regular high-frequency rate, such as in video playback or animation, interference by DPCs and ISRs can cause operational problems.</source>
          <target>When threads must complete operations at a regular high-frequency rate, such as in video playback or animation, interference by DPCs and ISRs can cause operational problems.</target>
        </segment>
      </unit>
      <unit id="1012">
        <segment state="initial">
          <source>Problem Identification</source>
          <target>Problem Identification</target>
        </segment>
      </unit>
      <unit id="1013">
        <segment state="initial">
          <source>Many assessments use heuristics to identify DPC/ISR-related problems.</source>
          <target>Many assessments use heuristics to identify DPC/ISR-related problems.</target>
        </segment>
      </unit>
      <unit id="1014">
        <segment state="initial">
          <source>DPC/ISR activity is identified as suspicious when it is reported as an issue in the following form:</source>
          <target>DPC/ISR activity is identified as suspicious when it is reported as an issue in the following form:</target>
        </segment>
      </unit>
      <unit id="1015">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
          <data id="id7">*</data>
          <data id="id8">*</data>
          <data id="id9">*</data>
          <data id="id10">*</data>
          <data id="id11">*</data>
          <data id="id12">*</data>
        </originalData>
        <segment state="initial">
          <source>DPC <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D</pc> exceeds the threshold of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m</pc> milliseconds <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> times during <pc dataRefEnd="id8" dataRefStart="id7" id="p4">P</pc>. The <pc dataRefEnd="id10" dataRefStart="id9" id="p5">n</pc> instances of this DPC run for a combined total of <pc dataRefEnd="id12" dataRefStart="id11" id="p6">t</pc> milliseconds.</source>
          <target>DPC <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D</pc> exceeds the threshold of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m</pc> milliseconds <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> times during <pc dataRefEnd="id8" dataRefStart="id7" id="p4">P</pc>. The <pc dataRefEnd="id10" dataRefStart="id9" id="p5">n</pc> instances of this DPC run for a combined total of <pc dataRefEnd="id12" dataRefStart="id11" id="p6">t</pc> milliseconds.</target>
        </segment>
      </unit>
      <unit id="1016">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
          <data id="id7">*</data>
          <data id="id8">*</data>
          <data id="id9">*</data>
          <data id="id10">*</data>
          <data id="id11">*</data>
          <data id="id12">*</data>
        </originalData>
        <segment state="initial">
          <source>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D</pc> is the DPC, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m</pc> is the number of milliseconds that sets the threshold, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the number of times that the DPC exceeded the threshold, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">P</pc> is the current process, <pc dataRefEnd="id10" dataRefStart="id9" id="p5">n</pc> is the number of instances that the DPC ran, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6">t</pc> is the total time in milliseconds that the DPC ran over the threshold.</source>
          <target>Where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D</pc> is the DPC, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m</pc> is the number of milliseconds that sets the threshold, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x</pc> is the number of times that the DPC exceeded the threshold, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">P</pc> is the current process, <pc dataRefEnd="id10" dataRefStart="id9" id="p5">n</pc> is the number of instances that the DPC ran, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6">t</pc> is the total time in milliseconds that the DPC ran over the threshold.</target>
        </segment>
      </unit>
      <unit id="1017">
        <segment state="initial">
          <source>For example, the following issue is reported by an assessment:</source>
          <target>For example, the following issue is reported by an assessment:</target>
        </segment>
      </unit>
      <unit id="1018">
        <segment state="initial">
          <source>DPC sdbus.sys!SdbusWorkerDpc exceeds the goal of 3.0 milliseconds 153 times during Media Engine Lifetime.</source>
          <target>DPC sdbus.sys!SdbusWorkerDpc exceeds the goal of 3.0 milliseconds 153 times during Media Engine Lifetime.</target>
        </segment>
      </unit>
      <unit id="1019">
        <segment state="initial">
          <source>The 153 instances of this DPC run for a combined total of 864 milliseconds</source>
          <target>The 153 instances of this DPC run for a combined total of 864 milliseconds</target>
        </segment>
      </unit>
      <unit id="1020">
        <segment state="initial">
          <source>If this issue is reported for an activity that exhibits problem events or delays, DPC/ISR activity might be the cause.</source>
          <target>If this issue is reported for an activity that exhibits problem events or delays, DPC/ISR activity might be the cause.</target>
        </segment>
      </unit>
      <unit id="1021">
        <segment state="initial">
          <source>Manually Identify DPC/ISR Interference</source>
          <target>Manually Identify DPC/ISR Interference</target>
        </segment>
      </unit>
      <unit id="1022">
        <segment state="initial">
          <source>To manually identify DPC/ISR interference, open a trace in WPA and identify the problem events of interest.</source>
          <target>To manually identify DPC/ISR interference, open a trace in WPA and identify the problem events of interest.</target>
        </segment>
      </unit>
      <unit id="1023">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source>These are assessment-specific generic events such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft-Windows-Dwm-Core:SCHEDULE<ph dataRef="id3" id="ph1" />GLITCH</pc> or <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Microsoft-Windows-MediaEngine:DroppedFrame</pc>.</source>
          <target>These are assessment-specific generic events such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft-Windows-Dwm-Core:SCHEDULE<ph dataRef="id3" id="ph1" />GLITCH</pc> or <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Microsoft-Windows-MediaEngine:DroppedFrame</pc>.</target>
        </segment>
      </unit>
      <unit id="1024">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Next to the graph of events, add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> graph.</source>
          <target>Next to the graph of events, add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> graph.</target>
        </segment>
      </unit>
      <unit id="1025">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If peaks in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> graph line up with the problem events, DPC/ISRs might be a factor in causing the problems.</source>
          <target>If peaks in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> graph line up with the problem events, DPC/ISRs might be a factor in causing the problems.</target>
        </segment>
      </unit>
      <unit id="1026">
        <segment state="initial">
          <source>For additional data, zoom into the time period that occurs 100ms before several problem events display.</source>
          <target>For additional data, zoom into the time period that occurs 100ms before several problem events display.</target>
        </segment>
      </unit>
      <unit id="1027">
        <segment state="initial">
          <source>If significant DPC/ISR activity displays on one or more processors in the 100ms region before the problem events occurred, you can conclude that the problem events were caused by the DPC/IRS activity.</source>
          <target>If significant DPC/ISR activity displays on one or more processors in the 100ms region before the problem events occurred, you can conclude that the problem events were caused by the DPC/IRS activity.</target>
        </segment>
      </unit>
      <unit id="1028">
        <segment state="initial">
          <source>To determine whether DPC/ISR interference is causing delays, zoom to a region that shows a running thread.</source>
          <target>To determine whether DPC/ISR interference is causing delays, zoom to a region that shows a running thread.</target>
        </segment>
      </unit>
      <unit id="1029">
        <segment state="initial">
          <source>Make a note of the CPU or CPUs on which this thread is running.</source>
          <target>Make a note of the CPU or CPUs on which this thread is running.</target>
        </segment>
      </unit>
      <unit id="1030">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>In the DPC/ISR graph, apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> preset and view the DPC/ISR activity on the relevant CPUs in that time range.</source>
          <target>In the DPC/ISR graph, apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by CPU</pc> preset and view the DPC/ISR activity on the relevant CPUs in that time range.</target>
        </segment>
      </unit>
      <unit id="1031">
        <segment state="initial">
          <source>Figure 47 Problem Events and DPC/ISR Activity shows that thread 864 of iexplore.exe is relevant to the affected activity.</source>
          <target>Figure 47 Problem Events and DPC/ISR Activity shows that thread 864 of iexplore.exe is relevant to the affected activity.</target>
        </segment>
      </unit>
      <unit id="1032">
        <segment state="initial">
          <source>Thread 864 is in the Running state on CPU2 for 10.65% of the time range in view.</source>
          <target>Thread 864 is in the Running state on CPU2 for 10.65% of the time range in view.</target>
        </segment>
      </unit>
      <unit id="1033">
        <segment state="initial">
          <source>However, the DPC/ISR graph shows that CPU2 was busy executing DPC/ISRs for 10% of that time.</source>
          <target>However, the DPC/ISR graph shows that CPU2 was busy executing DPC/ISRs for 10% of that time.</target>
        </segment>
      </unit>
      <unit id="1034">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="1035">
        <segment state="initial">
          <source>Most DPC/ISRs do not have as high an impact as that shown in this example.</source>
          <target>Most DPC/ISRs do not have as high an impact as that shown in this example.</target>
        </segment>
      </unit>
      <unit id="1036">
        <segment state="initial">
          <source>figure 47 problem events and dpc isr activity</source>
          <target>figure 47 problem events and dpc isr activity</target>
        </segment>
      </unit>
      <unit id="1037">
        <segment state="initial">
          <source>Figure 47 Problem Events and DPC/ISR Activity</source>
          <target>Figure 47 Problem Events and DPC/ISR Activity</target>
        </segment>
      </unit>
      <unit id="1038">
        <segment state="initial">
          <source>In Figure 48 DPC/ISR Unrelated to Problem Events, DPC/ISRs are shown to not be related to performance problems:</source>
          <target>In Figure 48 DPC/ISR Unrelated to Problem Events, DPC/ISRs are shown to not be related to performance problems:</target>
        </segment>
      </unit>
      <unit id="1039">
        <segment state="initial">
          <source>figure 48 dpc isr unrelated to problem events</source>
          <target>figure 48 dpc isr unrelated to problem events</target>
        </segment>
      </unit>
      <unit id="1040">
        <segment state="initial">
          <source>Figure 48 DPC/ISR Unrelated to Problem Events</source>
          <target>Figure 48 DPC/ISR Unrelated to Problem Events</target>
        </segment>
      </unit>
      <unit id="1041">
        <segment state="initial">
          <source>In Figure 49 Delay caused by DPC/ISR Interference, DPC/ISRs are shown to cause performance problems:</source>
          <target>In Figure 49 Delay caused by DPC/ISR Interference, DPC/ISRs are shown to cause performance problems:</target>
        </segment>
      </unit>
      <unit id="1042">
        <segment state="initial">
          <source>figure 49 delay caused by dpc isr interference</source>
          <target>figure 49 delay caused by dpc isr interference</target>
        </segment>
      </unit>
      <unit id="1043">
        <segment state="initial">
          <source>Figure 49 Delay caused by DPC/ISR Interference</source>
          <target>Figure 49 Delay caused by DPC/ISR Interference</target>
        </segment>
      </unit>
      <unit id="1044">
        <segment state="initial">
          <source>Investigation</source>
          <target>Investigation</target>
        </segment>
      </unit>
      <unit id="1045">
        <segment state="initial">
          <source>After you determine that DPCs/ISRs are related to problems or delays, you must determine which specific DPCs/ISRs are involved and why they occur frequently or of run for an excessive length of time.</source>
          <target>After you determine that DPCs/ISRs are related to problems or delays, you must determine which specific DPCs/ISRs are involved and why they occur frequently or of run for an excessive length of time.</target>
        </segment>
      </unit>
      <unit id="1046">
        <segment state="initial">
          <source>Technique: Review an Assessment-Reported DPC/ISR Issue</source>
          <target>Technique: Review an Assessment-Reported DPC/ISR Issue</target>
        </segment>
      </unit>
      <unit id="1047">
        <segment state="initial">
          <source>In assessment-reported DPC/ISR issues, you can expand the issue that displays the major processes that are preempted by the DPC or ISR.</source>
          <target>In assessment-reported DPC/ISR issues, you can expand the issue that displays the major processes that are preempted by the DPC or ISR.</target>
        </segment>
      </unit>
      <unit id="1048">
        <segment state="initial">
          <source>Expand the stack to view the DPC activity for the process that is most related to the impacted activity, as shown in, expand the stack to understand what the DPC was doing.</source>
          <target>Expand the stack to view the DPC activity for the process that is most related to the impacted activity, as shown in, expand the stack to understand what the DPC was doing.</target>
        </segment>
      </unit>
      <unit id="1049">
        <segment state="initial">
          <source>Figure 50 Expanded DPC Stack shows the expanded stack:</source>
          <target>Figure 50 Expanded DPC Stack shows the expanded stack:</target>
        </segment>
      </unit>
      <unit id="1050">
        <segment state="initial">
          <source>figure 50 expanded dpc stack</source>
          <target>figure 50 expanded dpc stack</target>
        </segment>
      </unit>
      <unit id="1051">
        <segment state="initial">
          <source>Figure 50 Expanded DPC Stack</source>
          <target>Figure 50 Expanded DPC Stack</target>
        </segment>
      </unit>
      <unit id="1052">
        <segment state="initial">
          <source>Technique: Find the Highest Duration DPCs/ISRs and Review the Stacks</source>
          <target>Technique: Find the Highest Duration DPCs/ISRs and Review the Stacks</target>
        </segment>
      </unit>
      <unit id="1053">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If an assessment does not report the DPC/ISR to be an issue, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (Sampled)</pc> graphs to get stack information for the most relevant DPCs.</source>
          <target>If an assessment does not report the DPC/ISR to be an issue, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CPU Usage (Sampled)</pc> graphs to get stack information for the most relevant DPCs.</target>
        </segment>
      </unit>
      <unit id="1054">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>We recommend that you find a DPC/ISR of interest, note its module and function, and then find the samples in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph to get complete stack information.</source>
          <target>We recommend that you find a DPC/ISR of interest, note its module and function, and then find the samples in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph to get complete stack information.</target>
        </segment>
      </unit>
      <unit id="1055">
        <segment state="initial">
          <source>Find the Highest Duration DPCs/ISRs and Review the Stacks</source>
          <target>Find the Highest Duration DPCs/ISRs and Review the Stacks</target>
        </segment>
      </unit>
      <unit id="1056">
        <segment state="initial">
          <source>Zoom to the interval of interest.</source>
          <target>Zoom to the interval of interest.</target>
        </segment>
      </unit>
      <unit id="1057">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>In the DPC/ISR graph, select the preset <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by Module, Function</pc>.</source>
          <target>In the DPC/ISR graph, select the preset <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DPC/ISR Duration by Module, Function</pc>.</target>
        </segment>
      </unit>
      <unit id="1058">
        <segment state="initial">
          <source>If symbols are loaded, DPC/ISR events are sorted by total duration and are then broken down by Module and Function.</source>
          <target>If symbols are loaded, DPC/ISR events are sorted by total duration and are then broken down by Module and Function.</target>
        </segment>
      </unit>
      <unit id="1059">
        <segment state="initial">
          <source>The top rows in the list contain the DPC/ISR events that probably caused the event problems.</source>
          <target>The top rows in the list contain the DPC/ISR events that probably caused the event problems.</target>
        </segment>
      </unit>
      <unit id="1060">
        <segment state="initial">
          <source>Make a note of the module and function names.</source>
          <target>Make a note of the module and function names.</target>
        </segment>
      </unit>
      <unit id="1061">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph, select the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by Process</pc> preset.</source>
          <target>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CPU Usage (Sampled)</pc> graph, select the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Utilization by Process</pc> preset.</target>
        </segment>
      </unit>
      <unit id="1062">
        <segment state="initial">
          <source>By default, this preset hides DPC/ISR activity.</source>
          <target>By default, this preset hides DPC/ISR activity.</target>
        </segment>
      </unit>
      <unit id="1063">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, and click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc>.</source>
          <target>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, and click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc>.</target>
        </segment>
      </unit>
      <unit id="1064">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>On the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> tab, change the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Hide rows that match the filter</pc> setting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Keep rows that match the filter</pc>.</source>
          <target>On the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> tab, change the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Hide rows that match the filter</pc> setting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Keep rows that match the filter</pc>.</target>
        </segment>
      </unit>
      <unit id="1065">
        <segment state="initial">
          <source>This will enable DPC/ISR activities to be display.</source>
          <target>This will enable DPC/ISR activities to be display.</target>
        </segment>
      </unit>
      <unit id="1066">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Remove the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Process</pc> column and add the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stack</pc> column to view DPCs/ISRs sorted by stack.</source>
          <target>Remove the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Process</pc> column and add the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stack</pc> column to view DPCs/ISRs sorted by stack.</target>
        </segment>
      </unit>
      <unit id="1067">
        <segment state="initial">
          <source>Clear the current row selection.</source>
          <target>Clear the current row selection.</target>
        </segment>
      </unit>
      <unit id="1068">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Right-click a cell in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stack</pc> column and then click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Find in this column</pc>.</source>
          <target>Right-click a cell in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Stack</pc> column and then click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Find in this column</pc>.</target>
        </segment>
      </unit>
      <unit id="1069">
        <segment state="initial">
          <source>Enter a module and function that you noted in Step 2 of this procedure.</source>
          <target>Enter a module and function that you noted in Step 2 of this procedure.</target>
        </segment>
      </unit>
      <unit id="1070">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Check <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add to current selection</pc>, and click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Find All</pc> to select all instances of the function.</source>
          <target>Check <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add to current selection</pc>, and click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Find All</pc> to select all instances of the function.</target>
        </segment>
      </unit>
      <unit id="1071">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>After all the rows are selected, right-click and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Butterfly/View Callees</pc>.</source>
          <target>After all the rows are selected, right-click and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Butterfly/View Callees</pc>.</target>
        </segment>
      </unit>
      <unit id="1072">
        <segment state="initial">
          <source>This view shows the activities of this particular function, sorted by total duration.</source>
          <target>This view shows the activities of this particular function, sorted by total duration.</target>
        </segment>
      </unit>
      <unit id="1073">
        <segment state="initial">
          <source>The view is similar to a stacks display in the detailed view of an assessment-reported issue.</source>
          <target>The view is similar to a stacks display in the detailed view of an assessment-reported issue.</target>
        </segment>
      </unit>
      <unit id="1074">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Weight</pc> column approximates the inclusive time that is spent by each function on the stack, in milliseconds.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Weight</pc> column approximates the inclusive time that is spent by each function on the stack, in milliseconds.</target>
        </segment>
      </unit>
      <unit id="1075">
        <segment state="initial">
          <source>This view is shown in Figure 51 Callees of a DPC Sorted by Approximate Duration:</source>
          <target>This view is shown in Figure 51 Callees of a DPC Sorted by Approximate Duration:</target>
        </segment>
      </unit>
      <unit id="1076">
        <segment state="initial">
          <source>figure 51 callees of a dpc sorted by approximate d</source>
          <target>figure 51 callees of a dpc sorted by approximate d</target>
        </segment>
      </unit>
      <unit id="1077">
        <segment state="initial">
          <source>Figure 51 Callees of a DPC Sorted by Approximate Duration</source>
          <target>Figure 51 Callees of a DPC Sorted by Approximate Duration</target>
        </segment>
      </unit>
      <unit id="1078">
        <segment state="initial">
          <source>Technique: Review Long-Running DPCs/ISRs</source>
          <target>Technique: Review Long-Running DPCs/ISRs</target>
        </segment>
      </unit>
      <unit id="1079">
        <segment state="initial">
          <source>The total duration of DPCs/ISRs is important, but long-running individual DPCs/ISRs are more likely to cause delays.</source>
          <target>The total duration of DPCs/ISRs is important, but long-running individual DPCs/ISRs are more likely to cause delays.</target>
        </segment>
      </unit>
      <unit id="1080">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>In the DPC/ISR graph, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Inclusive Duration (ms)</pc> column, sorted in descending order, displays the maximum durations of individual DPC/ISRs.</source>
          <target>In the DPC/ISR graph, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Inclusive Duration (ms)</pc> column, sorted in descending order, displays the maximum durations of individual DPC/ISRs.</target>
        </segment>
      </unit>
      <unit id="1081">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The preset <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Long DPCs/ISRs</pc> that is available in some assessment profiles lets you filter this view to display only DPCs/ISRs that have an inclusive duration that is greater than 1ms.</source>
          <target>The preset <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Long DPCs/ISRs</pc> that is available in some assessment profiles lets you filter this view to display only DPCs/ISRs that have an inclusive duration that is greater than 1ms.</target>
        </segment>
      </unit>
      <unit id="1082">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="1083">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If this preset is not available, you can open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc> section, to add a filter.</source>
          <target>If this preset is not available, you can open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Editor</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Advanced</pc> section, to add a filter.</target>
        </segment>
      </unit>
      <unit id="1084">
        <segment state="initial">
          <source>Resolution</source>
          <target>Resolution</target>
        </segment>
      </unit>
      <unit id="1085">
        <segment state="initial">
          <source>DPC/ISR activity often reflects a hardware or software problem that must be corrected at the hardware or component level.</source>
          <target>DPC/ISR activity often reflects a hardware or software problem that must be corrected at the hardware or component level.</target>
        </segment>
      </unit>
      <unit id="1086">
        <segment state="initial">
          <source>At a configuration level, you can replace the hardware or upgrade the related driver to a fixed version.</source>
          <target>At a configuration level, you can replace the hardware or upgrade the related driver to a fixed version.</target>
        </segment>
      </unit>
      <unit id="1087">
        <segment state="initial">
          <source>At a component level, hardware and drivers should follow best practices for DPCs/ISRs from MSDN, and should use threaded DPCs when possible.</source>
          <target>At a component level, hardware and drivers should follow best practices for DPCs/ISRs from MSDN, and should use threaded DPCs when possible.</target>
        </segment>
      </unit>
      <unit id="1088">
        <segment state="initial">
          <source>Threaded DPCs do not run at the dispatch level on client editions of Windows.</source>
          <target>Threaded DPCs do not run at the dispatch level on client editions of Windows.</target>
        </segment>
      </unit>
      <unit id="1089">
        <segment state="initial">
          <source>For more information about best practices for DPCs/ISRs, see Guidelines on ISR and DPC behavior and Introduction to Threaded DPCs.</source>
          <target>For more information about best practices for DPCs/ISRs, see Guidelines on ISR and DPC behavior and Introduction to Threaded DPCs.</target>
        </segment>
      </unit>
      <unit id="1090">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="1091">
        <segment state="initial">
          <source>Introduction to Threaded DPCs</source>
          <target>Introduction to Threaded DPCs</target>
        </segment>
      </unit>
      <unit id="1092">
        <segment state="initial">
          <source>ISRs and DPCs, The Silent Killers</source>
          <target>ISRs and DPCs, The Silent Killers</target>
        </segment>
      </unit>
      <unit id="1093">
        <segment state="initial">
          <source>Loading Symbols</source>
          <target>Loading Symbols</target>
        </segment>
      </unit>
      <unit id="1094">
        <segment state="initial">
          <source>Power Management and ACPI - Architecture and Driver Support</source>
          <target>Power Management and ACPI - Architecture and Driver Support</target>
        </segment>
      </unit>
      <unit id="1095">
        <segment state="initial">
          <source>PPM in Windows Vista and Windows Server 2008</source>
          <target>PPM in Windows Vista and Windows Server 2008</target>
        </segment>
      </unit>
      <unit id="1096">
        <segment state="initial">
          <source>Scheduling Priorities</source>
          <target>Scheduling Priorities</target>
        </segment>
      </unit>
      <unit id="1097">
        <segment state="initial">
          <source>Scheduling, Thread Context, and IRQL</source>
          <target>Scheduling, Thread Context, and IRQL</target>
        </segment>
      </unit>
      <unit id="1098">
        <segment state="initial">
          <source>Windows Internals, Sixth Edition</source>
          <target>Windows Internals, Sixth Edition</target>
        </segment>
      </unit>
      <unit id="1099">
        <segment state="initial">
          <source>Windows Performance Analyzer</source>
          <target>Windows Performance Analyzer</target>
        </segment>
      </unit>
      <unit id="1100">
        <segment state="initial">
          <source>Windows Performance Toolkit Technical Reference</source>
          <target>Windows Performance Toolkit Technical Reference</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>