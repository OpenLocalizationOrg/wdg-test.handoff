<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationtype">Human Translation</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">docset\performance\wpt\creating-a-regions-of-interest-file.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">c2d82e729309c3e2010c1ed65fac74873e860b74</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-48076a9</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Creating a Regions of Interest File</source>
          <target>Creating a Regions of Interest File</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Creating a Regions of Interest File</source>
          <target>Creating a Regions of Interest File</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Creating a Regions of Interest File</source>
          <target>Creating a Regions of Interest File</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>A Regions of Interest file is a valid XML file that contains the following nodes:</source>
          <target>A Regions of Interest file is a valid XML file that contains the following nodes:</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>InstrumentationManifest</source>
          <target>InstrumentationManifest</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Instrumentation</source>
          <target>Instrumentation</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>Regions</source>
          <target>Regions</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionsRoot</pc>, a container for all of the defined regions</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionsRoot</pc>, a container for all of the defined regions</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>One or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> nodes</source>
          <target>One or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> nodes</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">`version='1.0'`</data>
        </originalData>
        <segment state="initial">
          <source>In a region's definition, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">version</pc> attribute in the XML declaration, such as <ph dataRef="id3" id="ph1" />, is optional.</source>
          <target>In a region's definition, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">version</pc> attribute in the XML declaration, such as <ph dataRef="id3" id="ph1" />, is optional.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>The following example is a complete Regions of Interest file that defines a simple region.</source>
          <target>The following example is a complete Regions of Interest file that defines a simple region.</target>
        </segment>
      </unit>
      <unit id="113">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Explanations for the attributes and nodes within <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> are described after the example.</source>
          <target>Explanations for the attributes and nodes within <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> are described after the example.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>This topic has the following contents:</source>
          <target>This topic has the following contents:</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>Defining a region</source>
          <target>Defining a region</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>Region types</source>
          <target>Region types</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>Using payload fields to identify events</source>
          <target>Using payload fields to identify events</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>Matching events for regions</source>
          <target>Matching events for regions</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>Filtering a region based on a condition</source>
          <target>Filtering a region based on a condition</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Parent-child relationships</source>
          <target>Parent-child relationships</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>Self-nesting regions</source>
          <target>Self-nesting regions</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Instance names</source>
          <target>Instance names</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>Metadata</source>
          <target>Metadata</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>Defining a region</source>
          <target>Defining a region</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>A region definition contains the following attributes in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> node:</source>
          <target>A region definition contains the following attributes in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> node:</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Guid</pc> (required), a GUID for the region.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Guid</pc> (required), a GUID for the region.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> (required), a unique name for the region.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> (required), a unique name for the region.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">`Root-GrandparentName-ParentName-RegionName`</data>
        </originalData>
        <segment state="initial">
          <source>A suggested format for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> is <ph dataRef="id3" id="ph1" />.</source>
          <target>A suggested format for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> is <ph dataRef="id3" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FriendlyName</pc> (optional), an alternate name for the region.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FriendlyName</pc> (optional), an alternate name for the region.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Region types</source>
          <target>Region types</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>You can create the following types of regions based on how they start and stop:</source>
          <target>You can create the following types of regions based on how they start and stop:</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Regions based on events</source>
          <target>Regions based on events</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Regions based on duration</source>
          <target>Regions based on duration</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Regions based on other regions</source>
          <target>Regions based on other regions</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>Regions that are containers of other regions</source>
          <target>Regions that are containers of other regions</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>Regions based on events</source>
          <target>Regions based on events</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>The most common type of region is one whose starting and stopping points are defined by events.</source>
          <target>The most common type of region is one whose starting and stopping points are defined by events.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>To specify an event as the starting or stopping point, you need to provide the following attributes:</source>
          <target>To specify an event as the starting or stopping point, you need to provide the following attributes:</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Provider</pc>, a GUID that specifies the provider ID for the event.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Provider</pc>, a GUID that specifies the provider ID for the event.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Id</pc>, an unsigned short that specifies the ID of the event.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Id</pc>, an unsigned short that specifies the ID of the event.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Version</pc>, an unsigned char that specifies the event version.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Version</pc>, an unsigned char that specifies the event version.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Additionally, you can further refine your definition by adding one or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes.</source>
          <target>Additionally, you can further refine your definition by adding one or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>These tags contain two string attributes, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FieldValue</pc>, that specify a field that the event must contain.</source>
          <target>These tags contain two string attributes, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FieldValue</pc>, that specify a field that the event must contain.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> tags are further described below in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Using payload fields to identify events</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> tags are further described below in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Using payload fields to identify events</pc>.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Examples</source>
          <target>Examples</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>Following is a basic example for this type of region:</source>
          <target>Following is a basic example for this type of region:</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">`StartOrStop`</data>
          <data id="id2">`Stop`</data>
        </originalData>
        <segment state="initial">
          <source>In the following example, the region ends only when the specified event contains a field named <ph dataRef="id1" id="ph1" /> with a value of <ph dataRef="id2" id="ph2" />:</source>
          <target>In the following example, the region ends only when the specified event contains a field named <ph dataRef="id1" id="ph1" /> with a value of <ph dataRef="id2" id="ph2" />:</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>Regions based on duration</source>
          <target>Regions based on duration</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Many ETW events are defined as a single stop event with a duration payload field.</source>
          <target>Many ETW events are defined as a single stop event with a duration payload field.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>We can calculate the starting point by subtracting the duration from the stop event time.</source>
          <target>We can calculate the starting point by subtracting the duration from the stop event time.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc> tag can be used within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> tag to specify a payload field from which to grab duration information.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc> tag can be used within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> tag to specify a payload field from which to grab duration information.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>If you define a duration for the starting point, the duration is subtracted from the stopping point.</source>
          <target>If you define a duration for the starting point, the duration is subtracted from the stopping point.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>Similarly, if you define a duration for the stopping point, the duration is added to the starting point.</source>
          <target>Similarly, if you define a duration for the stopping point, the duration is added to the starting point.</target>
        </segment>
      </unit>
      <unit id="154">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc> node can have the following attributes:</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc> node can have the following attributes:</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Provider</pc>, a GUID that specifies the provider ID for the event that contains the payload field.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Provider</pc>, a GUID that specifies the provider ID for the event that contains the payload field.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Id</pc>, an unsigned short that specifies the ID of the event that contains the payload field.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Id</pc>, an unsigned short that specifies the ID of the event that contains the payload field.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Version</pc>, an unsigned char that specifies the version of the event that contains the payload field.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Version</pc>, an unsigned char that specifies the version of the event that contains the payload field.</target>
        </segment>
      </unit>
      <unit id="158">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc>, a string that specifies the name of the payload field.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Duration</pc>, a string that specifies the name of the payload field.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Multiplier</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Multiplier</pc>.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>WPA requires the duration to be in nanoseconds.</source>
          <target>WPA requires the duration to be in nanoseconds.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>Use this attribute to convert the duration to nanoseconds, if necessary.</source>
          <target>Use this attribute to convert the duration to nanoseconds, if necessary.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>For example, use 1000000 (one million) to convert milliseconds to nanoseconds.</source>
          <target>For example, use 1000000 (one million) to convert milliseconds to nanoseconds.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>If you define a duration for the starting point, the duration is subtracted from the stopping point.</source>
          <target>If you define a duration for the starting point, the duration is subtracted from the stopping point.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>Similarly, if you define a duration for the stopping point, the duration is added to the starting point.</source>
          <target>Similarly, if you define a duration for the stopping point, the duration is added to the starting point.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>The following example defines a region that stops when another region starts.</source>
          <target>The following example defines a region that stops when another region starts.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>To calculate the starting point, we subtract a duration from our stopping point.</source>
          <target>To calculate the starting point, we subtract a duration from our stopping point.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>The duration is found in the HiberHiberFileTime payload field.</source>
          <target>The duration is found in the HiberHiberFileTime payload field.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>We then multiply the duration by 1,000,000 to convert it to nanoseconds and subtract it from the stopping point.</source>
          <target>We then multiply the duration by 1,000,000 to convert it to nanoseconds and subtract it from the stopping point.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>Regions based on other regions</source>
          <target>Regions based on other regions</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>You can define a region whose starting and stopping points are defined by other regions by using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> node within the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> node.</source>
          <target>You can define a region whose starting and stopping points are defined by other regions by using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Region</pc> node within the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> node.</target>
        </segment>
      </unit>
      <unit id="172">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>This Region node has one mandatory attribute, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionGuid</pc>, that specifies the GUID of the target region.</source>
          <target>This Region node has one mandatory attribute, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionGuid</pc>, that specifies the GUID of the target region.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>By default, a region whose starting point is based on another region will start when the starting point region stops.</source>
          <target>By default, a region whose starting point is based on another region will start when the starting point region stops.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>Similarly, a region whose stopping point is based on another region will stop when the stopping point region starts.</source>
          <target>Similarly, a region whose stopping point is based on another region will stop when the stopping point region starts.</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>You can override this default behavior by adding an optional attribute, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Endpoint</pc>, to the Region node.</source>
          <target>You can override this default behavior by adding an optional attribute, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Endpoint</pc>, to the Region node.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">`Start`</data>
          <data id="id4">`Stop`</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Endpoint</pc> can have a value of <ph dataRef="id3" id="ph1" /> or <ph dataRef="id4" id="ph2" /> and specifies which endpoint of the region to use for the starting or stopping event.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Endpoint</pc> can have a value of <ph dataRef="id3" id="ph1" /> or <ph dataRef="id4" id="ph2" /> and specifies which endpoint of the region to use for the starting or stopping event.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>The following region definition contains starting and stopping points that are defined by other regions:</source>
          <target>The following region definition contains starting and stopping points that are defined by other regions:</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>Regions that are containers of other regions</source>
          <target>Regions that are containers of other regions</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Regions that contain other regions are called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">containers</pc>.</source>
          <target>Regions that contain other regions are called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">containers</pc>.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>Containers start when the first instance of a contained region starts, and they stop when the last instance stops.</source>
          <target>Containers start when the first instance of a contained region starts, and they stop when the last instance stops.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>These regions do not have any other attributes.</source>
          <target>These regions do not have any other attributes.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionRoot</pc> is a container for all of the regions that you define.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionRoot</pc> is a container for all of the regions that you define.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Thus, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionRoot</pc> starts when the first instance of a region starts, and it stops when the last instance of a region stops.</source>
          <target>Thus, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionRoot</pc> starts when the first instance of a region starts, and it stops when the last instance of a region stops.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>To define a container region, simply define a region without a starting point or a stopping point.</source>
          <target>To define a container region, simply define a region without a starting point or a stopping point.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>In the example below, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Subscribers for Create Session</pc> is a container for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Child of Subscribers of Create Session</pc>.</source>
          <target>In the example below, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Subscribers for Create Session</pc> is a container for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Child of Subscribers of Create Session</pc>.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Notice that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Subscribers for Create Session</pc> does not have a starting point or a stopping point.</source>
          <target>Notice that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Subscribers for Create Session</pc> does not have a starting point or a stopping point.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>It will start when the first instance of a child region starts and stop when the last instance of a child region stops.</source>
          <target>It will start when the first instance of a child region starts and stop when the last instance of a child region stops.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>Using payload fields to identify events</source>
          <target>Using payload fields to identify events</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>Often the event ID properties (process ID, thread ID, and activity ID) are not enough to identify specific scenarios.</source>
          <target>Often the event ID properties (process ID, thread ID, and activity ID) are not enough to identify specific scenarios.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>For example, when a service starts, a generic event is fired that might not identify which service started.</source>
          <target>For example, when a service starts, a generic event is fired that might not identify which service started.</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>When this occurs, you must rely on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">payload fields</pc> for additional information.</source>
          <target>When this occurs, you must rely on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">payload fields</pc> for additional information.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>In this case, one of the additional fields should include the service name.</source>
          <target>In this case, one of the additional fields should include the service name.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>You can use this information to further specify region starting and stopping points.</source>
          <target>You can use this information to further specify region starting and stopping points.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>To use payload fields as additional event identifiers, add one or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> node.</source>
          <target>To use payload fields as additional event identifiers, add one or more <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Start</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Stop</pc> node.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> node has the following attributes:</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> node has the following attributes:</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> (required), the name of the payload field.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> (required), the name of the payload field.</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldValue</pc> (required), the payload value.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldValue</pc> (required), the payload value.</target>
        </segment>
      </unit>
      <unit id="200">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldValueRelationship</pc> (optional).</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldValueRelationship</pc> (optional).</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEqual</pc> to specify that the event must contain the payload value.</source>
          <target>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEqual</pc> to specify that the event must contain the payload value.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DoesNotContain</pc> to specify that the event must not contain the payload value.</source>
          <target>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DoesNotContain</pc> to specify that the event must not contain the payload value.</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If this attribute is not specified, the default value is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEqual</pc>.</source>
          <target>If this attribute is not specified, the default value is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEqual</pc>.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>Payload fields are case-sensitive, and the XML definition must fully match the payload value.</source>
          <target>Payload fields are case-sensitive, and the XML definition must fully match the payload value.</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">`00000`</data>
          <data id="id2">`00000`</data>
        </originalData>
        <segment state="initial">
          <source>For example, if a payload field has a value of <ph dataRef="id1" id="ph1" />, the region definition must also specify <ph dataRef="id2" id="ph2" /> as the payload value.</source>
          <target>For example, if a payload field has a value of <ph dataRef="id1" id="ph1" />, the region definition must also specify <ph dataRef="id2" id="ph2" /> as the payload value.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="208">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The following example contains <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes for both the starting point and the stopping point:</source>
          <target>The following example contains <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadIdentifier</pc> nodes for both the starting point and the stopping point:</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>Matching events for regions</source>
          <target>Matching events for regions</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>WPA matches starting events with stopping events to form regions in a process called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">event matching</pc>.</source>
          <target>WPA matches starting events with stopping events to form regions in a process called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">event matching</pc>.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>At the event level, WPA attempts to match a single starting or stopping event based on its provider ID, event ID, event version, and any additional specified payload fields.</source>
          <target>At the event level, WPA attempts to match a single starting or stopping event based on its provider ID, event ID, event version, and any additional specified payload fields.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>Matching can also be extended to the region level, where criteria can be specified that must be met by both the starting and stopping points.</source>
          <target>Matching can also be extended to the region level, where criteria can be specified that must be met by both the starting and stopping points.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>At the region level, you can require that both points have matching thread IDs, process IDs, and activity IDs.</source>
          <target>At the region level, you can require that both points have matching thread IDs, process IDs, and activity IDs.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>Additionally, you can also define payload criteria at the region level.</source>
          <target>Additionally, you can also define payload criteria at the region level.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You can use region-level matching by including a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> node inside of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Region</pc> node.</source>
          <target>You can use region-level matching by including a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> node inside of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Region</pc> node.</target>
        </segment>
      </unit>
      <unit id="216">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> node contains a child node, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc>, that can have any combination of the following attributes:</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> node contains a child node, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc>, that can have any combination of the following attributes:</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>– require matching thread IDs</source>
          <target>– require matching thread IDs</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>– require matching process IDs</source>
          <target>– require matching process IDs</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>– require matching activity IDs</source>
          <target>– require matching activity IDs</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Event</pc> node can have an optional <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Payload</pc> child node that contains a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FieldName</pc> attribute.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Event</pc> node can have an optional <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Payload</pc> child node that contains a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FieldName</pc> attribute.</target>
        </segment>
      </unit>
      <unit id="221">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>This node requires that both the starting and stopping nodes contain matching payload values for the specified <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc>.</source>
          <target>This node requires that both the starting and stopping nodes contain matching payload values for the specified <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc>.</target>
        </segment>
      </unit>
      <unit id="222">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>Alternatively, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Payload</pc> node can also contain an optional attribute, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc>.</source>
          <target>Alternatively, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Payload</pc> node can also contain an optional attribute, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc>.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>If this attribute is specified, then <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> corresponds to a payload field only in the starting node, while <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc> corresponds to a payload field in the stopping node.</source>
          <target>If this attribute is specified, then <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> corresponds to a payload field only in the starting node, while <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc> corresponds to a payload field in the stopping node.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The following example forms a region when the starting event contains a payload field, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SubscriberName</pc>, whose value matches that of a payload field, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Client</pc>, in the stopping node.</source>
          <target>The following example forms a region when the starting event contains a payload field, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SubscriberName</pc>, whose value matches that of a payload field, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Client</pc>, in the stopping node.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>The starting and stopping events must also have matching thread IDs.</source>
          <target>The starting and stopping events must also have matching thread IDs.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>Filtering a region based on a condition</source>
          <target>Filtering a region based on a condition</target>
        </segment>
      </unit>
      <unit id="228">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>WPA can include or exclude a region based on a condition, or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">trigger</pc>, which can be an event or another region.</source>
          <target>WPA can include or exclude a region based on a condition, or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">trigger</pc>, which can be an event or another region.</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source>The trigger is specified in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> node, and the region that contains <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Filter</pc> is called the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">target</pc>.</source>
          <target>The trigger is specified in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> node, and the region that contains <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Filter</pc> is called the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">target</pc>.</target>
        </segment>
      </unit>
      <unit id="230">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](#region-types)</data>
          <data id="id7">*</data>
          <data id="id8">*</data>
          <data id="id9">*</data>
          <data id="id10">*</data>
          <data id="id11">*</data>
          <data id="id12">*</data>
          <data id="id13">*</data>
          <data id="id14">*</data>
          <data id="id15">*</data>
          <data id="id16">*</data>
        </originalData>
        <segment state="initial">
          <source>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> node contains one <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> node with the attributes described earlier in <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Region types</pc> (<pc dataRefEnd="id8" dataRefStart="id7" id="p4">Provider</pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Id</pc>, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Version</pc>), plus the following additional attributes: <pc dataRefEnd="id14" dataRefStart="id13" id="p7">OpCode</pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8">Type</pc>.</source>
          <target>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Filter</pc> node contains one <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> node with the attributes described earlier in <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Region types</pc> (<pc dataRefEnd="id8" dataRefStart="id7" id="p4">Provider</pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Id</pc>, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Version</pc>), plus the following additional attributes: <pc dataRefEnd="id14" dataRefStart="id13" id="p7">OpCode</pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8">Type</pc>.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OpCode</pc> is...</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OpCode</pc> is...</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> specifies the mode of filtering the targeted region, including or excluding it based on the conditions described in the following table.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> specifies the mode of filtering the targeted region, including or excluding it based on the conditions described in the following table.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source>Type of filter</source>
          <target>Type of filter</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>Out</source>
          <target>Out</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source>Exclude the target region when the triggering event or region is found.</source>
          <target>Exclude the target region when the triggering event or region is found.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>OutPost</source>
          <target>OutPost</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>Exclude the target region when the target occurred after the most recent triggering event or region.</source>
          <target>Exclude the target region when the target occurred after the most recent triggering event or region.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>OutPrev</source>
          <target>OutPrev</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>Exclude the target region when the target occurred prior to the first triggering event or region.</source>
          <target>Exclude the target region when the target occurred prior to the first triggering event or region.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>In</source>
          <target>In</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>Include the target region only when the triggering event or region is found.</source>
          <target>Include the target region only when the triggering event or region is found.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>InPost</source>
          <target>InPost</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source>Include the target region only when it occurred after the most recent triggering event or region.</source>
          <target>Include the target region only when it occurred after the most recent triggering event or region.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>InPrev</source>
          <target>InPrev</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>Include the target region only when it occurred prior to the first triggering event or region.</source>
          <target>Include the target region only when it occurred prior to the first triggering event or region.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>Parent-child relationships</source>
          <target>Parent-child relationships</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>You can define a region within another to create a parent-child relationship.</source>
          <target>You can define a region within another to create a parent-child relationship.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>For a region to be a parent, it must have a start time that is earlier than or equal to the start time of the child region.</source>
          <target>For a region to be a parent, it must have a start time that is earlier than or equal to the start time of the child region.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>It must also have a stopping time that is later than or equal to the stopping time of the child region.</source>
          <target>It must also have a stopping time that is later than or equal to the stopping time of the child region.</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>If these conditions are not met, a parent-child relationship cannot be formed.</source>
          <target>If these conditions are not met, a parent-child relationship cannot be formed.</target>
        </segment>
      </unit>
      <unit id="252">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To specify additional criteria for a parent region, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent</pc> node within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Match</pc> node.</source>
          <target>To specify additional criteria for a parent region, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent</pc> node within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Match</pc> node.</target>
        </segment>
      </unit>
      <unit id="253">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent</pc> node has the same attributes and child nodes as the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> node used in region-level matching.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent</pc> node has the same attributes and child nodes as the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> node used in region-level matching.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>You can specify that the parent and child regions must have the same thread ID, process ID, activity ID, and any number of matching payload fields.</source>
          <target>You can specify that the parent and child regions must have the same thread ID, process ID, activity ID, and any number of matching payload fields.</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>When using payload fields, if you specify only the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> attribute, then both the parent and child regions must have matching payload values for that field.</source>
          <target>When using payload fields, if you specify only the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FieldName</pc> attribute, then both the parent and child regions must have matching payload values for that field.</target>
        </segment>
      </unit>
      <unit id="256">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
          <data id="id7">*</data>
          <data id="id8">*</data>
        </originalData>
        <segment state="initial">
          <source>If you also specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetFieldName</pc> attribute, then the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc> attribute applies to the parent as well as the child, meaning that the child region must have a payload value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FieldName</pc> field that matches the payload value for the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">TargetFieldName</pc> field in the parent.</source>
          <target>If you also specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetFieldName</pc> attribute, then the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetFieldName</pc> attribute applies to the parent as well as the child, meaning that the child region must have a payload value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FieldName</pc> field that matches the payload value for the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">TargetFieldName</pc> field in the parent.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>If a child has more than one potential parent, the parent with the earliest starting time is chosen.</source>
          <target>If a child has more than one potential parent, the parent with the earliest starting time is chosen.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>The example below defines criteria for a parent.</source>
          <target>The example below defines criteria for a parent.</target>
        </segment>
      </unit>
      <unit id="260">
        <originalData>
          <data id="id1">`SubscriberName`</data>
          <data id="id2">`Client`</data>
        </originalData>
        <segment state="initial">
          <source>The parent must have a matching thread ID, and a payload value for the <ph dataRef="id1" id="ph1" /> field in the child must match a value for the <ph dataRef="id2" id="ph2" /> field in the parent.</source>
          <target>The parent must have a matching thread ID, and a payload value for the <ph dataRef="id1" id="ph1" /> field in the child must match a value for the <ph dataRef="id2" id="ph2" /> field in the parent.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>Self-nesting regions</source>
          <target>Self-nesting regions</target>
        </segment>
      </unit>
      <unit id="262">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Self-nesting</pc> is an optional feature that optimizes parent-child relationships.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Self-nesting</pc> is an optional feature that optimizes parent-child relationships.</target>
        </segment>
      </unit>
      <unit id="263">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">self-nesting region</pc> is one whose duration is contained wholly within the duration of a sibling region.</source>
          <target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">self-nesting region</pc> is one whose duration is contained wholly within the duration of a sibling region.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source>This region effectively becomes a child of its longer-lasting sibling.</source>
          <target>This region effectively becomes a child of its longer-lasting sibling.</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>For example, assume that self-nesting is enabled for the following regions:</source>
          <target>For example, assume that self-nesting is enabled for the following regions:</target>
        </segment>
      </unit>
      <unit id="266">
        <segment state="initial">
          <source>Parent region A</source>
          <target>Parent region A</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source>Child region B1, which starts at time 0 and stops at time 6</source>
          <target>Child region B1, which starts at time 0 and stops at time 6</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source>Child region B2, which starts at time 2 and stops at time 5</source>
          <target>Child region B2, which starts at time 2 and stops at time 5</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>Child region B3, which starts at time 3 and stops at time 4</source>
          <target>Child region B3, which starts at time 3 and stops at time 4</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>In this example, B2 becomes a child region of B1, and B3 becomes a child region of B2.</source>
          <target>In this example, B2 becomes a child region of B1, and B3 becomes a child region of B2.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>When creating this type of parent-child relationship, the parent with the starting time closest to the child starting time is chosen.</source>
          <target>When creating this type of parent-child relationship, the parent with the starting time closest to the child starting time is chosen.</target>
        </segment>
      </unit>
      <unit id="272">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To activate self-nesting, add a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SelfNest</pc> node inside of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Match</pc> node.</source>
          <target>To activate self-nesting, add a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SelfNest</pc> node inside of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Match</pc> node.</target>
        </segment>
      </unit>
      <unit id="273">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SelfNest</pc> node has no required parameters.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SelfNest</pc> node has no required parameters.</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>You can, however, use the same matching parameters that are used to create ordinary parent-child relationships.</source>
          <target>You can, however, use the same matching parameters that are used to create ordinary parent-child relationships.</target>
        </segment>
      </unit>
      <unit id="275">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent-child relationships</pc> earlier in this topic.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parent-child relationships</pc> earlier in this topic.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>Examples</source>
          <target>Examples</target>
        </segment>
      </unit>
      <unit id="277">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The following example defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> tag that simply invokes self-nesting:</source>
          <target>The following example defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Match</pc> tag that simply invokes self-nesting:</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>The following example defines a more complex self-nesting scenario that requires matching thread IDs and payload fields:</source>
          <target>The following example defines a more complex self-nesting scenario that requires matching thread IDs and payload fields:</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source>Instance names</source>
          <target>Instance names</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You can assign a unique name to each instance of a matched region by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node.</source>
          <target>You can assign a unique name to each instance of a matched region by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>Naming is useful when you have a large number of instances of the same region or when you need to categorize regions based on other criteria.</source>
          <target>Naming is useful when you have a large number of instances of the same region or when you need to categorize regions based on other criteria.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>Instance names can be based on either payload fields or on relationships with other regions.</source>
          <target>Instance names can be based on either payload fields or on relationships with other regions.</target>
        </segment>
      </unit>
      <unit id="283">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Instances can be named based on payload values by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadBased</pc> node within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Naming</pc> node.</source>
          <target>Instances can be named based on payload values by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadBased</pc> node within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Naming</pc> node.</target>
        </segment>
      </unit>
      <unit id="284">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadBased</pc> node has one required attribute, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NameField</pc>, that specifies the payload field whose values you want to use as instance names.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PayloadBased</pc> node has one required attribute, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NameField</pc>, that specifies the payload field whose values you want to use as instance names.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>These payload fields can be in either the starting or stopping point for the region.</source>
          <target>These payload fields can be in either the starting or stopping point for the region.</target>
        </segment>
      </unit>
      <unit id="286">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Following is an example of a region with a payload-based <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node:</source>
          <target>Following is an example of a region with a payload-based <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node:</target>
        </segment>
      </unit>
      <unit id="287">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">`SubscriberName`</data>
        </originalData>
        <segment state="initial">
          <source>In the preceding example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node indicates that either the starting or the stopping event contains a payload field named <ph dataRef="id3" id="ph1" />.</source>
          <target>In the preceding example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Naming</pc> node indicates that either the starting or the stopping event contains a payload field named <ph dataRef="id3" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source>For each instance of the region that is created, the instance name is the associated payload value.</source>
          <target>For each instance of the region that is created, the instance name is the associated payload value.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source>When naming region instances, WPA first checks the starting event for the matching payload field.</source>
          <target>When naming region instances, WPA first checks the starting event for the matching payload field.</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source>If one is not found, WPA will then search the stopping event for the payload field.</source>
          <target>If one is not found, WPA will then search the stopping event for the payload field.</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>If a match is not found in either event, an error is printed to the console.</source>
          <target>If a match is not found in either event, an error is printed to the console.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>Sometimes, the information in the payload is not the only information we want.</source>
          <target>Sometimes, the information in the payload is not the only information we want.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>For example, if the information in the payload contained is a device ID, we may wish to map this information back to a device description and name.</source>
          <target>For example, if the information in the payload contained is a device ID, we may wish to map this information back to a device description and name.</target>
        </segment>
      </unit>
      <unit id="295">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Supported <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> attributes are:</source>
          <target>Supported <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> attributes are:</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>, associates a name and description</source>
          <target>, associates a name and description</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>, associates the GUID with the region</source>
          <target>, associates the GUID with the region</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source>, associates a class name to the class ID</source>
          <target>, associates a class name to the class ID</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>, associates the process name with the region</source>
          <target>, associates the process name with the region</target>
        </segment>
      </unit>
      <unit id="300">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>If it is possible for the payload value to be found in both the starting and stopping points, you can use the optional <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InstanceEndpoint</pc> attribute to specify which point to use.</source>
          <target>If it is possible for the payload value to be found in both the starting and stopping points, you can use the optional <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InstanceEndpoint</pc> attribute to specify which point to use.</target>
        </segment>
      </unit>
      <unit id="301">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">`Start`</data>
          <data id="id4">`Stop`</data>
        </originalData>
        <segment state="initial">
          <source>Possible values for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InstanceEndpoint</pc> are <ph dataRef="id3" id="ph1" /> and <ph dataRef="id4" id="ph2" />.</source>
          <target>Possible values for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InstanceEndpoint</pc> are <ph dataRef="id3" id="ph1" /> and <ph dataRef="id4" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source>You can also name a region based on relationships with other regions.</source>
          <target>You can also name a region based on relationships with other regions.</target>
        </segment>
      </unit>
      <unit id="303">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>To associate with another region, add a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionBased</pc> node to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Naming</pc> node.</source>
          <target>To associate with another region, add a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionBased</pc> node to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Naming</pc> node.</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionBased</pc> node has four required attributes:</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionBased</pc> node has four required attributes:</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionGuid</pc>, the GUID of the associated region.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RegionGuid</pc>, the GUID of the associated region.</target>
        </segment>
      </unit>
      <unit id="306">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Relation</pc>, a conditional value that describes the relationship between the region you are defining and the region with which you are associating.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Relation</pc>, a conditional value that describes the relationship between the region you are defining and the region with which you are associating.</target>
        </segment>
      </unit>
      <unit id="307">
        <originalData>
          <data id="id1">`IsPresent`</data>
        </originalData>
        <segment state="initial">
          <source>Currently, the only supported relationship is <ph dataRef="id1" id="ph1" />, meaning that the conditional is true if the associated region is found somewhere in the trace.</source>
          <target>Currently, the only supported relationship is <ph dataRef="id1" id="ph1" />, meaning that the conditional is true if the associated region is found somewhere in the trace.</target>
        </segment>
      </unit>
      <unit id="308">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IfRelationTrue</pc>, string value that is used as the instance name if the relationship described by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Relation</pc> is true.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IfRelationTrue</pc>, string value that is used as the instance name if the relationship described by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Relation</pc> is true.</target>
        </segment>
      </unit>
      <unit id="309">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IfRelationFalse</pc>, string value that is used as the instance name if the relationship described by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Relation</pc> is false.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IfRelationFalse</pc>, string value that is used as the instance name if the relationship described by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Relation</pc> is false.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source>The following example defines a region that has region-based naming.</source>
          <target>The following example defines a region that has region-based naming.</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">`Launch`</data>
          <data id="id2">`Warm`</data>
        </originalData>
        <segment state="initial">
          <source>If a region with a matching GUID is found somewhere in the trace, then each instance of <ph dataRef="id1" id="ph1" /> is named <ph dataRef="id2" id="ph2" />.</source>
          <target>If a region with a matching GUID is found somewhere in the trace, then each instance of <ph dataRef="id1" id="ph1" /> is named <ph dataRef="id2" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="312">
        <originalData>
          <data id="id1">`Cold`</data>
        </originalData>
        <segment state="initial">
          <source>Otherwise, each instance is named <ph dataRef="id1" id="ph1" />.</source>
          <target>Otherwise, each instance is named <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source>You can see instance names in WPA by hovering the mouse over a region instance in the Regions of Interest graph.</source>
          <target>You can see instance names in WPA by hovering the mouse over a region instance in the Regions of Interest graph.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>Metadata</source>
          <target>Metadata</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You can add additional information to a region definition in the form of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">metadata</pc>, contained within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Metadata</pc> node.</source>
          <target>You can add additional information to a region definition in the form of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">metadata</pc>, contained within a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Metadata</pc> node.</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>For example, you might include information in metadata that explains the region criteria so that another user can more easily understand the purpose of the region.</source>
          <target>For example, you might include information in metadata that explains the region criteria so that another user can more easily understand the purpose of the region.</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source>Metadata is simply additional data—it does not affect the processing of regions.</source>
          <target>Metadata is simply additional data—it does not affect the processing of regions.</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source>WPA adds this metadata to each region instance in the chart view of the Regions of Interest graph.</source>
          <target>WPA adds this metadata to each region instance in the chart view of the Regions of Interest graph.</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source>To view metadata for matched events in WPA, simply expand the region in the chart view, and scroll to the desired metadata.</source>
          <target>To view metadata for matched events in WPA, simply expand the region in the chart view, and scroll to the desired metadata.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source>WPA assigns a unique number to the metadata, and the name of the node is displayed as the column information.</source>
          <target>WPA assigns a unique number to the metadata, and the name of the node is displayed as the column information.</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source>Example</source>
          <target>Example</target>
        </segment>
      </unit>
      <unit id="323">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The following example includes a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Metadata</pc> node in the region definition:</source>
          <target>The following example includes a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Metadata</pc> node in the region definition:</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source>Regions of Interest</source>
          <target>Regions of Interest</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source>WPA Features</source>
          <target>WPA Features</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>