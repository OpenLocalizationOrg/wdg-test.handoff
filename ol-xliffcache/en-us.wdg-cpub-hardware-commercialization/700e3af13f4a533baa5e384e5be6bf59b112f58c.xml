{"nodes":[{"content":"Supporting new OID commands for manufacturing mode","pos":[34,84]},{"content":"Supporting new OID commands for manufacturing mode","pos":[191,241]},{"content":"Supporting new OID commands for manufacturing mode","pos":[249,299]},{"content":"When running in manufacturing mode, Wi-Fi miniport drivers must add support for the following new OID commands.","pos":[302,413]},{"content":"The driver should ensure that the device is currently in manufacturing mode prior to calling any of these commands.","pos":[414,529]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Determine if MMOS is running<ept id=\"p1\">](determine-if-mmos-is-running.md)</ept>.","pos":[530,613]},{"content":"Some of the parameters specified in the API may be IHV-specific.","pos":[614,678]},{"pos":[777,808],"content":"OID<ph id=\"ph1\">\\_</ph>DOT11<ph id=\"ph2\">\\_</ph>MANUFACTURING<ph id=\"ph3\">\\_</ph>TEST"},{"content":"OID<ph id=\"ph1\">\\_</ph>DOT11<ph id=\"ph2\">\\_</ph>MANUFACTURING<ph id=\"ph3\">\\_</ph>TEST is called as a method request in the driver to perform a specific test.","pos":[811,914]},{"content":"This OID should never be used during normal operation.","pos":[915,969]},{"content":"dot11ManufacturingTestType","pos":[1333,1359]},{"content":"in<ph id=\"ph1\">\\]</ph> Specifies the manufacturing test to be run.","pos":[1365,1413]},{"content":"The data type for this member is one of the values of the <bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>TEST<ph id=\"ph3\">\\_</ph>TYPE<ept id=\"p1\">**</ept> enumeration.","pos":[1414,1521]},{"content":"The DOT11 manufacturing test type enumeration is defined as follows:","pos":[1523,1591]},{"content":"uBufferLength","pos":[2303,2316]},{"content":"in<ph id=\"ph1\">\\]</ph> The length, in bytes, of the <bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph2\">\\_</ph>MANUFACTURING<ph id=\"ph3\">\\_</ph>TEST<ept id=\"p1\">**</ept> structure and any additional data specific to the test appended at the end.","pos":[2322,2462]},{"content":"ucBuffer","pos":[2546,2554]},{"content":"in<ph id=\"ph1\">\\]</ph> The buffer containing optional data as specified by the <bpt id=\"p1\">**</bpt>dot11DiagnosticsTestType<ept id=\"p1\">**</ept> member.","pos":[2560,2657]},{"pos":[2770,2809],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>self<ph id=\"ph4\">\\_</ph>start"},{"pos":[2812,2988],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>self<ph id=\"ph4\">\\_</ph>start<ept id=\"p1\">**</ept> command is called to request the driver to test WLAN IC connectivity, FEM IC connectivity, or the WLAN-BT coexistence interface."},{"content":"<bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph1\">\\_</ph>DIAGNOSTIC<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>BT<ph id=\"ph5\">\\_</ph>COEXISTENCE<ept id=\"p1\">**</ept> is only applicable if the WLAN and Bluetooth chips are on separate ICs.","pos":[2990,3112]},{"content":"If they are on the same module, this test is not supported and the miniport should return <bpt id=\"p1\">**</bpt>NDIS<ph id=\"ph1\">\\_</ph>STATUS<ph id=\"ph2\">\\_</ph>NOT<ph id=\"ph3\">\\_</ph>SUPPORTED<ept id=\"p1\">**</ept>.","pos":[3113,3236]},{"content":"When called, the driver should run the requested tests as defined in the <bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>SET<ph id=\"ph5\">\\_</ph>PARAMS<ept id=\"p1\">**</ept> structure and return success when the tests have been started.","pos":[3238,3423]},{"content":"On completion, whether the tests have succeeded or failed, the driver should indicate the test status by using the <bpt id=\"p1\">**</bpt>NDIS<ph id=\"ph1\">\\_</ph>STATUS<ph id=\"ph2\">\\_</ph>DOT11<ph id=\"ph3\">\\_</ph>MANUFACTURING<ph id=\"ph4\">\\_</ph>CALLBACK<ept id=\"p1\">**</ept> callback handler, with the <bpt id=\"p2\">*</bpt>dot11ManufacturingCallbackType<ept id=\"p2\">*</ept> set to <bpt id=\"p3\">**</bpt>dot11<ph id=\"ph5\">\\_</ph>manufacturing<ph id=\"ph6\">\\_</ph>callback<ph id=\"ph7\">\\_</ph>self<ph id=\"ph8\">\\_</ph>test<ph id=\"ph9\">\\_</ph>complete<ept id=\"p3\">**</ept> and the status describing the result of the test.","pos":[3424,3761]},{"content":"The driver will then call the <bpt id=\"p1\">**</bpt>OID<ph id=\"ph1\">\\_</ph>DOT11<ph id=\"ph2\">\\_</ph>MANUFACTURING<ph id=\"ph3\">\\_</ph>TEST<ept id=\"p1\">**</ept> oid with the <bpt id=\"p2\">**</bpt>dot11<ph id=\"ph4\">\\_</ph>manufacturing<ph id=\"ph5\">\\_</ph>test<ph id=\"ph6\">\\_</ph>self<ph id=\"ph7\">\\_</ph>query<ph id=\"ph8\">\\_</ph>result<ept id=\"p2\">**</ept> command to query the detailed result of the test.","pos":[3762,3942]},{"content":"SelfTestType","pos":[4367,4379]},{"content":"in<ph id=\"ph1\">\\]</ph> Specifies the type of self-test to be run by the driver.","pos":[4385,4446]},{"content":"The data type for this member is the <bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>TYPE<ept id=\"p1\">**</ept> enumeration with one of the following values:","pos":[4447,4572]},{"pos":[4692,4735],"content":"DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>INTERFACE"},{"content":"Control and data interface to WLAN","pos":[4744,4778]},{"content":"Clock request","pos":[4784,4797]},{"content":"Sleep clock","pos":[4803,4814]},{"content":"Interrupt and power supply lines","pos":[4820,4852]},{"content":"All related connections","pos":[4858,4881]},{"pos":[5007,5054],"content":"DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>RF<ph id=\"ph5\">\\_</ph>INTERFACE"},{"content":"Control and RF interface to FEM IC","pos":[5063,5097]},{"content":"FEM power supply","pos":[5103,5119]},{"content":"Transmit signal on loopback path from TX interface to RX interface and validate.","pos":[5125,5205]},{"pos":[5335,5384],"content":"DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>BT<ph id=\"ph5\">\\_</ph>COEXISTENCE"},{"content":"Set line states from Bluetooth side and read line states from WLAN side","pos":[5393,5464]},{"content":"Verify each pinâ€™s state","pos":[5470,5493]},{"content":"uTestID","pos":[5574,5581]},{"content":"in<ph id=\"ph1\">\\]</ph> ID of the test to be run.","pos":[5587,5617]},{"content":"uPinBitMask","pos":[5710,5721]},{"content":"in<ph id=\"ph1\">\\]</ph> Bit mask of pins to be tested.","pos":[5727,5762]},{"content":"pvContext","pos":[5849,5858]},{"content":"in<ph id=\"ph1\">\\]</ph> The context value to be returned to the application by using <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph2\">\\_</ph>manufacturing<ph id=\"ph3\">\\_</ph>callback<ph id=\"ph4\">\\_</ph>self<ph id=\"ph5\">\\_</ph>test<ph id=\"ph6\">\\_</ph>complete callback<ept id=\"p1\">**</ept> when the driver has completed the tests.","pos":[5864,6036]},{"content":"uBufferLength","pos":[6135,6148]},{"content":"in, optional<ph id=\"ph1\">\\]</ph> The length of the buffer containing additional input for the self-test.","pos":[6154,6240]},{"content":"ucBufferIn","pos":[6330,6340]},{"content":"in, optional<ph id=\"ph1\">\\]</ph> The buffer that contains additional input for the self-test.","pos":[6346,6421]},{"pos":[6548,6595],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>self<ph id=\"ph4\">\\_</ph>query<ph id=\"ph5\">\\_</ph>result"},{"content":"This command gets the results of a previously requested self-test.","pos":[6598,6664]},{"content":"It should only be called when the driver has indicated that the self-test is complete by using the <bpt id=\"p1\">**</bpt>NDIS<ph id=\"ph1\">\\_</ph>STATUS<ph id=\"ph2\">\\_</ph>DOT11<ph id=\"ph3\">\\_</ph>MANUFACTURING<ph id=\"ph4\">\\_</ph>CALLBACK<ept id=\"p1\">**</ept> with the <bpt id=\"p2\">*</bpt>dot11ManufacturingCallbackType<ept id=\"p2\">*</ept> set to <bpt id=\"p3\">**</bpt>dot11<ph id=\"ph5\">\\_</ph>manufacturing<ph id=\"ph6\">\\_</ph>callback<ph id=\"ph7\">\\_</ph>self<ph id=\"ph8\">\\_</ph>test<ph id=\"ph9\">\\_</ph>complete<ept id=\"p3\">**</ept> and the status describing the result of the test.","pos":[6665,6968]},{"content":"SelfTestType","pos":[7560,7572]},{"content":"in<ph id=\"ph1\">\\]</ph> Specifies the type of self-test whose result is being queried.","pos":[7578,7645]},{"content":"The data type for this member is the <bpt id=\"p1\">**</bpt>DOT11<ph id=\"ph1\">\\_</ph>MANUFACTURING<ph id=\"ph2\">\\_</ph>SELF<ph id=\"ph3\">\\_</ph>TEST<ph id=\"ph4\">\\_</ph>TYPE<ept id=\"p1\">**</ept> enumeration.","pos":[7646,7738]},{"content":"uTestID","pos":[7819,7826]},{"content":"in<ph id=\"ph1\">\\]</ph> ID of the test to be run.","pos":[7832,7862]},{"content":"bResult","pos":[7943,7950]},{"content":"out<ph id=\"ph1\">\\]</ph> The result of the test.","pos":[7956,7985]},{"content":"<bpt id=\"p1\">**</bpt>True<ept id=\"p1\">**</ept> if the test passed, <bpt id=\"p2\">**</bpt>False<ept id=\"p2\">**</ept> if it failed.","pos":[7986,8038]},{"content":"uPinFailedBitMask","pos":[8149,8166]},{"content":"out<ph id=\"ph1\">\\]</ph> The bit mask of any detected PIN faults.","pos":[8172,8218]},{"content":"pvContext","pos":[8305,8314]},{"content":"in<ph id=\"ph1\">\\]</ph> The context used when the driver indicated that the tests were complete.","pos":[8320,8397]},{"content":"uBytesWrittenOut","pos":[8505,8521]},{"content":"out<ph id=\"ph1\">\\]</ph> The length of the buffer that contains any additional returned output from the self-test.","pos":[8527,8622]},{"content":"ucBufferOut","pos":[8715,8726]},{"content":"in, out, optional<ph id=\"ph1\">\\]</ph> The buffer of length <bpt id=\"p1\">*</bpt>uBytesWrittenOut<ept id=\"p1\">*</ept> that contains additional output from the self-test.","pos":[8732,8843]},{"pos":[8940,8970],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>rx"},{"pos":[8973,9113],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>rx<ept id=\"p1\">**</ept> read-only command tests and verifies that there is connectivity between the antenna port and WLAN IC."},{"content":"To test this connectivity, a signal generator generates a non-modulated carrier wave (CW) at a certain frequency and power that will be measured and returned by the device under test (DUT).","pos":[9115,9304]},{"content":"If the band and/or channel setting are inconsistent, then the driver returns <bpt id=\"p1\">**</bpt>STATUS<ph id=\"ph1\">\\_</ph>INVALID<ph id=\"ph2\">\\_</ph>PARAMETER<ept id=\"p1\">**</ept>.","pos":[9305,9413]},{"content":"bEnabled","pos":[9745,9753]},{"content":"out<ph id=\"ph1\">\\]</ph> <bpt id=\"p1\">**</bpt>True<ept id=\"p1\">**</ept> if the driver detected a signal at the specified band and channel.","pos":[9759,9840]},{"content":"<bpt id=\"p1\">**</bpt>False<ept id=\"p1\">**</ept> if no signal was detected.","pos":[9841,9877]},{"content":"Dot11Band","pos":[9964,9973]},{"content":"in<ph id=\"ph1\">\\]</ph> The band on which the signal is to be detected.","pos":[9979,10031]},{"content":"uChannel","pos":[10115,10123]},{"content":"in<ph id=\"ph1\">\\]</ph> The channel on which the signal is to be detected.","pos":[10129,10184]},{"content":"The channel range depends on the band and supported PHYs.","pos":[10185,10242]},{"content":"PowerLevel","pos":[10332,10342]},{"content":"out<ph id=\"ph1\">\\]</ph> The power level of the received signal detected at the antenna, returned as the RSSI measured in dBm.","pos":[10348,10455]},{"content":"This is valid only if <bpt id=\"p1\">*</bpt>bEnabled<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>True<ept id=\"p2\">**</ept>.","pos":[10456,10501]},{"pos":[10598,10628],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>tx"},{"pos":[10631,10747],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>tx<ept id=\"p1\">**</ept> set-only command validates the connection from the chipset to the FEM output."},{"content":"To perform this test, a signal analyzer is physically connected to the antenna port and the DUT is requested to transmit a CW with specific band, channel, and power level settings.","pos":[10749,10929]},{"content":"The driver also measures its own ADC reading for the transmitted signal and returns it to the application.","pos":[10930,11036]},{"content":"bEnable","pos":[11416,11423]},{"content":"in<ph id=\"ph1\">\\]</ph> If set, this command enables transmission.","pos":[11429,11476]},{"content":"If not set, transmission at the specified band and channel are disabled.","pos":[11477,11549]},{"content":"bOpenLoop","pos":[11636,11645]},{"content":"in<ph id=\"ph1\">\\]</ph> If set to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>, this parameter indicates that the driver is requested to use an open loop power control and return the read signal value in <bpt id=\"p2\">*</bpt>ADCPowerLevel<ept id=\"p2\">*</ept>.","pos":[11651,11816]},{"content":"If set to <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept>, the driver will not use an open loop power control.","pos":[11817,11889]},{"pos":[11891,12023],"content":"If this value is set and the hardware does not support open loop power control, the driver returns <bpt id=\"p1\">**</bpt>NDIS<ph id=\"ph1\">\\_</ph>STATUS<ph id=\"ph2\">\\_</ph>NOT<ph id=\"ph3\">\\_</ph>SUPPORTED<ept id=\"p1\">**</ept>."},{"content":"Dot11Band","pos":[12110,12119]},{"content":"in<ph id=\"ph1\">\\]</ph> The band on which the signal is to be transmitted.","pos":[12125,12180]},{"content":"uChannel","pos":[12264,12272]},{"content":"in<ph id=\"ph1\">\\]</ph> The channel on which the signal is to be transmitted.","pos":[12278,12336]},{"content":"The channel range depends on the band and supported PHYs.","pos":[12337,12394]},{"content":"uSetPowerLevel","pos":[12496,12510]},{"content":"in<ph id=\"ph1\">\\]</ph> The power level of the transmitted signal.","pos":[12516,12563]},{"content":"This is returned as a percentage of the maximum possible power level.","pos":[12564,12633]},{"content":"ADCPowerLevel","pos":[12732,12745]},{"content":"out, optional<ph id=\"ph1\">\\]</ph> The current signal level detected at the antenna, returned as a RAW value.","pos":[12751,12841]},{"content":"The interpretation of this value is specified by the IHV.","pos":[12842,12899]},{"pos":[12901,12974],"content":"This must be set if <bpt id=\"p1\">*</bpt>bOpenLoop<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>True<ept id=\"p2\">**</ept> and the hardware supports it."},{"pos":[13083,13120],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>set<ph id=\"ph4\">\\_</ph>data"},{"pos":[13123,13247],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>set<ph id=\"ph4\">\\_</ph>data<ept id=\"p1\">**</ept> set-only command enables the application to write data at a specific location."},{"content":"uKey","pos":[13547,13551]},{"content":"in<ph id=\"ph1\">\\]</ph> The key is IHV specific and can be either a reference to a specific register or an entry from a named table.","pos":[13557,13670]},{"content":"uOffset","pos":[13751,13758]},{"content":"in<ph id=\"ph1\">\\]</ph> The offset within the data.","pos":[13764,13796]},{"content":"uBufferLength","pos":[13895,13908]},{"content":"in<ph id=\"ph1\">\\]</ph> The number of data bytes to be contained in the buffer of additional test data.","pos":[13914,13998]},{"content":"ucBufferIn","pos":[14087,14097]},{"content":"in<ph id=\"ph1\">\\]</ph> The buffer containing the additional test data of length <bpt id=\"p1\">*</bpt>uBufferLength<ept id=\"p1\">*</ept>.","pos":[14102,14180]},{"pos":[14293,14332],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>query<ph id=\"ph4\">\\_</ph>data"},{"pos":[14335,14451],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>query<ph id=\"ph4\">\\_</ph>data<ept id=\"p1\">**</ept> command enables the application to read data at a specific location."},{"content":"uKey","pos":[14780,14784]},{"content":"in<ph id=\"ph1\">\\]</ph> The key is IHV specific and can be either a reference to a specific register or an entry from a named table.","pos":[14790,14903]},{"content":"uOffset","pos":[14984,14991]},{"content":"in<ph id=\"ph1\">\\]</ph> The offset within the data.","pos":[14997,15029]},{"content":"uBufferLength","pos":[15128,15141]},{"content":"in<ph id=\"ph1\">\\]</ph> The number of data bytes to be read in the buffer.","pos":[15147,15202]},{"content":"uBytesRead","pos":[15291,15301]},{"content":"out<ph id=\"ph1\">\\]</ph> The actual number of data bytes read by the driver.","pos":[15306,15363]},{"content":"ucBufferOut","pos":[15455,15466]},{"content":"out<ph id=\"ph1\">\\]</ph> Contains the data read by the driver.","pos":[15471,15514]},{"pos":[15617,15650],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>sleep"},{"pos":[15653,15810],"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>sleep<ept id=\"p1\">**</ept> command instructs the Wi-Fi chipset to go into its lowest power state, for either a specified time or indefinitely."},{"content":"For this test, all radios should be turned off and the Wi-Fi chipset should be powered off.","pos":[15812,15903]},{"content":"The test verifies that Wi-Fi can enter the sleep state, that the current consumption is within the specified limits, and that there is no current drawn when Wi-Fi is switched off.","pos":[15904,16083]},{"content":"The driver can be awakened from the sleep state at any time by using the <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>awake<ept id=\"p1\">**</ept> command.","pos":[16085,16204]},{"content":"If the sleep time-out is set to âˆ’1, the driver should sleep indefinitely unless asked to wake up by using <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>awake<ept id=\"p1\">**</ept>.","pos":[16205,16349]},{"content":"When the driver wakes up, either due to the time-out expiring or as a result of the awake command, it should indicate its awake status by using the <bpt id=\"p1\">**</bpt>NDIS<ph id=\"ph1\">\\_</ph>STATUS<ph id=\"ph2\">\\_</ph>DOT11<ph id=\"ph3\">\\_</ph>MANUFACTURING<ph id=\"ph4\">\\_</ph>CALLBACK<ept id=\"p1\">**</ept> callback handler with the <bpt id=\"p2\">*</bpt>dot11ManufacturingCallbackType<ept id=\"p2\">*</ept> set to <bpt id=\"p3\">**</bpt>dot11<ph id=\"ph5\">\\_</ph>manufacturing<ph id=\"ph6\">\\_</ph>callback<ph id=\"ph7\">\\_</ph>sleep<ph id=\"ph8\">\\_</ph>complete<ept id=\"p3\">**</ept>.","pos":[16350,16665]},{"content":"uSleepTime","pos":[16932,16942]},{"content":"in<ph id=\"ph1\">\\]</ph> The amount of time for the driver to sleep, in milliseconds.","pos":[16948,17013]},{"content":"If set to âˆ’1, the driver enters sleep state until awakened by using the <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>awake<ept id=\"p1\">**</ept> command.","pos":[17014,17132]},{"content":"pvContext","pos":[17219,17228]},{"content":"in<ph id=\"ph1\">\\]</ph> The context used when the driver returns the test completion state to the application by using <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph2\">\\_</ph>manufacturing<ph id=\"ph3\">\\_</ph>callback<ph id=\"ph4\">\\_</ph>sleep<ph id=\"ph5\">\\_</ph>complete<ept id=\"p1\">**</ept>.","pos":[17234,17386]},{"pos":[17489,17522],"content":"dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>awake"},{"content":"The <bpt id=\"p1\">**</bpt>dot11<ph id=\"ph1\">\\_</ph>manufacturing<ph id=\"ph2\">\\_</ph>test<ph id=\"ph3\">\\_</ph>awake<ept id=\"p1\">**</ept> command causes the Wi-Fi chipset to wake up from its lowest-power sleep state.","pos":[17525,17645]},{"content":"The driver returns <bpt id=\"p1\">**</bpt>STATUS<ph id=\"ph1\">\\_</ph>INVALID<ph id=\"ph2\">\\_</ph>PARAMETER<ept id=\"p1\">**</ept> if this command is sent when the chipset is already awake.","pos":[17646,17754]},{"pos":[17792,17806],"content":"Related topics"},{"content":"Adding Wi-Fi manufacturing test support to the OID interface","pos":[17810,17870]}],"content":"---\nauthor: kpacquer\nDescription: Supporting new OID commands for manufacturing mode\nms.assetid: 0ebb9581-043e-47f8-84c9-6fa97c0900cc\nMSHAttr: 'PreferredLib:/library/windows/hardware'\ntitle: Supporting new OID commands for manufacturing mode\n---\n\n# Supporting new OID commands for manufacturing mode\n\n\nWhen running in manufacturing mode, Wi-Fi miniport drivers must add support for the following new OID commands. The driver should ensure that the device is currently in manufacturing mode prior to calling any of these commands. For more info, see [Determine if MMOS is running](determine-if-mmos-is-running.md). Some of the parameters specified in the API may be IHV-specific.\n\n## <span id=\"OID_DOT11_MANUFACTURING_TEST\"></span><span id=\"oid_dot11_manufacturing_test\"></span>OID\\_DOT11\\_MANUFACTURING\\_TEST\n\n\nOID\\_DOT11\\_MANUFACTURING\\_TEST is called as a method request in the driver to perform a specific test. This OID should never be used during normal operation.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_TEST {\n    DOT11_MANUFACTURING_TEST_TYPE dot11ManufacturingTestType;\n    ULONG uBufferLength;\n    UCHAR ucBuffer[1];\n} DOT11_MANUFACTURING_TEST, * PDOT11_MANUFACTURING_TEST;\n```\n\n<span id=\"dot11ManufacturingTestType\"></span><span id=\"dot11manufacturingtesttype\"></span><span id=\"DOT11MANUFACTURINGTESTTYPE\"></span>*dot11ManufacturingTestType*  \n\\[in\\] Specifies the manufacturing test to be run. The data type for this member is one of the values of the **DOT11\\_MANUFACTURING\\_TEST\\_TYPE** enumeration.\n\nThe DOT11 manufacturing test type enumeration is defined as follows:\n\n``` syntax\ntypedef enum _DOT11_MANUFACTURING_TEST_TYPE {\n    dot11_manufacturing_test_unknown = 0,\n    dot11_manufacturing_test_self_start = 1,\n    dot11_manufacturing_test_self_query_result = 2,\n    dot11_manufacturing_test_rx = 3,\n    dot11_manufacturing_test_tx = 4,\n    dot11_manufacturing_test_set_data = 5,\n    dot11_manufacturing_test_query_data = 6,\n    dot11_manufacturing_test_sleep = 7,\n    dot11_manufacturing_test_awake = 8,\n    dot11_manufacturing_test_IHV_start = 0x80000000,\n    dot11_manufacturing_test_IHV_end = 0xffffffff\n} DOT11_MANUFACTURING_TEST_TYPE, * PDOT11_MANUFACTURING_TEST_TYPE;\n```\n\n<span id=\"uBufferLength\"></span><span id=\"ubufferlength\"></span><span id=\"UBUFFERLENGTH\"></span>*uBufferLength*  \n\\[in\\] The length, in bytes, of the **DOT11\\_MANUFACTURING\\_TEST** structure and any additional data specific to the test appended at the end.\n\n<span id=\"ucBuffer\"></span><span id=\"ucbuffer\"></span><span id=\"UCBUFFER\"></span>*ucBuffer*  \n\\[in\\] The buffer containing optional data as specified by the **dot11DiagnosticsTestType** member.\n\n## <span id=\"dot11_manufacturing_test_self_start\"></span><span id=\"DOT11_MANUFACTURING_TEST_SELF_START\"></span>dot11\\_manufacturing\\_test\\_self\\_start\n\n\nThe **dot11\\_manufacturing\\_test\\_self\\_start** command is called to request the driver to test WLAN IC connectivity, FEM IC connectivity, or the WLAN-BT coexistence interface.\n\n**DOT11\\_DIAGNOSTIC\\_SELF\\_TEST\\_BT\\_COEXISTENCE** is only applicable if the WLAN and Bluetooth chips are on separate ICs. If they are on the same module, this test is not supported and the miniport should return **NDIS\\_STATUS\\_NOT\\_SUPPORTED**.\n\nWhen called, the driver should run the requested tests as defined in the **DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_SET\\_PARAMS** structure and return success when the tests have been started. On completion, whether the tests have succeeded or failed, the driver should indicate the test status by using the **NDIS\\_STATUS\\_DOT11\\_MANUFACTURING\\_CALLBACK** callback handler, with the *dot11ManufacturingCallbackType* set to **dot11\\_manufacturing\\_callback\\_self\\_test\\_complete** and the status describing the result of the test. The driver will then call the **OID\\_DOT11\\_MANUFACTURING\\_TEST** oid with the **dot11\\_manufacturing\\_test\\_self\\_query\\_result** command to query the detailed result of the test.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_SELF_TEST_SET_PARAMS {\n    DOT11_MANUFACTURING_SELF_TEST_TYPE SelfTestType;\n    ULONG uTestID;\n    ULONG uPinBitMask;\n    PVOID pvContext;\n    ULONG uBufferLength;\n    UCHAR ucBufferIn[1];\n} DOT11_MANUFACTURING_SELF_TEST_SET_PARAMS, *PDOT11_MANUFACTURING_SELF_TEST_SET_PARAMS;\n```\n\n<span id=\"SelfTestType\"></span><span id=\"selftesttype\"></span><span id=\"SELFTESTTYPE\"></span>*SelfTestType*  \n\\[in\\] Specifies the type of self-test to be run by the driver. The data type for this member is the **DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_TYPE** enumeration with one of the following values:\n\n<span id=\"DOT11_MANUFACTURING_SELF_TEST_INTERFACE\"></span><span id=\"dot11_manufacturing_self_test_interface\"></span>**DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_INTERFACE**  \n-   Control and data interface to WLAN\n\n-   Clock request\n\n-   Sleep clock\n\n-   Interrupt and power supply lines\n\n-   All related connections\n\n<span id=\"DOT11_MANUFACTURING_SELF_TEST_RF_INTERFACE\"></span><span id=\"dot11_manufacturing_self_test_rf_interface\"></span>**DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_RF\\_INTERFACE**  \n-   Control and RF interface to FEM IC\n\n-   FEM power supply\n\n-   Transmit signal on loopback path from TX interface to RX interface and validate.\n\n<span id=\"DOT11_MANUFACTURING_SELF_TEST_BT_COEXISTENCE\"></span><span id=\"dot11_manufacturing_self_test_bt_coexistence\"></span>**DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_BT\\_COEXISTENCE**  \n-   Set line states from Bluetooth side and read line states from WLAN side\n\n-   Verify each pinâ€™s state\n\n<span id=\"uTestID\"></span><span id=\"utestid\"></span><span id=\"UTESTID\"></span>*uTestID*  \n\\[in\\] ID of the test to be run.\n\n<span id=\"uPinBitMask\"></span><span id=\"upinbitmask\"></span><span id=\"UPINBITMASK\"></span>*uPinBitMask*  \n\\[in\\] Bit mask of pins to be tested.\n\n<span id=\"pvContext\"></span><span id=\"pvcontext\"></span><span id=\"PVCONTEXT\"></span>*pvContext*  \n\\[in\\] The context value to be returned to the application by using **dot11\\_manufacturing\\_callback\\_self\\_test\\_complete callback** when the driver has completed the tests.\n\n<span id=\"uBufferLength\"></span><span id=\"ubufferlength\"></span><span id=\"UBUFFERLENGTH\"></span>*uBufferLength*  \n\\[in, optional\\] The length of the buffer containing additional input for the self-test.\n\n<span id=\"ucBufferIn\"></span><span id=\"ucbufferin\"></span><span id=\"UCBUFFERIN\"></span>*ucBufferIn*  \n\\[in, optional\\] The buffer that contains additional input for the self-test.\n\n## <span id=\"dot11_manufacturing_test_self_query_result\"></span><span id=\"DOT11_MANUFACTURING_TEST_SELF_QUERY_RESULT\"></span>dot11\\_manufacturing\\_test\\_self\\_query\\_result\n\n\nThis command gets the results of a previously requested self-test. It should only be called when the driver has indicated that the self-test is complete by using the **NDIS\\_STATUS\\_DOT11\\_MANUFACTURING\\_CALLBACK** with the *dot11ManufacturingCallbackType* set to **dot11\\_manufacturing\\_callback\\_self\\_test\\_complete** and the status describing the result of the test.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_SELF_TEST_QUERY_RESULTS {\n    DOT11_MANUFACTURING_SELF_TEST_TYPE SelfTestType;\n    ULONG uTestID;\n    BOOLEAN bResult;                    // PASS/FAIL\n    ULONG uPinFailedBitMask;            // Detected PIN faults\n    PVOID pvContext;\n    ULONG uBytesWrittenOut;\n    UCHAR ucBufferOut[1];               // Additional output from self-test (optional)\n} DOT11_MANUFACTURING_SELF_TEST_QUERY_RESULTS, *PDOT11_MANUFACTURING_SELF_TEST_QUERY_RESULTS;\n```\n\n<span id=\"SelfTestType\"></span><span id=\"selftesttype\"></span><span id=\"SELFTESTTYPE\"></span>*SelfTestType*  \n\\[in\\] Specifies the type of self-test whose result is being queried. The data type for this member is the **DOT11\\_MANUFACTURING\\_SELF\\_TEST\\_TYPE** enumeration.\n\n<span id=\"uTestID\"></span><span id=\"utestid\"></span><span id=\"UTESTID\"></span>*uTestID*  \n\\[in\\] ID of the test to be run.\n\n<span id=\"bResult\"></span><span id=\"bresult\"></span><span id=\"BRESULT\"></span>*bResult*  \n\\[out\\] The result of the test. **True** if the test passed, **False** if it failed.\n\n<span id=\"uPinFailedBitMask\"></span><span id=\"upinfailedbitmask\"></span><span id=\"UPINFAILEDBITMASK\"></span>*uPinFailedBitMask*  \n\\[out\\] The bit mask of any detected PIN faults.\n\n<span id=\"pvContext\"></span><span id=\"pvcontext\"></span><span id=\"PVCONTEXT\"></span>*pvContext*  \n\\[in\\] The context used when the driver indicated that the tests were complete.\n\n<span id=\"uBytesWrittenOut\"></span><span id=\"ubyteswrittenout\"></span><span id=\"UBYTESWRITTENOUT\"></span>*uBytesWrittenOut*  \n\\[out\\] The length of the buffer that contains any additional returned output from the self-test.\n\n<span id=\"ucBufferOut\"></span><span id=\"ucbufferout\"></span><span id=\"UCBUFFEROUT\"></span>*ucBufferOut*  \n\\[in, out, optional\\] The buffer of length *uBytesWrittenOut* that contains additional output from the self-test.\n\n## <span id=\"dot11_manufacturing_test_rx\"></span><span id=\"DOT11_MANUFACTURING_TEST_RX\"></span>dot11\\_manufacturing\\_test\\_rx\n\n\nThe **dot11\\_manufacturing\\_test\\_rx** read-only command tests and verifies that there is connectivity between the antenna port and WLAN IC.\n\nTo test this connectivity, a signal generator generates a non-modulated carrier wave (CW) at a certain frequency and power that will be measured and returned by the device under test (DUT). If the band and/or channel setting are inconsistent, then the driver returns **STATUS\\_INVALID\\_PARAMETER**.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_FUNCTIONAL_TEST_RX {\n    BOOLEAN bEnabled;\n    DOT11_BAND Dot11Band;\n    ULONG uChannel;\n    LONG  PowerLevel;\n} DOT11_MANUFACTURING_FUNCTIONAL_TEST_RX, * PDOT11_MANUFACTURING_FUNCTIONAL_TEST_RX;\n```\n\n<span id=\"bEnabled\"></span><span id=\"benabled\"></span><span id=\"BENABLED\"></span>*bEnabled*  \n\\[out\\] **True** if the driver detected a signal at the specified band and channel. **False** if no signal was detected.\n\n<span id=\"Dot11Band\"></span><span id=\"dot11band\"></span><span id=\"DOT11BAND\"></span>*Dot11Band*  \n\\[in\\] The band on which the signal is to be detected.\n\n<span id=\"uChannel\"></span><span id=\"uchannel\"></span><span id=\"UCHANNEL\"></span>*uChannel*  \n\\[in\\] The channel on which the signal is to be detected. The channel range depends on the band and supported PHYs.\n\n<span id=\"PowerLevel\"></span><span id=\"powerlevel\"></span><span id=\"POWERLEVEL\"></span>*PowerLevel*  \n\\[out\\] The power level of the received signal detected at the antenna, returned as the RSSI measured in dBm. This is valid only if *bEnabled* is **True**.\n\n## <span id=\"dot11_manufacturing_test_tx\"></span><span id=\"DOT11_MANUFACTURING_TEST_TX\"></span>dot11\\_manufacturing\\_test\\_tx\n\n\nThe **dot11\\_manufacturing\\_test\\_tx** set-only command validates the connection from the chipset to the FEM output.\n\nTo perform this test, a signal analyzer is physically connected to the antenna port and the DUT is requested to transmit a CW with specific band, channel, and power level settings. The driver also measures its own ADC reading for the transmitted signal and returns it to the application.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_FUNCTIONAL_TEST_TX {\n    BOOLEAN bEnable;\n    BOOLEAN bOpenLoop;\n    DOT11_BAND Dot11Band;\n    ULONG uChannel;\n    ULONG uSetPowerLevel;\n    LONG  ADCPowerLevel;\n} DOT11_MANUFACTURING_FUNCTIONAL_TEST_TX, * PDOT11_MANUFACTURING_FUNCTIONAL_TEST_TX;\n```\n\n<span id=\"bEnable\"></span><span id=\"benable\"></span><span id=\"BENABLE\"></span>*bEnable*  \n\\[in\\] If set, this command enables transmission. If not set, transmission at the specified band and channel are disabled.\n\n<span id=\"bOpenLoop\"></span><span id=\"bopenloop\"></span><span id=\"BOPENLOOP\"></span>*bOpenLoop*  \n\\[in\\] If set to **true**, this parameter indicates that the driver is requested to use an open loop power control and return the read signal value in *ADCPowerLevel*. If set to **false**, the driver will not use an open loop power control.\n\nIf this value is set and the hardware does not support open loop power control, the driver returns **NDIS\\_STATUS\\_NOT\\_SUPPORTED**.\n\n<span id=\"Dot11Band\"></span><span id=\"dot11band\"></span><span id=\"DOT11BAND\"></span>*Dot11Band*  \n\\[in\\] The band on which the signal is to be transmitted.\n\n<span id=\"uChannel\"></span><span id=\"uchannel\"></span><span id=\"UCHANNEL\"></span>*uChannel*  \n\\[in\\] The channel on which the signal is to be transmitted. The channel range depends on the band and supported PHYs.\n\n<span id=\"uSetPowerLevel\"></span><span id=\"usetpowerlevel\"></span><span id=\"USETPOWERLEVEL\"></span>*uSetPowerLevel*  \n\\[in\\] The power level of the transmitted signal. This is returned as a percentage of the maximum possible power level.\n\n<span id=\"ADCPowerLevel\"></span><span id=\"adcpowerlevel\"></span><span id=\"ADCPOWERLEVEL\"></span>*ADCPowerLevel*  \n\\[out, optional\\] The current signal level detected at the antenna, returned as a RAW value. The interpretation of this value is specified by the IHV.\n\nThis must be set if *bOpenLoop* is **True** and the hardware supports it.\n\n## <span id=\"dot11_manufacturing_test_set_data\"></span><span id=\"DOT11_MANUFACTURING_TEST_SET_DATA\"></span>dot11\\_manufacturing\\_test\\_set\\_data\n\n\nThe **dot11\\_manufacturing\\_test\\_set\\_data** set-only command enables the application to write data at a specific location.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_TEST_SET_DATA {\n    ULONG uKey;\n    ULONG uOffset;\n    ULONG uBufferLength;\n    UCHAR ucBufferIn[1];\n} DOT11_MANUFACTURING_TEST_SET_DATA, * PDOT11_MANUFACTURING_TEST_SET_DATA;\n```\n\n<span id=\"uKey\"></span><span id=\"ukey\"></span><span id=\"UKEY\"></span>*uKey*  \n\\[in\\] The key is IHV specific and can be either a reference to a specific register or an entry from a named table.\n\n<span id=\"uOffset\"></span><span id=\"uoffset\"></span><span id=\"UOFFSET\"></span>*uOffset*  \n\\[in\\] The offset within the data.\n\n<span id=\"uBufferLength\"></span><span id=\"ubufferlength\"></span><span id=\"UBUFFERLENGTH\"></span>*uBufferLength*  \n\\[in\\] The number of data bytes to be contained in the buffer of additional test data.\n\n<span id=\"ucBufferIn\"></span><span id=\"ucbufferin\"></span><span id=\"UCBUFFERIN\"></span>ucBufferIn  \n\\[in\\] The buffer containing the additional test data of length *uBufferLength*.\n\n## <span id=\"dot11_manufacturing_test_query_data\"></span><span id=\"DOT11_MANUFACTURING_TEST_QUERY_DATA\"></span>dot11\\_manufacturing\\_test\\_query\\_data\n\n\nThe **dot11\\_manufacturing\\_test\\_query\\_data** command enables the application to read data at a specific location.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_TEST_QUERY_DATA {\n    ULONG uKey;\n    ULONG uOffset;\n    ULONG uBufferLength;\n    ULONG uBytesRead;\n    UCHAR ucBufferOut[1];\n} DOT11_MANUFACTURING_TEST_QUERY_DATA, * PDOT11_MANUFACTURING_TEST_QUERY_DATA;\n```\n\n<span id=\"uKey\"></span><span id=\"ukey\"></span><span id=\"UKEY\"></span>*uKey*  \n\\[in\\] The key is IHV specific and can be either a reference to a specific register or an entry from a named table.\n\n<span id=\"uOffset\"></span><span id=\"uoffset\"></span><span id=\"UOFFSET\"></span>*uOffset*  \n\\[in\\] The offset within the data.\n\n<span id=\"uBufferLength\"></span><span id=\"ubufferlength\"></span><span id=\"UBUFFERLENGTH\"></span>*uBufferLength*  \n\\[in\\] The number of data bytes to be read in the buffer.\n\n<span id=\"uBytesRead\"></span><span id=\"ubytesread\"></span><span id=\"UBYTESREAD\"></span>uBytesRead  \n\\[out\\] The actual number of data bytes read by the driver.\n\n<span id=\"ucBufferOut\"></span><span id=\"ucbufferout\"></span><span id=\"UCBUFFEROUT\"></span>ucBufferOut  \n\\[out\\] Contains the data read by the driver.\n\n## <span id=\"dot11_manufacturing_test_sleep\"></span><span id=\"DOT11_MANUFACTURING_TEST_SLEEP\"></span>dot11\\_manufacturing\\_test\\_sleep\n\n\nThe **dot11\\_manufacturing\\_test\\_sleep** command instructs the Wi-Fi chipset to go into its lowest power state, for either a specified time or indefinitely.\n\nFor this test, all radios should be turned off and the Wi-Fi chipset should be powered off. The test verifies that Wi-Fi can enter the sleep state, that the current consumption is within the specified limits, and that there is no current drawn when Wi-Fi is switched off.\n\nThe driver can be awakened from the sleep state at any time by using the **dot11\\_manufacturing\\_test\\_awake** command. If the sleep time-out is set to âˆ’1, the driver should sleep indefinitely unless asked to wake up by using **dot11\\_manufacturing\\_test\\_awake**. When the driver wakes up, either due to the time-out expiring or as a result of the awake command, it should indicate its awake status by using the **NDIS\\_STATUS\\_DOT11\\_MANUFACTURING\\_CALLBACK** callback handler with the *dot11ManufacturingCallbackType* set to **dot11\\_manufacturing\\_callback\\_sleep\\_complete**.\n\n``` syntax\ntypedef struct _DOT11_MANUFACTURING_TEST_SLEEP {\n    ULONG uSleepTime;\n    PVOID pvContext;\n} DOT11_MANUFACTURING_TEST_SLEEP, * PDOT11_MANUFACTURING_TEST_SLEEP;\n```\n\n<span id=\"uSleepTime\"></span><span id=\"usleeptime\"></span><span id=\"USLEEPTIME\"></span>*uSleepTime*  \n\\[in\\] The amount of time for the driver to sleep, in milliseconds. If set to âˆ’1, the driver enters sleep state until awakened by using the **dot11\\_manufacturing\\_test\\_awake** command.\n\n<span id=\"pvContext\"></span><span id=\"pvcontext\"></span><span id=\"PVCONTEXT\"></span>*pvContext*  \n\\[in\\] The context used when the driver returns the test completion state to the application by using **dot11\\_manufacturing\\_callback\\_sleep\\_complete**.\n\n## <span id=\"dot11_manufacturing_test_awake\"></span><span id=\"DOT11_MANUFACTURING_TEST_AWAKE\"></span>dot11\\_manufacturing\\_test\\_awake\n\n\nThe **dot11\\_manufacturing\\_test\\_awake** command causes the Wi-Fi chipset to wake up from its lowest-power sleep state. The driver returns **STATUS\\_INVALID\\_PARAMETER** if this command is sent when the chipset is already awake.\n\n## <span id=\"related_topics\"></span>Related topics\n\n\n[Adding Wi-Fi manufacturing test support to the OID interface](adding-wi-fi-manufacturing-test-support-to-the-oid-interface.md)\n\n \n\n \n\n\n\n\n\n\n"}