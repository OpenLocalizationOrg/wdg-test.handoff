<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationtype">Human Translation</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">docset\manufacture\desktop\uefi-requirements-boot-time-runtime-hibernation-state--s4.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">1ee8005190bfb515bbeb98f6a1f5e16144d7be66</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-48076a9</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</source>
          <target>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</source>
          <target>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</source>
          <target>UEFI Requirements: Boot time, Runtime, Hibernation State (S4)</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>This section describes UEFI and firmware requirements, including:</source>
          <target>This section describes UEFI and firmware requirements, including:</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>Boot time requirements</source>
          <target>Boot time requirements</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Runtime requirements</source>
          <target>Runtime requirements</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>Hibernation State (S4) requirements</source>
          <target>Hibernation State (S4) requirements</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>Requirements to Enable UEFI Platforms without CSM</source>
          <target>Requirements to Enable UEFI Platforms without CSM</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>Boot time requirements</source>
          <target>Boot time requirements</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>This section describes UEFI boot time requirements.</source>
          <target>This section describes UEFI boot time requirements.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>Display at Boot Time</source>
          <target>Display at Boot Time</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>For a platform that has a console device, the UEFI 2.0 specification requires the firmware to implement the Simple Text Output Protocol.</source>
          <target>For a platform that has a console device, the UEFI 2.0 specification requires the firmware to implement the Simple Text Output Protocol.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>Optionally, the firmware can also support a graphical protocol.</source>
          <target>Optionally, the firmware can also support a graphical protocol.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>UEFI 2.0 defines the Graphic Output Protocol (GOP), and EFI 1.1 defines the Universal Graphics Adapter (UGA) Protocol.</source>
          <target>UEFI 2.0 defines the Graphic Output Protocol (GOP), and EFI 1.1 defines the Universal Graphics Adapter (UGA) Protocol.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>Windows supports all three protocols, but the user experience with each protocol is different.</source>
          <target>Windows supports all three protocols, but the user experience with each protocol is different.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>For the best experience, if the firmware implements a graphical protocol, Windows recommends and prefers the GOP.</source>
          <target>For the best experience, if the firmware implements a graphical protocol, Windows recommends and prefers the GOP.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>Windows requires a graphical protocol to render glyphs for non-English message resources.</source>
          <target>Windows requires a graphical protocol to render glyphs for non-English message resources.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>To do so, the firmware must support the following:</source>
          <target>To do so, the firmware must support the following:</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>A graphical protocol—either GOP or UGA.</source>
          <target>A graphical protocol—either GOP or UGA.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Either 1024x768 display resolution with 32-bit pixel color or 800x600 display resolution with 24-bit pixel color.</source>
          <target>Either 1024x768 display resolution with 32-bit pixel color or 800x600 display resolution with 24-bit pixel color.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>If the firmware does not support any of these graphics modes, Windows still functions, but all boot display reverts to text mode and English.</source>
          <target>If the firmware does not support any of these graphics modes, Windows still functions, but all boot display reverts to text mode and English.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Windows 8.1, Windows Server 2012 R2, Windows 7, Windows Server 2008 R2, and Windows Server 2008 require GOP to display a high-resolution, animated image during boot.</source>
          <target>Windows 8.1, Windows Server 2012 R2, Windows 7, Windows Server 2008 R2, and Windows Server 2008 require GOP to display a high-resolution, animated image during boot.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>If GOP is not available, Windows uses the video graphics array (VGA) standard to display a lower resolution image and a simple progress indicator.</source>
          <target>If GOP is not available, Windows uses the video graphics array (VGA) standard to display a lower resolution image and a simple progress indicator.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>For an optimal boot experience with these versions of Windows, sealed platforms without expansion card slots can safely boot with graphics mode enabled and eliminate transitions to text mode.</source>
          <target>For an optimal boot experience with these versions of Windows, sealed platforms without expansion card slots can safely boot with graphics mode enabled and eliminate transitions to text mode.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>Whenever the firmware boot manager hands off execution to a Windows EFI application, platform firmware and the firmware boot manager must not use the frame buffer for any purpose.</source>
          <target>Whenever the firmware boot manager hands off execution to a Windows EFI application, platform firmware and the firmware boot manager must not use the frame buffer for any purpose.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>Input at Boot Time</source>
          <target>Input at Boot Time</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>For a platform that has a console device, the UEFI 2.0 specification requires the firmware to implement the Simple Input Protocol.</source>
          <target>For a platform that has a console device, the UEFI 2.0 specification requires the firmware to implement the Simple Input Protocol.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Windows supports this protocol for local keyboard input during boot.</source>
          <target>Windows supports this protocol for local keyboard input during boot.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>Network Boot</source>
          <target>Network Boot</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Windows implements support for the EFI Preboot eXecution Environment (PXE) Base Code Protocol.</source>
          <target>Windows implements support for the EFI Preboot eXecution Environment (PXE) Base Code Protocol.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>Windows uses this protocol to boot over the network and support Windows Deployment Services (WDS).</source>
          <target>Windows uses this protocol to boot over the network and support Windows Deployment Services (WDS).</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Disk Boot</source>
          <target>Disk Boot</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Windows requires Block I/O Protocol and Device Path Protocol support for the disk that contains the EFI system partition and the Windows OS partition.</source>
          <target>Windows requires Block I/O Protocol and Device Path Protocol support for the disk that contains the EFI system partition and the Windows OS partition.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Other Firmware Boot Requirements</source>
          <target>Other Firmware Boot Requirements</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>To ensure proper operation, Windows requires EFI firmware to comply with its indicated specification version.</source>
          <target>To ensure proper operation, Windows requires EFI firmware to comply with its indicated specification version.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>EFI firmware must fully implement the appropriate version of the EFI System Table, EFI Boot Services, and EFI Runtime Services.</source>
          <target>EFI firmware must fully implement the appropriate version of the EFI System Table, EFI Boot Services, and EFI Runtime Services.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Other specific required protocols and specifications include the following:</source>
          <target>Other specific required protocols and specifications include the following:</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Trusted Computing Group (TCG) EFI Specifications</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Trusted Computing Group (TCG) EFI Specifications</pc>.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>All UEFI platforms that have a Trusted Platform Module (TPM) must implement the TCG EFI Platform and Protocol specifications.</source>
          <target>All UEFI platforms that have a Trusted Platform Module (TPM) must implement the TCG EFI Platform and Protocol specifications.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
          <data id="id7">\_</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />PCI<ph dataRef="id4" id="ph2" />ROOT<ph dataRef="id5" id="ph3" />BRIDGE<ph dataRef="id6" id="ph4" />IO<ph dataRef="id7" id="ph5" />PROTOCOL</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />PCI<ph dataRef="id4" id="ph2" />ROOT<ph dataRef="id5" id="ph3" />BRIDGE<ph dataRef="id6" id="ph4" />IO<ph dataRef="id7" id="ph5" />PROTOCOL</pc>.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Windows uses this protocol if Windows Boot Configuration Data (BCD) specifies IEEE 1394 boot debugging.</source>
          <target>Windows uses this protocol if Windows Boot Configuration Data (BCD) specifies IEEE 1394 boot debugging.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Runtime Requirements</source>
          <target>Runtime Requirements</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>Windows minimizes its use of UEFI services during operating system runtime and, wherever possible, relies on runtime firmware such as ACPI and Windows drivers.</source>
          <target>Windows minimizes its use of UEFI services during operating system runtime and, wherever possible, relies on runtime firmware such as ACPI and Windows drivers.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Windows uses the following UEFI Runtime Services to manage NVRAM boot entries and hardware error records after ExitBootServices() is called.</source>
          <target>Windows uses the following UEFI Runtime Services to manage NVRAM boot entries and hardware error records after ExitBootServices() is called.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>GetVariable</source>
          <target>GetVariable</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>GetNextVariableName</source>
          <target>GetNextVariableName</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>SetVariable</source>
          <target>SetVariable</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>QueryVariableInfo</source>
          <target>QueryVariableInfo</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Hibernation State (S4) Transition Requirements</source>
          <target>Hibernation State (S4) Transition Requirements</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>This section describes requirements for system and firmware memory that are related to transitions to the hibernation power state (S4).</source>
          <target>This section describes requirements for system and firmware memory that are related to transitions to the hibernation power state (S4).</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>System Memory Requirements</source>
          <target>System Memory Requirements</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>Platform firmware must ensure that operating system physical memory is consistent across S4 sleep state transitions, in both size and location.</source>
          <target>Platform firmware must ensure that operating system physical memory is consistent across S4 sleep state transitions, in both size and location.</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\[</data>
          <data id="id4">\]</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">\[</data>
          <data id="id8">\]</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">\[</data>
          <data id="id12">\]</data>
        </originalData>
        <segment state="initial">
          <source>Operating system physical memory is defined according to the ACPI 3.0 specification as any memory that is described by the firmware system address map interface with a memory type other than <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddressRangeReserved</pc><ph dataRef="id3" id="ph1" />2<ph dataRef="id4" id="ph2" />, <pc dataRefEnd="id6" dataRefStart="id5" id="p2">AddressRangeUnusable</pc><ph dataRef="id7" id="ph3" />5<ph dataRef="id8" id="ph4" />, or <pc dataRefEnd="id10" dataRefStart="id9" id="p3">Undefined</pc><ph dataRef="id11" id="ph5" />any value greater than 5<ph dataRef="id12" id="ph6" />.</source>
          <target>Operating system physical memory is defined according to the ACPI 3.0 specification as any memory that is described by the firmware system address map interface with a memory type other than <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddressRangeReserved</pc><ph dataRef="id3" id="ph1" />2<ph dataRef="id4" id="ph2" />, <pc dataRefEnd="id6" dataRefStart="id5" id="p2">AddressRangeUnusable</pc><ph dataRef="id7" id="ph3" />5<ph dataRef="id8" id="ph4" />, or <pc dataRefEnd="id10" dataRefStart="id9" id="p3">Undefined</pc><ph dataRef="id11" id="ph5" />any value greater than 5<ph dataRef="id12" id="ph6" />.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>Firmware Memory Requirements</source>
          <target>Firmware Memory Requirements</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>On a UEFI platform, firmware runtime memory must be consistent across S4 sleep state transitions, in both size and location.</source>
          <target>On a UEFI platform, firmware runtime memory must be consistent across S4 sleep state transitions, in both size and location.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
        </originalData>
        <segment state="initial">
          <source>Runtime memory is defined according to the UEFI specification as any memory that is described by the GetMemoryMap() boot service, with the attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />MEMORY<ph dataRef="id4" id="ph2" />RUNTIME</pc>.</source>
          <target>Runtime memory is defined according to the UEFI specification as any memory that is described by the GetMemoryMap() boot service, with the attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />MEMORY<ph dataRef="id4" id="ph2" />RUNTIME</pc>.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Requirements to Enable UEFI Platforms without CSM</source>
          <target>Requirements to Enable UEFI Platforms without CSM</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>First-generation 64-bit UEFI platforms typically contain some form of limited BIOS emulation such as a CSM to preserve the ability to run 32-bit operating systems and operating systems that do not support UEFI.</source>
          <target>First-generation 64-bit UEFI platforms typically contain some form of limited BIOS emulation such as a CSM to preserve the ability to run 32-bit operating systems and operating systems that do not support UEFI.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>Existing Windows dependencies on INT 10 video BIOS functions also require a CSM.</source>
          <target>Existing Windows dependencies on INT 10 video BIOS functions also require a CSM.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>To reduce the need for a CSM and improve boot times in the future, we are collaborating with the industry to eliminate this dependency and encourage changes to system firmware.</source>
          <target>To reduce the need for a CSM and improve boot times in the future, we are collaborating with the industry to eliminate this dependency and encourage changes to system firmware.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>Firmware requirements:</source>
          <target>Firmware requirements:</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GOP</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GOP</pc>.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>Windows uses the GOP to obtain a frame buffer pointer at boot time for use during operating system runtime.</source>
          <target>Windows uses the GOP to obtain a frame buffer pointer at boot time for use during operating system runtime.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>GOP support is essential to replace VGA support and avoid the requirement for a CSM in future versions of Windows.</source>
          <target>GOP support is essential to replace VGA support and avoid the requirement for a CSM in future versions of Windows.</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI Capsule Services</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI Capsule Services</pc>.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>Windows can use the EFI UpdateCapsule() service to persist information across a system restart and pass that information to the firmware.</source>
          <target>Windows can use the EFI UpdateCapsule() service to persist information across a system restart and pass that information to the firmware.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>This would potentially let the system report and/or respond to certain error conditions if the boot device or operating system were damaged or otherwise unavailable.</source>
          <target>This would potentially let the system report and/or respond to certain error conditions if the boot device or operating system were damaged or otherwise unavailable.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Firmware recommendations</source>
          <target>Firmware recommendations</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Note to firmware manufacturers: We recommend that when Secure Boot is disabled, then the firmware should trigger the following actions, to provide a better support experience for previous versions of Windows:</source>
          <target>Note to firmware manufacturers: We recommend that when Secure Boot is disabled, then the firmware should trigger the following actions, to provide a better support experience for previous versions of Windows:</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>Enable the CSM for VGA support, though not BIOS mode emulation.</source>
          <target>Enable the CSM for VGA support, though not BIOS mode emulation.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>Enable messages during the POST process to show which keys open the boot menus.</source>
          <target>Enable messages during the POST process to show which keys open the boot menus.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>