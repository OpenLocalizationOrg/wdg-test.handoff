{"nodes":[{"content":"Exercise 2 - Track User Mode Process Allocations","pos":[11,59]},{"content":"Heap allocations are made directly via Heap APIs (HeapAlloc, HeapRealloc, and C/C++ allocations such as new, alloc, realloc, calloc) and are serviced using three types of heaps","pos":[73,249]},{"content":"Exercise 2 - Track User Mode Process Allocations","pos":[438,486]},{"pos":[489,698],"content":"<bpt id=\"p1\">**</bpt>Heap<ept id=\"p1\">**</ept> allocations are made directly via <bpt id=\"p2\">**</bpt>Heap<ept id=\"p2\">**</ept> APIs (<bpt id=\"p3\">**</bpt>HeapAlloc<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>HeapRealloc<ept id=\"p4\">**</ept>, and C/C++ allocations such as <bpt id=\"p5\">**</bpt>new<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>alloc<ept id=\"p6\">**</ept>, <bpt id=\"p7\">**</bpt>realloc<ept id=\"p7\">**</ept>, <bpt id=\"p8\">**</bpt>calloc<ept id=\"p8\">**</ept>) and are serviced using three types of heaps:"},{"pos":[704,781],"content":"<bpt id=\"p1\">**</bpt>Mainline NT Heap<ept id=\"p1\">**</ept> – Services allocation requests of sizes less than 64 KB."},{"pos":[787,895],"content":"<bpt id=\"p1\">**</bpt>Low Fragmentation Heap<ept id=\"p1\">**</ept> – Composed of sub-segments that service allocation requests of fixed size blocks."},{"pos":[901,977],"content":"<bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> – Services allocation requests of sizes greater than 64 KB."},{"content":"<bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> is used for large dynamic memory allocations that are made directly via the <bpt id=\"p2\">**</bpt>VirtualAlloc<ept id=\"p2\">**</ept> API.","pos":[979,1093]},{"content":"The typical usage is usually for bitmaps or buffers.","pos":[1094,1146]},{"content":"You can use <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> to reserve a block of pages and then make additional calls to <bpt id=\"p2\">**</bpt>VirtualAlloc<ept id=\"p2\">**</ept> to commit individual pages from the reserved block.","pos":[1147,1306]},{"content":"This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed.","pos":[1307,1432]},{"content":"There are two concepts to understand in this area:","pos":[1434,1484]},{"pos":[1490,1585],"content":"<bpt id=\"p1\">**</bpt>Reserved memory<ept id=\"p1\">**</ept>: Reserves an address range for usage but does not acquire memory resources."},{"pos":[1591,1718],"content":"<bpt id=\"p1\">**</bpt>Committed memory<ept id=\"p1\">**</ept>: Ensures that either physical memory or page file space will be available if the addresses are referenced."},{"content":"In this exercise, you will learn how to gather traces to investigate how a user mode process allocates memory.","pos":[1720,1830]},{"pos":[1832,1936],"content":"The exercise focuses on a dummy test process called <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> that allocates memory through:"},{"pos":[1942,1998],"content":"The <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> API to commit large memory buffers."},{"pos":[2004,2058],"content":"The C++ <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator to instantiate small objects."},{"pos":[2060,2212],"content":"You can download <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> from <bpt id=\"p2\">[</bpt>here<ept id=\"p2\">](http://download.microsoft.com/download/9/C/8/9C88C0A1-1200-416A-B92B-2EBB128E4A4B/MemoryTestApp.exe)</ept>."},{"content":"Step 1: Gather a virtualAlloc/heap trace using WPR","pos":[2216,2266]},{"content":"Large memory allocations are usually the ones that impact the footprint of a process and are serviced by the <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> API.","pos":[2269,2399]},{"content":"This is where all investigations should begin, but it is also possible that a process misbehaves with smaller allocations (e.g. memory leaks using <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator in C++, etc.).","pos":[2400,2578]},{"content":"Heap tracing becomes useful when this situation happens.","pos":[2579,2635]},{"pos":[2708,2753],"content":"Step 1.1: Prepare the system for heap tracing"},{"content":"Heap tracing should be considered optional and done when <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> analysis does not provide any relevant explanation for a memory usage issue.","pos":[2755,2905]},{"content":"Heap tracing tends to produce larger traces, and it is recommended to enable tracing only for the individual processes that you’re investigating.","pos":[2906,3051]},{"pos":[3053,3207],"content":"Add the registry key for the process of interest (<bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> in this case); heap tracing is then enabled for every subsequent process creation."},{"pos":[3430,3465],"content":"Step 1.2: Capture a trace using WPR"},{"pos":[3467,3566],"content":"In this step, you’ll gather a trace using <bpt id=\"p1\">**</bpt>WPR<ept id=\"p1\">**</ept> that contains <bpt id=\"p2\">**</bpt>VirtualAlloc<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Heap<ept id=\"p3\">**</ept> data."},{"pos":[3572,3622],"content":"Open <bpt id=\"p1\">**</bpt>WPR<ept id=\"p1\">**</ept> and modify the tracing configuration."},{"pos":[3632,3683],"content":"Select the <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Heap<ept id=\"p2\">**</ept> providers."},{"pos":[3693,3744],"content":"Select <bpt id=\"p1\">**</bpt>general<ept id=\"p1\">**</ept> as the <bpt id=\"p2\">**</bpt>performance scenario<ept id=\"p2\">**</ept>."},{"pos":[3754,3797],"content":"Select <bpt id=\"p1\">**</bpt>general<ept id=\"p1\">**</ept> as the <bpt id=\"p2\">**</bpt>logging mode<ept id=\"p2\">**</ept>."},{"pos":[3849,3882],"content":"Click <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> to start tracing."},{"pos":[3888,3991],"content":"Launch <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept>, and wait for the process to terminate (it should take around 30 seconds)."},{"pos":[3997,4088],"content":"Return to <bpt id=\"p1\">**</bpt>WPR<ept id=\"p1\">**</ept>, save the trace, and open it with <bpt id=\"p2\">**</bpt>Windows Performance Analyzer (WPA)<ept id=\"p2\">**</ept>."},{"pos":[4094,4156],"content":"Open the <bpt id=\"p1\">**</bpt>Trace<ept id=\"p1\">**</ept> menu and select <bpt id=\"p2\">**</bpt>Configure symbols path<ept id=\"p2\">**</ept>."},{"content":"Specify the path of the symbol cache.","pos":[4166,4203]},{"content":"For more information on symbols, see the <bpt id=\"p1\">[</bpt>Symbol Support<ept id=\"p1\">](https://go.microsoft.com/fwlink/?linkid=623019)</ept> page on MSDN.","pos":[4204,4323]},{"pos":[4329,4381],"content":"Open the <bpt id=\"p1\">**</bpt>Trace<ept id=\"p1\">**</ept> menu and select <bpt id=\"p2\">**</bpt>Load symbols<ept id=\"p2\">**</ept>."},{"pos":[4383,4507],"content":"You now have a trace that contains all memory allocation patterns for the <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> process during its lifetime."},{"content":"Step 2: Review VirtualAlloc dynamic allocations","pos":[4512,4559]},{"content":"The detailed <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> data is exposed via the <bpt id=\"p2\">**</bpt>‘VirtualAlloc Commit Lifetimes’<ept id=\"p2\">**</ept> graph in WPA.","pos":[4562,4665]},{"content":"The key columns of interest are the following:","pos":[4666,4712]},{"content":"Column","pos":[4817,4823]},{"content":"Description","pos":[4833,4844]},{"content":"Process","pos":[4902,4909]},{"content":"The name of the process that performs memory allocations through <ph id=\"ph1\">&lt;strong&gt;</ph>VirtualAlloc<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[4931,5026]},{"content":"Commit Stack","pos":[5072,5084]},{"content":"The call stack that shows the code path leading to memory being allocated.","pos":[5106,5180]},{"content":"Commit Time","pos":[5225,5236]},{"content":"The timestamp of when memory was allocated.","pos":[5258,5301]},{"content":"Decommit Time","pos":[5347,5360]},{"content":"The timestamp of when memory was freed.","pos":[5382,5421]},{"content":"Impacting Size","pos":[5466,5480]},{"content":"The size of outstanding allocations or the size difference between the start and end of the selected time interval.","pos":[5502,5617]},{"content":"This size adjusts based on the selected view port.","pos":[5618,5668]},{"content":"The <ph id=\"ph1\">&lt;strong&gt;</ph>Impacting Size<ph id=\"ph2\">&lt;/strong&gt;</ph> value will be zero if all memory allocated by a process is freed by the end of the visualized interval in <ph id=\"ph3\">&lt;strong&gt;</ph>WPA.","pos":[5676,5830]},{"content":"Size","pos":[5885,5889]},{"content":"The cumulative sum of all allocation during the selected time interval.","pos":[5911,5982]},{"pos":[6020,6071],"content":"Follow these steps to analyze <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept>"},{"pos":[6077,6179],"content":"Find the <bpt id=\"p1\">**</bpt>VirtualAlloc Commit Lifetimes<ept id=\"p1\">**</ept> graph in the <bpt id=\"p2\">**</bpt>Memory<ept id=\"p2\">**</ept> category of the <bpt id=\"p3\">**</bpt>Graph Explorer<ept id=\"p3\">**</ept>."},{"pos":[6185,6263],"content":"Drag and drop the <bpt id=\"p1\">**</bpt>VirtualAlloc Commit Lifetimes<ept id=\"p1\">**</ept> onto the <bpt id=\"p2\">**</bpt>Analysis<ept id=\"p2\">**</ept> tab."},{"content":"Organize the table to show these columns.","pos":[6269,6310]},{"content":"Right-click on the column headers to add or remove columns.","pos":[6311,6370]},{"content":"Process","pos":[6382,6389]},{"content":"Impacting Type","pos":[6403,6417]},{"content":"Commit Stack","pos":[6431,6443]},{"pos":[6455,6492],"content":"<bpt id=\"p1\">**</bpt>Commit Time<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Decommit Time<ept id=\"p2\">**</ept>"},{"content":"Count","pos":[6504,6509]},{"pos":[6521,6552],"content":"<bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Size<ept id=\"p2\">**</ept>"},{"pos":[6558,6605],"content":"Find <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> in the process list."},{"pos":[6611,6674],"content":"Apply a filter to keep only <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> on the graph."},{"pos":[6684,6732],"content":"Right-click, and select <bpt id=\"p1\">**</bpt>Filter<ept id=\"p1\">**</ept> to Selection."},{"content":"Your analysis viewport should look similar to this:","pos":[6772,6823]},{"content":"In the preceding example, two values are of interest:","pos":[6863,6916]},{"content":"<bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> of 126 MB: This indicates that <bpt id=\"p2\">**</bpt>MemoryTestApp.exe<ept id=\"p2\">**</ept> allocated a total of 125 MB over the course of its lifespan.","pos":[6922,7044]},{"content":"It represents the cumulative sum of all <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> API calls made by the process and its dependencies.","pos":[7045,7153]},{"content":"<bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> of 0 MB: This indicates that all of the memory allocated by the process is freed by the end of the time interval being currently analyzed.","pos":[7159,7316]},{"content":"The system didn’t suffer from an increase of its steady state memory usage.","pos":[7317,7392]},{"content":"Step 2.1: Analyze steady state memory usage","pos":[7398,7441]},{"content":"When investigating memory allocation, you should try to answer the question: “Why is the steady state memory usage growing for this scenario?”","pos":[7443,7585]},{"content":"In the <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> example, you can see that it has about 10 MB of steady state memory allocated at the beginning, and then it increases to 20 MB halfway through.","pos":[7586,7758]},{"content":"To investigate this behavior, narrow the zoom to around the time interval when the sudden increase occurs in the middle of the trace.","pos":[7798,7931]},{"content":"Your viewport should look like this.","pos":[7971,8007]},{"content":"As you can see, the <bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> is now <bpt id=\"p2\">**</bpt>10 MB<ept id=\"p2\">**</ept>.","pos":[8047,8103]},{"content":"This means that, between the start and the end of the time interval being analyzed, there’s a 10 MB increase in steady state memory usage.","pos":[8104,8242]},{"pos":[8248,8308],"content":"Sort by <bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> by clicking on the column header."},{"pos":[8314,8379],"content":"Expand the <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> row (in the <bpt id=\"p2\">**</bpt>Process<ept id=\"p2\">**</ept> column)."},{"pos":[8385,8449],"content":"Expand the <bpt id=\"p1\">**</bpt>Impacting<ept id=\"p1\">**</ept> row (in the <bpt id=\"p2\">**</bpt>Impacting Type<ept id=\"p2\">**</ept> column)."},{"pos":[8455,8560],"content":"Navigate through the process <bpt id=\"p1\">**</bpt>Commit Stack<ept id=\"p1\">**</ept> until you find the function that allocated 10 MB of memory."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>Main<ept id=\"p1\">**</ept> function of <bpt id=\"p2\">**</bpt>MemoryTestApp.exe<ept id=\"p2\">**</ept> allocates 10 MB of memory in the middle of the workload by directly calling <bpt id=\"p3\">**</bpt>VirtualAlloc<ept id=\"p3\">**</ept>.","pos":[8604,8761]},{"content":"In the real world, the application developer should determine if the allocation is reasonable or if the code could be rearranged to minimize the steady state memory usage increase.","pos":[8762,8942]},{"pos":[8944,8987],"content":"You can now <bpt id=\"p1\">**</bpt>unzoom<ept id=\"p1\">**</ept> the viewport in WPA."},{"content":"Step 2.2: Analyze transient (or peak) memory usage","pos":[9031,9081]},{"content":"When investigating memory allocations, you should try to answer the question: “Why is there a transient peak in the memory usage for this part of the scenario?”","pos":[9083,9243]},{"content":"Transient allocations cause spikes in memory usage, and can lead to fragmentation and push valuable content out of the system Standby cache when there’s memory pressure.","pos":[9244,9413]},{"pos":[9415,9554],"content":"In the <bpt id=\"p1\">**</bpt>MemoryTest<ept id=\"p1\">**</ept> example, you can see that there are 10 different spikes of memory usage (of 10 MB) evenly scattered across the trace."},{"content":"Narrow the zoom to the last four spikes, to focus on a smaller region of interest and reduce noise from non-relevant behaviors.","pos":[9594,9721]},{"content":"Your viewport should look like this:","pos":[9761,9797]},{"pos":[9841,9891],"content":"Sort by <bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> by clicking on the column header."},{"pos":[9897,9962],"content":"Expand the <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> row (in the <bpt id=\"p2\">**</bpt>Process<ept id=\"p2\">**</ept> column)."},{"pos":[9968,10034],"content":"Click on the <bpt id=\"p1\">**</bpt>Transient<ept id=\"p1\">**</ept> row (in the <bpt id=\"p2\">**</bpt>Impacting Type<ept id=\"p2\">**</ept> column)."},{"content":"This should highlight in blue all the spikes of memory usage in the viewport.","pos":[10044,10121]},{"content":"Note the value of the different columns:","pos":[10127,10167]},{"pos":[10177,10282],"content":"<bpt id=\"p1\">**</bpt>Count<ept id=\"p1\">**</ept> = 4: This indicates that four transient memory allocations were made during that time interval."},{"pos":[10292,10420],"content":"<bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> = 0 MB: This indicates that all four transient memory allocations were freed by the end of the time interval."},{"pos":[10430,10539],"content":"<bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> = 40 MB: This indicates that sum of all four transient memory allocations amount to 40 MB of memory."},{"pos":[10545,10651],"content":"Navigate through the process <bpt id=\"p1\">**</bpt>Commit Stack<ept id=\"p1\">**</ept> until you find the functions that allocated 40 MB of memory."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>Main<ept id=\"p1\">**</ept> function of <bpt id=\"p2\">**</bpt>MemoryTestApp.exe<ept id=\"p2\">**</ept> calls a function named <bpt id=\"p3\">**</bpt>Operation1<ept id=\"p3\">**</ept>, which in turn calls a function named <bpt id=\"p4\">**</bpt>ManipulateTemporaryBuffer<ept id=\"p4\">**</ept>.","pos":[10695,10865]},{"content":"This <bpt id=\"p1\">**</bpt>ManipulateTemporaryBuffer<ept id=\"p1\">**</ept> function then directly calls <bpt id=\"p2\">**</bpt>VirtualAlloc<ept id=\"p2\">**</ept> four times, creating and freeing a 10 MB memory buffer every time.","pos":[10866,11013]},{"content":"The buffers only last 100 ms each.","pos":[11014,11048]},{"content":"The buffers' allocation and free times are represented by the <bpt id=\"p1\">**</bpt>Commit Time<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Decommit Time<ept id=\"p2\">**</ept> columns.","pos":[11049,11157]},{"content":"In the real world, the application developer would determine if those short-lived transient temporary buffer allocations are necessary, or if they can be replaced by using a permanent memory buffer for the operation.","pos":[11159,11375]},{"pos":[11377,11424],"content":"You can now <bpt id=\"p1\">**</bpt>unzoom<ept id=\"p1\">**</ept> the viewport in <bpt id=\"p2\">**</bpt>WPA<ept id=\"p2\">**</ept>."},{"content":"Step 3: Review heap dynamic allocations","pos":[11429,11468]},{"content":"So far, the analysis has only focused on large memory allocations that are serviced by the <bpt id=\"p1\">**</bpt>VirtualAlloc<ept id=\"p1\">**</ept> API.","pos":[11471,11583]},{"content":"The next step is to determine if there are issues with other small allocations made by the process, using the Heap data initially gathered.","pos":[11584,11723]},{"content":"The detailed Heap data is exposed via the <bpt id=\"p1\">**</bpt>“Heap Allocations”<ept id=\"p1\">**</ept> graph in WPA.","pos":[11725,11803]},{"content":"The key columns of interest are the following:","pos":[11804,11850]},{"content":"Column","pos":[11955,11961]},{"content":"Description","pos":[11971,11982]},{"content":"Process","pos":[12040,12047]},{"content":"The name of the process that is performing memory allocation.","pos":[12066,12127]},{"content":"Handle","pos":[12169,12175]},{"content":"The identifier of the Heap that is used to service the allocation.","pos":[12197,12263]},{"content":"Heaps can be created, so there could be multiple heap handles for the process.","pos":[12271,12349]},{"content":"Stack","pos":[12394,12399]},{"content":"The call stack that shows the code path that leads to memory being allocated.","pos":[12418,12495]},{"content":"Alloc Time","pos":[12537,12547]},{"content":"The timestamp of when memory was allocated.","pos":[12566,12609]},{"content":"Impacting Size","pos":[12650,12664]},{"content":"The size of outstanding allocations or the difference between the start and end of the selected viewport.","pos":[12683,12788]},{"content":"This size adjusts based on the selected time interval.","pos":[12789,12843]},{"content":"Size","pos":[12885,12889]},{"content":"The cumulative sum of all allocations/deallocations.","pos":[12908,12960]},{"pos":[12994,13045],"content":"Follow these steps to analyze <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept>"},{"pos":[13051,13140],"content":"Find the <bpt id=\"p1\">**</bpt>Heap Allocations<ept id=\"p1\">**</ept> graph in the <bpt id=\"p2\">**</bpt>Memory<ept id=\"p2\">**</ept> category of the <bpt id=\"p3\">**</bpt>Graph Explorer<ept id=\"p3\">**</ept>."},{"pos":[13146,13211],"content":"Drag and drop the <bpt id=\"p1\">**</bpt>Heap Allocations<ept id=\"p1\">**</ept> onto the <bpt id=\"p2\">**</bpt>Analysis<ept id=\"p2\">**</ept> tab."},{"content":"Organize the table to show these columns:","pos":[13217,13258]},{"content":"Process","pos":[13270,13277]},{"content":"Handle","pos":[13291,13297]},{"content":"Impacting Type","pos":[13311,13325]},{"content":"Stack","pos":[13339,13344]},{"content":"AllocTime","pos":[13358,13367]},{"content":"Count","pos":[13381,13386]},{"pos":[13398,13429],"content":"<bpt id=\"p1\">**</bpt>Impacting Size<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Size<ept id=\"p2\">**</ept>"},{"pos":[13435,13482],"content":"Find <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> in the process list."},{"pos":[13488,13551],"content":"Apply a filter to keep only <bpt id=\"p1\">**</bpt>MemoryTestApp.exe<ept id=\"p1\">**</ept> on the graph."},{"pos":[13561,13608],"content":"Right-click and select <bpt id=\"p1\">**</bpt>Filter<ept id=\"p1\">**</ept> to Selection."},{"content":"Your viewport should look like this:","pos":[13610,13646]},{"content":"In this example, you can see that one of the heaps is steadily increasing in size over time at a constant rate.","pos":[13686,13797]},{"content":"There are 1200 memory allocations on that heap, accounting for 130 KB of used memory by the end of the interval.","pos":[13798,13910]},{"content":"Zoom in on a smaller interval (for example, 10 seconds) in the middle of the trace.","pos":[13916,13999]},{"pos":[14005,14121],"content":"Expand the head <bpt id=\"p1\">**</bpt>Handle<ept id=\"p1\">**</ept> that shows the largest amount of allocations (as shown in the <bpt id=\"p2\">**</bpt>Impacting Size<ept id=\"p2\">**</ept> column)."},{"pos":[14127,14157],"content":"Expand the <bpt id=\"p1\">**</bpt>Impacting<ept id=\"p1\">**</ept> type."},{"pos":[14163,14281],"content":"Navigate through the process <bpt id=\"p1\">**</bpt>Stack<ept id=\"p1\">**</ept> until you find the function that is responsible for allocating all this memory."},{"content":"In this example, the <bpt id=\"p1\">**</bpt>Main<ept id=\"p1\">**</ept> function of <bpt id=\"p2\">**</bpt>MemoryTestApp.exe<ept id=\"p2\">**</ept> calls a function named <bpt id=\"p3\">**</bpt>InnerLoopOperation<ept id=\"p3\">**</ept>.","pos":[14325,14435]},{"content":"This <bpt id=\"p1\">**</bpt>InnerLoopOperation<ept id=\"p1\">**</ept> function then allocates 40 bytes of memory 319 times through the C++ <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator.","pos":[14436,14550]},{"content":"This memory remains allocated until the process is terminated.","pos":[14551,14613]},{"content":"In the real world, the application developer should then determine if this behavior implies a possible memory leak and fix the issue.","pos":[14615,14748]},{"content":"Step 4: Clean up the test system","pos":[14753,14785]},{"content":"Once the analysis is complete, you should clean up the registry to make sure that heap tracing is disabled for the process.","pos":[14788,14911]},{"content":"Run this command on an elevated command prompt:","pos":[14912,14959]}],"content":"---\ntitle: Exercise 2 - Track User Mode Process Allocations\ndescription: Heap allocations are made directly via Heap APIs (HeapAlloc, HeapRealloc, and C/C++ allocations such as new, alloc, realloc, calloc) and are serviced using three types of heaps\nMSHAttr:\n- 'PreferredSiteName:MSDN'\n- 'PreferredLib:/library/windows/hardware'\nms.assetid: A1548D9A-6865-46FF-86B3-2874F559C893\nms.prod: W10\nms.mktglfcycl: operate\nms.sitesec: msdn\n---\n\n# Exercise 2 - Track User Mode Process Allocations\n\n\n**Heap** allocations are made directly via **Heap** APIs (**HeapAlloc**, **HeapRealloc**, and C/C++ allocations such as **new**, **alloc**, **realloc**, **calloc**) and are serviced using three types of heaps:\n\n1.  **Mainline NT Heap** – Services allocation requests of sizes less than 64 KB.\n\n2.  **Low Fragmentation Heap** – Composed of sub-segments that service allocation requests of fixed size blocks.\n\n3.  **VirtualAlloc** – Services allocation requests of sizes greater than 64 KB.\n\n**VirtualAlloc** is used for large dynamic memory allocations that are made directly via the **VirtualAlloc** API. The typical usage is usually for bitmaps or buffers. You can use **VirtualAlloc** to reserve a block of pages and then make additional calls to **VirtualAlloc** to commit individual pages from the reserved block. This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed.\n\nThere are two concepts to understand in this area:\n\n1.  **Reserved memory**: Reserves an address range for usage but does not acquire memory resources.\n\n2.  **Committed memory**: Ensures that either physical memory or page file space will be available if the addresses are referenced.\n\nIn this exercise, you will learn how to gather traces to investigate how a user mode process allocates memory.\n\nThe exercise focuses on a dummy test process called **MemoryTestApp.exe** that allocates memory through:\n\n1.  The **VirtualAlloc** API to commit large memory buffers.\n\n2.  The C++ **new** operator to instantiate small objects.\n\nYou can download **MemoryTestApp.exe** from [here](http://download.microsoft.com/download/9/C/8/9C88C0A1-1200-416A-B92B-2EBB128E4A4B/MemoryTestApp.exe).\n## Step 1: Gather a virtualAlloc/heap trace using WPR\n\n\nLarge memory allocations are usually the ones that impact the footprint of a process and are serviced by the **VirtualAlloc** API. This is where all investigations should begin, but it is also possible that a process misbehaves with smaller allocations (e.g. memory leaks using **new** operator in C++, etc.). Heap tracing becomes useful when this situation happens.\n\n### <a href=\"\" id=\"step-1-1---prepare-the-system-for-heap-tracing\"></a>Step 1.1: Prepare the system for heap tracing\n\nHeap tracing should be considered optional and done when **VirtualAlloc** analysis does not provide any relevant explanation for a memory usage issue. Heap tracing tends to produce larger traces, and it is recommended to enable tracing only for the individual processes that you’re investigating.\n\nAdd the registry key for the process of interest (**MemoryTestApp.exe** in this case); heap tracing is then enabled for every subsequent process creation.\n\n``` syntax\nreg add \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MemoryTestApp.exe\" /v TracingFlags /t REG_DWORD /d 1 /f\n```\n\n### <a href=\"\" id=\"step-1-2--capture-a-trace-using-wpr-\"></a>Step 1.2: Capture a trace using WPR\n\nIn this step, you’ll gather a trace using **WPR** that contains **VirtualAlloc** and **Heap** data.\n\n1.  Open **WPR** and modify the tracing configuration.\n\n    1.  Select the **VirtualAlloc** and **Heap** providers.\n\n    2.  Select **general** as the **performance scenario**.\n\n    3.  Select **general** as the **logging mode**.\n\n        ![](images/memoryfootprintlab11.png)\n\n2.  Click **Start** to start tracing.\n\n3.  Launch **MemoryTestApp.exe**, and wait for the process to terminate (it should take around 30 seconds).\n\n4.  Return to **WPR**, save the trace, and open it with **Windows Performance Analyzer (WPA)**.\n\n5.  Open the **Trace** menu and select **Configure symbols path**.\n\n    -   Specify the path of the symbol cache. For more information on symbols, see the [Symbol Support](https://go.microsoft.com/fwlink/?linkid=623019) page on MSDN.\n\n6.  Open the **Trace** menu and select **Load symbols**.\n\nYou now have a trace that contains all memory allocation patterns for the **MemoryTestApp.exe** process during its lifetime.\n\n## Step 2: Review VirtualAlloc dynamic allocations\n\n\nThe detailed **VirtualAlloc** data is exposed via the **‘VirtualAlloc Commit Lifetimes’** graph in WPA. The key columns of interest are the following:\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Column</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>Process</strong></td>\n<td><p>The name of the process that performs memory allocations through <strong>VirtualAlloc</strong>.</p></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Commit Stack</strong></td>\n<td><p>The call stack that shows the code path leading to memory being allocated.</p></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Commit Time</strong></td>\n<td><p>The timestamp of when memory was allocated.</p></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Decommit Time</strong></td>\n<td><p>The timestamp of when memory was freed.</p></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Impacting Size</strong></td>\n<td><p>The size of outstanding allocations or the size difference between the start and end of the selected time interval. This size adjusts based on the selected view port.</p>\n<p>The <strong>Impacting Size</strong> value will be zero if all memory allocated by a process is freed by the end of the visualized interval in <strong>WPA.</strong></p></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Size</strong></td>\n<td><p>The cumulative sum of all allocation during the selected time interval.</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\nFollow these steps to analyze **MemoryTestApp.exe**\n\n1.  Find the **VirtualAlloc Commit Lifetimes** graph in the **Memory** category of the **Graph Explorer**.\n\n2.  Drag and drop the **VirtualAlloc Commit Lifetimes** onto the **Analysis** tab.\n\n3.  Organize the table to show these columns. Right-click on the column headers to add or remove columns.\n\n    1.  **Process**\n\n    2.  **Impacting Type**\n\n    3.  **Commit Stack**\n\n    4.  **Commit Time** and **Decommit Time**\n\n    5.  **Count**\n\n    6.  **Impacting Size** and **Size**\n\n4.  Find **MemoryTestApp.exe** in the process list.\n\n5.  Apply a filter to keep only **MemoryTestApp.exe** on the graph.\n\n    -   Right-click, and select **Filter** to Selection.\n\n![](images/memoryfootprintlab12.png)\n\nYour analysis viewport should look similar to this:\n\n![](images/memoryfootprintlab13.png)\n\nIn the preceding example, two values are of interest:\n\n-   **Size** of 126 MB: This indicates that **MemoryTestApp.exe** allocated a total of 125 MB over the course of its lifespan. It represents the cumulative sum of all **VirtualAlloc** API calls made by the process and its dependencies.\n\n-   **Impacting Size** of 0 MB: This indicates that all of the memory allocated by the process is freed by the end of the time interval being currently analyzed. The system didn’t suffer from an increase of its steady state memory usage.\n\n### Step 2.1: Analyze steady state memory usage\n\nWhen investigating memory allocation, you should try to answer the question: “Why is the steady state memory usage growing for this scenario?” In the **MemoryTestApp.exe** example, you can see that it has about 10 MB of steady state memory allocated at the beginning, and then it increases to 20 MB halfway through.\n\n![](images/memoryfootprintlab14.png)\n\nTo investigate this behavior, narrow the zoom to around the time interval when the sudden increase occurs in the middle of the trace.\n\n![](images/memoryfootprintlab15.png)\n\nYour viewport should look like this.\n\n![](images/memoryfootprintlab16.png)\n\nAs you can see, the **Impacting Size** is now **10 MB**. This means that, between the start and the end of the time interval being analyzed, there’s a 10 MB increase in steady state memory usage.\n\n1.  Sort by **Impacting Size** by clicking on the column header.\n\n2.  Expand the **MemoryTestApp.exe** row (in the **Process** column).\n\n3.  Expand the **Impacting** row (in the **Impacting Type** column).\n\n4.  Navigate through the process **Commit Stack** until you find the function that allocated 10 MB of memory.\n\n    ![](images/memoryfootprintlab17.png)\n\nIn this example, the **Main** function of **MemoryTestApp.exe** allocates 10 MB of memory in the middle of the workload by directly calling **VirtualAlloc**. In the real world, the application developer should determine if the allocation is reasonable or if the code could be rearranged to minimize the steady state memory usage increase.\n\nYou can now **unzoom** the viewport in WPA.\n\n![](images/memoryfootprintlab18.png)\n\n### Step 2.2: Analyze transient (or peak) memory usage\n\nWhen investigating memory allocations, you should try to answer the question: “Why is there a transient peak in the memory usage for this part of the scenario?” Transient allocations cause spikes in memory usage, and can lead to fragmentation and push valuable content out of the system Standby cache when there’s memory pressure.\n\nIn the **MemoryTest** example, you can see that there are 10 different spikes of memory usage (of 10 MB) evenly scattered across the trace.\n\n![](images/memoryfootprintlab19.png)\n\nNarrow the zoom to the last four spikes, to focus on a smaller region of interest and reduce noise from non-relevant behaviors.\n\n![](images/memoryfootprintlab20.png)\n\nYour viewport should look like this:\n\n![](images/memoryfootprintlab21.png)\n\n1.  Sort by **Size** by clicking on the column header.\n\n2.  Expand the **MemoryTestApp.exe** row (in the **Process** column).\n\n3.  Click on the **Transient** row (in the **Impacting Type** column).\n\n    -   This should highlight in blue all the spikes of memory usage in the viewport.\n\n4.  Note the value of the different columns:\n\n    1.  **Count** = 4: This indicates that four transient memory allocations were made during that time interval.\n\n    2.  **Impacting Size** = 0 MB: This indicates that all four transient memory allocations were freed by the end of the time interval.\n\n    3.  **Size** = 40 MB: This indicates that sum of all four transient memory allocations amount to 40 MB of memory.\n\n5.  Navigate through the process **Commit Stack** until you find the functions that allocated 40 MB of memory.\n\n    ![](images/memoryfootprintlab22.png)\n\nIn this example, the **Main** function of **MemoryTestApp.exe** calls a function named **Operation1**, which in turn calls a function named **ManipulateTemporaryBuffer**. This **ManipulateTemporaryBuffer** function then directly calls **VirtualAlloc** four times, creating and freeing a 10 MB memory buffer every time. The buffers only last 100 ms each. The buffers' allocation and free times are represented by the **Commit Time** and **Decommit Time** columns.\n\nIn the real world, the application developer would determine if those short-lived transient temporary buffer allocations are necessary, or if they can be replaced by using a permanent memory buffer for the operation.\n\nYou can now **unzoom** the viewport in **WPA**.\n\n## Step 3: Review heap dynamic allocations\n\n\nSo far, the analysis has only focused on large memory allocations that are serviced by the **VirtualAlloc** API. The next step is to determine if there are issues with other small allocations made by the process, using the Heap data initially gathered.\n\nThe detailed Heap data is exposed via the **“Heap Allocations”** graph in WPA. The key columns of interest are the following:\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Column</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>Process</strong></td>\n<td>The name of the process that is performing memory allocation.</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Handle</strong></td>\n<td><p>The identifier of the Heap that is used to service the allocation.</p>\n<p>Heaps can be created, so there could be multiple heap handles for the process.</p></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Stack</strong></td>\n<td>The call stack that shows the code path that leads to memory being allocated.</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Alloc Time</strong></td>\n<td>The timestamp of when memory was allocated.</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Impacting Size</strong></td>\n<td>The size of outstanding allocations or the difference between the start and end of the selected viewport. This size adjusts based on the selected time interval.</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Size</strong></td>\n<td>The cumulative sum of all allocations/deallocations.</td>\n</tr>\n</tbody>\n</table>\n\n \n\nFollow these steps to analyze **MemoryTestApp.exe**\n\n1.  Find the **Heap Allocations** graph in the **Memory** category of the **Graph Explorer**.\n\n2.  Drag and drop the **Heap Allocations** onto the **Analysis** tab.\n\n3.  Organize the table to show these columns:\n\n    1.  **Process**\n\n    2.  **Handle**\n\n    3.  **Impacting Type**\n\n    4.  **Stack**\n\n    5.  **AllocTime**\n\n    6.  **Count**\n\n    7.  **Impacting Size** and **Size**\n\n4.  Find **MemoryTestApp.exe** in the process list.\n\n5.  Apply a filter to keep only **MemoryTestApp.exe** on the graph.\n\n    -   Right-click and select **Filter** to Selection.\n\nYour viewport should look like this:\n\n![](images/memoryfootprintlab23.png)\n\nIn this example, you can see that one of the heaps is steadily increasing in size over time at a constant rate. There are 1200 memory allocations on that heap, accounting for 130 KB of used memory by the end of the interval.\n\n1.  Zoom in on a smaller interval (for example, 10 seconds) in the middle of the trace.\n\n2.  Expand the head **Handle** that shows the largest amount of allocations (as shown in the **Impacting Size** column).\n\n3.  Expand the **Impacting** type.\n\n4.  Navigate through the process **Stack** until you find the function that is responsible for allocating all this memory.\n\n    ![](images/memoryfootprintlab24.png)\n\nIn this example, the **Main** function of **MemoryTestApp.exe** calls a function named **InnerLoopOperation**. This **InnerLoopOperation** function then allocates 40 bytes of memory 319 times through the C++ **new** operator. This memory remains allocated until the process is terminated.\n\nIn the real world, the application developer should then determine if this behavior implies a possible memory leak and fix the issue.\n\n## Step 4: Clean up the test system\n\n\nOnce the analysis is complete, you should clean up the registry to make sure that heap tracing is disabled for the process. Run this command on an elevated command prompt:\n\n``` syntax\nreg delete \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MemoryTestApp.exe\" /v TracingFlags /f\n```\n\n \n\n \n\n\n\n\n\n\n"}