{"nodes":[{"content":"Exercise 1 - Identify Processes with Large Working Sets","pos":[11,66]},{"content":"The methodology used to analyze the data can take several approaches and differs based on the circumstances under which the investigation was started.","pos":[80,230]},{"content":"Exercise 1 - Identify Processes with Large Working Sets","pos":[419,474]},{"content":"The methodology used to analyze the data can take several approaches and differs based on the circumstances under which the investigation was started.","pos":[477,627]},{"content":"This exercise discusses and presents some example methodologies along with the different views presented by various column arrangements.","pos":[628,764]},{"content":"The data referred to as the Resident Set is the set of pages that currently reside in physical memory (RAM).","pos":[766,874]},{"content":"The Resident Set is a snapshot of the current memory state at the end of a trace capture with <bpt id=\"p1\">**</bpt>Windows Performance Recorder (WPR)<ept id=\"p1\">**</ept> or the Assessment Toolkit Memory assessment.","pos":[875,1052]},{"content":"It is not possible to collect multiple snapshots in a single trace.","pos":[1053,1120]},{"content":"Resident Sets provide a holistic and instantaneous snapshot of the memory composition on the system.","pos":[1122,1222]},{"content":"Investigations into Resident Set analysis are typically done for the following reasons:","pos":[1223,1310]},{"content":"To understand physical memory usage, especially when physical memory usage is higher than expected.","pos":[1316,1415]},{"content":"To understand the sources of process private working set, especially when the process private working set is larger than expected.","pos":[1421,1551]},{"content":"System responsiveness issues due to paging activity.","pos":[1557,1609]},{"content":"Step 1: Collect data using the Assessment Toolkit","pos":[1614,1663]},{"content":"The <bpt id=\"p1\">**</bpt>Windows Assessment Toolkit<ept id=\"p1\">**</ept> contains a test to measure the memory footprint after boot.","pos":[1666,1760]},{"content":"You can use the <bpt id=\"p1\">**</bpt>Memory Footprint<ept id=\"p1\">**</ept> assessment results to gather a baseline of the image software preload.","pos":[1761,1868]},{"content":"Many processes and services are always in use and take up memory.","pos":[1869,1934]},{"content":"This assessment helps you to see how drivers and applications (that always run) impact the boot process.","pos":[1935,2039]},{"pos":[2045,2111],"content":"Open <bpt id=\"p1\">**</bpt>Windows Assessment Console (WAC)<ept id=\"p1\">**</ept> from the <bpt id=\"p2\">**</bpt>Start<ept id=\"p2\">**</ept> menu."},{"pos":[2117,2166],"content":"Open the <bpt id=\"p1\">**</bpt>Options<ept id=\"p1\">**</ept> menu and select <bpt id=\"p2\">**</bpt>New Job…<ept id=\"p2\">**</ept>"},{"pos":[2176,2213],"content":"Enter <bpt id=\"p1\">**</bpt>MemoryTest<ept id=\"p1\">**</ept> as the job name."},{"pos":[2223,2254],"content":"Select <bpt id=\"p1\">**</bpt>Create a custom job.<ept id=\"p1\">**</ept>"},{"pos":[2260,2289],"content":"Click on <bpt id=\"p1\">**</bpt>Add Assessments.<ept id=\"p1\">**</ept>"},{"pos":[2299,2368],"content":"Add the <bpt id=\"p1\">**</bpt>Memory Footprint<ept id=\"p1\">**</ept> assessment by clicking on the “+” symbol"},{"pos":[2374,2463],"content":"Click on the newly added <bpt id=\"p1\">**</bpt>Memory Footprint<ept id=\"p1\">**</ept> assessment to enter the test configuration."},{"pos":[2469,2554],"content":"Unselect <bpt id=\"p1\">**</bpt>Use recommended settings<ept id=\"p1\">**</ept> and select <bpt id=\"p2\">**</bpt>Quick Run<ept id=\"p2\">**</ept> for the configuration."},{"pos":[2564,2666],"content":"<bpt id=\"p1\">**</bpt>Quick Run<ept id=\"p1\">**</ept> allows the test to complete in a shorter amount of time at the expense of data accuracy."},{"pos":[2713,2763],"content":"With <bpt id=\"p1\">**</bpt>Quick Run<ept id=\"p1\">**</ept> selected, you have two options:"},{"content":"<bpt id=\"p1\">**</bpt>Package<ept id=\"p1\">**</ept> the job in order to create a folder that has all the test resources and copy it to another test system.","pos":[2773,2888]},{"content":"(Click on the <bpt id=\"p1\">**</bpt>Package…<ept id=\"p1\">**</ept>","pos":[2889,2915]},{"content":"button in the bottom right corner to choose this option.)","pos":[2916,2973]},{"content":"<bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> the job directly on the system.","pos":[2983,3022]},{"content":"(Click on the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> button in the bottom right corner to choose this option.)","pos":[3023,3102]},{"content":"This restarts the system to gather a trace.","pos":[3116,3159]},{"content":"This test can take some 15-20 minutes to complete.","pos":[3173,3223]},{"pos":[3229,3256],"content":"We want the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> option."},{"content":"Step 2: Visualize the Memory Footprint assessment results using WAC","pos":[3261,3328]},{"content":"Once the assessment is done, you can open the results XML file that contains a summary of the memory usage on the system.","pos":[3331,3452]},{"content":"Step 2.1: Open the memory report","pos":[3458,3490]},{"pos":[3496,3562],"content":"In <bpt id=\"p1\">**</bpt>WAC<ept id=\"p1\">**</ept>, open the <bpt id=\"p2\">**</bpt>Options<ept id=\"p2\">**</ept> menu and select <bpt id=\"p3\">**</bpt>Open Results…<ept id=\"p3\">**</ept>"},{"pos":[3572,3618],"content":"You can also press <bpt id=\"p1\">**</bpt>CTRL+R<ept id=\"p1\">**</ept> on the keyboard."},{"content":"Click on the <bpt id=\"p1\">**</bpt>Browse…<ept id=\"p1\">**</ept>","pos":[3624,3648]},{"content":"button.","pos":[3649,3656]},{"content":"Navigate to the folder where you stored the assessment you created in Step 1.","pos":[3662,3739]},{"content":"Open the assessment you created in Step 1.","pos":[3745,3787]},{"content":"The report contains different categories to help you understand the driver and process contributions to the overall memory footprint.","pos":[3793,3926]},{"content":"The report should look something like this.","pos":[3932,3975]},{"pos":[4022,4146],"content":"Take the time to familiarize yourself with the report by looking at the <bpt id=\"p1\">**</bpt>Driver<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Process Private Pages<ept id=\"p2\">**</ept> categories."},{"content":"In the preceding example, 1487 MB of memory is used out of 4 GB of physical RAM.","pos":[4148,4228]},{"content":"Memory In Use = Process working sets + non-paged memory + modified pages","pos":[4234,4306]},{"content":"Available memory = Standby memory + free memory","pos":[4312,4359]},{"content":"In the preceding example, the biggest consumers of memory usage are driver allocations with 267 MB for non-paged, and 613 MB for process private pages (private working sets).","pos":[4361,4535]},{"pos":[4537,4693],"content":"For more information about the metrics, see the <bpt id=\"p1\">[</bpt>Results for the Memory Footprint Assessment<ept id=\"p1\">](https://go.microsoft.com/fwlink/?linkid=619204)</ept> topic on MSDN."},{"content":"Step 2.2: Review driver non-paged allocations","pos":[4699,4744]},{"content":"This metric is similar to the paged allocations except that these allocations use physical memory that cannot be paged out.","pos":[4746,4869]},{"content":"This reflects physical memory that is pinned and therefore unavailable for paged memory or use by other processes and services.","pos":[4870,4997]},{"content":"Acquiring too much non-paged memory reduces the amount of memory that backed memory can use.","pos":[4998,5090]},{"pos":[5096,5186],"content":"Expand the <bpt id=\"p1\">**</bpt>Driver Non-Paged Allocations<ept id=\"p1\">**</ept> category by clicking on the arrow on the left."},{"pos":[5192,5240],"content":"Expand the <bpt id=\"p1\">**</bpt>DriverLockedSystemPages<ept id=\"p1\">**</ept> category."},{"content":"This is memory loaded in from paged memory and then locked by the driver until it is no longer useful.","pos":[5250,5352]},{"content":"Identify the driver with the biggest memory usage.","pos":[5358,5408]},{"content":"You can influence this metric by swapping out hardware or software drivers that have lower memory requirements.","pos":[5451,5562]},{"content":"The driver vendor has the most influence over this metric by the way the driver is designed.","pos":[5564,5656]},{"content":"Look for large memory allocations in the results presented in <bpt id=\"p1\">**</bpt>WAC<ept id=\"p1\">**</ept>.","pos":[5657,5727]},{"content":"In addition, the driver vendors can be given performance traces (stored in the same directory as the assessment results and can be analyzed with <bpt id=\"p1\">**</bpt>WPA<ept id=\"p1\">**</ept>) of this assessment to find areas of heavy memory allocation that are candidates for investigations into reducing memory use.","pos":[5728,6006]},{"content":"Step 2.3: Review process private working sets","pos":[6012,6057]},{"content":"The largest users of the overall memory footprint are apps that may always be running in the background without the user’s knowledge.","pos":[6059,6192]},{"content":"To view the amount of memory that processes use, you can use the <bpt id=\"p1\">**</bpt>Process Private Pages<ept id=\"p1\">**</ept> category in the report.","pos":[6193,6307]},{"pos":[6313,6396],"content":"Expand the <bpt id=\"p1\">**</bpt>Process Private Pages<ept id=\"p1\">**</ept> category by clicking on the arrow on the left."},{"content":"Expand the <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept> category.","pos":[6402,6433]},{"content":"The list shows the binaries and their usage of active memory.","pos":[6434,6495]},{"content":"Your view should look something like this:","pos":[6501,6543]},{"content":"Identify the process that uses the most memory.","pos":[6590,6637]},{"content":"You can influence this metric by reducing the number of “run always” applications, which are applications in the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> registry key or <bpt id=\"p2\">**</bpt>Startup<ept id=\"p2\">**</ept> folder.","pos":[6639,6795]},{"content":"Analyze the impact of added apps.","pos":[6796,6829]},{"content":"Driver and software vendors have the most influence over this metric by the way their code is designed.","pos":[6831,6934]},{"content":"Look for large memory allocations in the results presented in the <bpt id=\"p1\">**</bpt>WAC<ept id=\"p1\">**</ept>.","pos":[6935,7009]},{"content":"In addition, software vendors can be given performance traces (stored in the same directory as the assessment results) of this assessment to find areas of heavy memory allocations that are candidates for investigations into reducing memory use.","pos":[7010,7254]},{"content":"Careful analyses of allocations, even small ones, can help the developer to find allocations that add up.","pos":[7255,7360]},{"pos":[7430,7473],"content":"Step 3: Collect Resident Set data using WPR"},{"content":"In steps 1 and 2, you learned how to gather memory traces using the <bpt id=\"p1\">**</bpt>Assessment Toolkit Memory Footprint<ept id=\"p1\">**</ept> assessment.","pos":[7476,7595]},{"content":"This assessment can solely capture a trace for the boot scenario.","pos":[7596,7661]},{"content":"You can capture traces for any scenario (app launch, web browsing, etc.) using the <bpt id=\"p1\">**</bpt>Windows Performance Recorder (WPR)<ept id=\"p1\">**</ept>","pos":[7662,7783]},{"content":"Follow these steps to gather a trace with Resident Set data.","pos":[7785,7845]},{"pos":[7851,7913],"content":"Open <bpt id=\"p1\">**</bpt>Windows Performance Recorder<ept id=\"p1\">**</ept> from the <bpt id=\"p2\">**</bpt>Start<ept id=\"p2\">**</ept> menu."},{"pos":[7919,8057],"content":"Select the <bpt id=\"p1\">**</bpt>\"First Level Triage\"<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>\"Resident Set analysis\"<ept id=\"p2\">**</ept> recording profiles, but keep the default values for the other options."},{"pos":[8063,8102],"content":"Click <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> and wait a few seconds."},{"pos":[8149,8199],"content":"Click <bpt id=\"p1\">**</bpt>Save<ept id=\"p1\">**</ept> and save the <bpt id=\"p2\">**</bpt>ETL<ept id=\"p2\">**</ept> trace to disk."},{"content":"You now have a snapshot of the system memory composition.","pos":[8201,8258]},{"content":"Step 4: Interpret Resident Set data using WPA","pos":[8263,8308]},{"content":"Follow this procedure:","pos":[8311,8333]},{"pos":[8339,8403],"content":"Launch <bpt id=\"p1\">**</bpt>Windows Performance Analyzer<ept id=\"p1\">**</ept> from the <bpt id=\"p2\">**</bpt>Start<ept id=\"p2\">**</ept> menu."},{"pos":[8409,8477],"content":"Open the <bpt id=\"p1\">**</bpt>ETL<ept id=\"p1\">**</ept> trace you just gathered (<bpt id=\"p2\">**</bpt>File<ept id=\"p2\">**</ept> menu, <bpt id=\"p3\">**</bpt>Open…<ept id=\"p3\">**</ept>)."},{"pos":[8483,8535],"content":"Expand the <bpt id=\"p1\">**</bpt>Memory<ept id=\"p1\">**</ept> set in the <bpt id=\"p2\">**</bpt>Graph Explorer<ept id=\"p2\">**</ept>."},{"pos":[8582,8645],"content":"Drag and drop the <bpt id=\"p1\">**</bpt>Resident Set<ept id=\"p1\">**</ept> graph into the Analysis tab."},{"content":"Your view should look something like this:","pos":[8647,8689]},{"content":"Review how the data is presented.","pos":[8728,8761]},{"content":"Here are some definitions of the most helpful columns to perform top level analysis:","pos":[8762,8846]},{"content":"Column","pos":[8951,8957]},{"content":"Definition","pos":[8967,8977]},{"content":"MMList","pos":[9035,9041]},{"content":"The memory management list that contains the pages.","pos":[9063,9114]},{"content":"Active<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages currently within a process private working set or kernel working set.","pos":[9147,9240]},{"content":"Standby<ph id=\"ph1\">&lt;/strong&gt;</ph> – Unmodified pages on the standby list.","pos":[9265,9321]},{"content":"They are part of the available memory.","pos":[9322,9360]},{"content":"Modified<ph id=\"ph1\">&lt;/strong&gt;</ph> – Process private or file backed pages that were modified since last being persisted to permanent storage.","pos":[9385,9509]},{"content":"ModifiedNoWrite<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages that were modified but will not be persisted to permanent storage.","pos":[9534,9633]},{"content":"Transition<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages in transition between lists.","pos":[9658,9714]},{"content":"Process","pos":[9771,9778]},{"content":"The name of the process that is the owner of the pages.","pos":[9800,9855]},{"content":"This information is available only for process private pages.","pos":[9856,9917]},{"content":"Even if they are not shared, all shareable pages are associated with the “Unknown” (-1) process.","pos":[9918,10014]},{"content":"Description","pos":[10059,10070]},{"content":"The value represented varies depending on the page category.","pos":[10092,10152]},{"content":"For example:","pos":[10153,10165]},{"content":"For images, drivers, files, etc, it displays the full file path and name.","pos":[10190,10263]},{"content":"For <ph id=\"ph1\">&lt;strong&gt;</ph>Pool<ph id=\"ph2\">&lt;/strong&gt;</ph> memory, it shows the driver pool tag name.","pos":[10280,10348]},{"content":"Page Category","pos":[10405,10418]},{"content":"The type of data contained within the page as defined below.","pos":[10440,10500]},{"content":"Some of the possible categories are:","pos":[10501,10537]},{"content":"CopyOnWriteImage<ph id=\"ph1\">&lt;/strong&gt;</ph> – Process private pages created by the patching of an executable images import address table or rebasing of an executable.","pos":[10570,10718]},{"content":"Driver<ph id=\"ph1\">&lt;/strong&gt;</ph> – Code pages for a driver.","pos":[10743,10785]},{"content":"DriverFile<ph id=\"ph1\">&lt;/strong&gt;</ph> – Code pages that were read from the driver executable and mapped as data.","pos":[10810,10904]},{"content":"DriverLockedSystemPage<ph id=\"ph1\">&lt;/strong&gt;</ph> – Kernel mode pages that are locked or pinned in memory, typically by drivers or the kernel.","pos":[10929,11053]},{"content":"Image<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages from .dll and .exe files loaded as executable images.","pos":[11078,11154]},{"content":"MapFile<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages of data files or images loaded as data.","pos":[11179,11243]},{"content":"NonPagedPool<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages that contain data for the non-pageable system pool.","pos":[11268,11349]},{"content":"PagedPool<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages that contain data for the pageable system pool.","pos":[11374,11448]},{"content":"PFMappedSection<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages of memory-mapped sections backed by the page file.","pos":[11473,11556]},{"content":"SystemPage<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages that contain system page table entries used to map system pages such as I/O space, kernel stacks, and memory descriptor lists.","pos":[11581,11735]},{"content":"UserStack<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages that contain the user mode data for each thread.","pos":[11760,11835]},{"content":"VirtualAlloc<ph id=\"ph1\">&lt;/strong&gt;</ph> – Pages allocated by the VirtualAlloc APIs.","pos":[11860,11925]},{"content":"Win32Heap<ph id=\"ph1\">&lt;/strong&gt;</ph> – Heap pages.","pos":[11950,11982]},{"content":"Size (MB)","pos":[12038,12047]},{"content":"The total size of the pages aggregated in each category.","pos":[12069,12125]},{"content":"Step 6: Identify process working sets that impact the memory footprint","pos":[12166,12236]},{"content":"Resident Set data can be displayed in many different ways based on the column arrangements in the summary table.","pos":[12239,12351]},{"content":"The summary table has several pre-defined column arrangements that you can use as starting points for an investigation.","pos":[12352,12471]},{"pos":[12477,12527],"content":"Select the <bpt id=\"p1\">**</bpt>Process Private Working Set<ept id=\"p1\">**</ept> preset."},{"pos":[12574,12609],"content":"Expand the <bpt id=\"p1\">**</bpt>Active MMList<ept id=\"p1\">**</ept> group."},{"pos":[12619,12701],"content":"Focus on the <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept> category as it is what’s currently impacting memory usage."},{"pos":[12711,12766],"content":"<bpt id=\"p1\">**</bpt>Standby<ept id=\"p1\">**</ept> pages could be freed under memory pressure."},{"pos":[12776,12830],"content":"<bpt id=\"p1\">**</bpt>Modified<ept id=\"p1\">**</ept> pages could be written to disk and freed."},{"pos":[12836,12896],"content":"Sort by size by clicking on the <bpt id=\"p1\">**</bpt>Size (MB)<ept id=\"p1\">**</ept> column header."},{"content":"Identify the processes with the largest usage.","pos":[12902,12948]},{"content":"You might see <bpt id=\"p1\">**</bpt>N/A<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>“Unknown (-1)”<ept id=\"p2\">**</ept> as process names.","pos":[12949,13011]},{"pos":[13021,13103],"content":"<bpt id=\"p1\">**</bpt>N/A<ept id=\"p1\">**</ept> contains pages not associated to any processes such as driver pool memory."},{"pos":[13113,13157],"content":"<bpt id=\"p1\">**</bpt>“Unknown (-1)”<ept id=\"p1\">**</ept> contains shareable pages."},{"pos":[13163,13213],"content":"Expand the processes to look at <bpt id=\"p1\">**</bpt>Page Category<ept id=\"p1\">**</ept>."},{"content":"You can now see the composition of the process working set in the following figure.","pos":[13223,13306]},{"content":"Top categories should be VirtualAlloc or Win32Heap, which we’ll analyze in Exercise 2.","pos":[13316,13402]},{"pos":[13412,13563],"content":"In the example below, <bpt id=\"p1\">**</bpt>SearchIndexer.exe<ept id=\"p1\">**</ept> uses 21.7 MB of active memory through <bpt id=\"p2\">**</bpt>Heap<ept id=\"p2\">**</ept> allocations, and 12.4 MB through <bpt id=\"p3\">**</bpt>VirtualAlloc<ept id=\"p3\">**</ept> API calls."},{"content":"Focus on 3rd-party processes and determine if they need to be launched on boot as part of the preloaded software.","pos":[13607,13720]},{"content":"As a developer, you should analyze the dynamic allocations your process is making to understand where optimizations can be made.","pos":[13721,13849]}],"content":"---\ntitle: Exercise 1 - Identify Processes with Large Working Sets\ndescription: The methodology used to analyze the data can take several approaches and differs based on the circumstances under which the investigation was started.\nMSHAttr:\n- 'PreferredSiteName:MSDN'\n- 'PreferredLib:/library/windows/hardware'\nms.assetid: F77AAF4D-2A0E-440B-8199-69FD1D5E65FE\nms.prod: W10\nms.mktglfcycl: operate\nms.sitesec: msdn\n---\n\n# Exercise 1 - Identify Processes with Large Working Sets\n\n\nThe methodology used to analyze the data can take several approaches and differs based on the circumstances under which the investigation was started. This exercise discusses and presents some example methodologies along with the different views presented by various column arrangements.\n\nThe data referred to as the Resident Set is the set of pages that currently reside in physical memory (RAM). The Resident Set is a snapshot of the current memory state at the end of a trace capture with **Windows Performance Recorder (WPR)** or the Assessment Toolkit Memory assessment. It is not possible to collect multiple snapshots in a single trace.\n\nResident Sets provide a holistic and instantaneous snapshot of the memory composition on the system. Investigations into Resident Set analysis are typically done for the following reasons:\n\n-   To understand physical memory usage, especially when physical memory usage is higher than expected.\n\n-   To understand the sources of process private working set, especially when the process private working set is larger than expected.\n\n-   System responsiveness issues due to paging activity.\n\n## Step 1: Collect data using the Assessment Toolkit\n\n\nThe **Windows Assessment Toolkit** contains a test to measure the memory footprint after boot. You can use the **Memory Footprint** assessment results to gather a baseline of the image software preload. Many processes and services are always in use and take up memory. This assessment helps you to see how drivers and applications (that always run) impact the boot process.\n\n1.  Open **Windows Assessment Console (WAC)** from the **Start** menu.\n\n2.  Open the **Options** menu and select **New Job…**\n\n    1.  Enter **MemoryTest** as the job name.\n\n    2.  Select **Create a custom job.**\n\n3.  Click on **Add Assessments.**\n\n    -   Add the **Memory Footprint** assessment by clicking on the “+” symbol\n\n4.  Click on the newly added **Memory Footprint** assessment to enter the test configuration.\n\n5.  Unselect **Use recommended settings** and select **Quick Run** for the configuration.\n\n    -   **Quick Run** allows the test to complete in a shorter amount of time at the expense of data accuracy.\n\n    ![](images/memoryfootprintlab1.png)\n\n6.  With **Quick Run** selected, you have two options:\n\n    1.  **Package** the job in order to create a folder that has all the test resources and copy it to another test system. (Click on the **Package…** button in the bottom right corner to choose this option.)\n\n    2.  **Run** the job directly on the system. (Click on the **Run** button in the bottom right corner to choose this option.)\n\n        -   This restarts the system to gather a trace.\n\n        -   This test can take some 15-20 minutes to complete.\n\n    We want the **Run** option.\n\n## Step 2: Visualize the Memory Footprint assessment results using WAC\n\n\nOnce the assessment is done, you can open the results XML file that contains a summary of the memory usage on the system.\n\n### Step 2.1: Open the memory report\n\n1.  In **WAC**, open the **Options** menu and select **Open Results…**\n\n    -   You can also press **CTRL+R** on the keyboard.\n\n2.  Click on the **Browse…** button.\n\n3.  Navigate to the folder where you stored the assessment you created in Step 1.\n\n4.  Open the assessment you created in Step 1.\n\n    The report contains different categories to help you understand the driver and process contributions to the overall memory footprint.\n\n    The report should look something like this.\n\n    ![](images/memoryfootprintlab2.png)\n\n5.  Take the time to familiarize yourself with the report by looking at the **Driver** and **Process Private Pages** categories.\n\nIn the preceding example, 1487 MB of memory is used out of 4 GB of physical RAM.\n\n-   Memory In Use = Process working sets + non-paged memory + modified pages\n\n-   Available memory = Standby memory + free memory\n\nIn the preceding example, the biggest consumers of memory usage are driver allocations with 267 MB for non-paged, and 613 MB for process private pages (private working sets).\n\nFor more information about the metrics, see the [Results for the Memory Footprint Assessment](https://go.microsoft.com/fwlink/?linkid=619204) topic on MSDN.\n\n### Step 2.2: Review driver non-paged allocations\n\nThis metric is similar to the paged allocations except that these allocations use physical memory that cannot be paged out. This reflects physical memory that is pinned and therefore unavailable for paged memory or use by other processes and services. Acquiring too much non-paged memory reduces the amount of memory that backed memory can use.\n\n1.  Expand the **Driver Non-Paged Allocations** category by clicking on the arrow on the left.\n\n2.  Expand the **DriverLockedSystemPages** category.\n\n    -   This is memory loaded in from paged memory and then locked by the driver until it is no longer useful.\n\n3.  Identify the driver with the biggest memory usage.\n\n    ![](images/memoryfootprintlab3.png)\n\nYou can influence this metric by swapping out hardware or software drivers that have lower memory requirements.\n\nThe driver vendor has the most influence over this metric by the way the driver is designed. Look for large memory allocations in the results presented in **WAC**. In addition, the driver vendors can be given performance traces (stored in the same directory as the assessment results and can be analyzed with **WPA**) of this assessment to find areas of heavy memory allocation that are candidates for investigations into reducing memory use.\n\n### Step 2.3: Review process private working sets\n\nThe largest users of the overall memory footprint are apps that may always be running in the background without the user’s knowledge. To view the amount of memory that processes use, you can use the **Process Private Pages** category in the report.\n\n1.  Expand the **Process Private Pages** category by clicking on the arrow on the left.\n\n2.  Expand the **Active** category. The list shows the binaries and their usage of active memory.\n\n    Your view should look something like this:\n\n    ![](images/memoryfootprintlab4.png)\n\n3.  Identify the process that uses the most memory.\n\nYou can influence this metric by reducing the number of “run always” applications, which are applications in the **Run** registry key or **Startup** folder. Analyze the impact of added apps.\n\nDriver and software vendors have the most influence over this metric by the way their code is designed. Look for large memory allocations in the results presented in the **WAC**. In addition, software vendors can be given performance traces (stored in the same directory as the assessment results) of this assessment to find areas of heavy memory allocations that are candidates for investigations into reducing memory use. Careful analyses of allocations, even small ones, can help the developer to find allocations that add up.\n\n## <a href=\"\" id=\"step-3--collect-resident-set-data-using-wpr-\"></a>Step 3: Collect Resident Set data using WPR\n\n\nIn steps 1 and 2, you learned how to gather memory traces using the **Assessment Toolkit Memory Footprint** assessment. This assessment can solely capture a trace for the boot scenario. You can capture traces for any scenario (app launch, web browsing, etc.) using the **Windows Performance Recorder (WPR)**\n\nFollow these steps to gather a trace with Resident Set data.\n\n1.  Open **Windows Performance Recorder** from the **Start** menu.\n\n2.  Select the **\"First Level Triage\"** and **\"Resident Set analysis\"** recording profiles, but keep the default values for the other options.\n\n3.  Click **Start** and wait a few seconds.\n\n    ![](images/memoryfootprintlab5.png)\n\n4.  Click **Save** and save the **ETL** trace to disk.\n\nYou now have a snapshot of the system memory composition.\n\n## Step 4: Interpret Resident Set data using WPA\n\n\nFollow this procedure:\n\n1.  Launch **Windows Performance Analyzer** from the **Start** menu.\n\n2.  Open the **ETL** trace you just gathered (**File** menu, **Open…**).\n\n3.  Expand the **Memory** set in the **Graph Explorer**.\n\n    ![](images/memoryfootprintlab7.png)\n\n4.  Drag and drop the **Resident Set** graph into the Analysis tab.\n\nYour view should look something like this:\n\n![](images/memoryfootprintlab8.png)\n\nReview how the data is presented. Here are some definitions of the most helpful columns to perform top level analysis:\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Column</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>MMList</strong></td>\n<td><p>The memory management list that contains the pages.</p>\n<p></p>\n<ul>\n<li><p><strong>Active</strong> – Pages currently within a process private working set or kernel working set.</p></li>\n<li><p><strong>Standby</strong> – Unmodified pages on the standby list. They are part of the available memory.</p></li>\n<li><p><strong>Modified</strong> – Process private or file backed pages that were modified since last being persisted to permanent storage.</p></li>\n<li><p><strong>ModifiedNoWrite</strong> – Pages that were modified but will not be persisted to permanent storage.</p></li>\n<li><p><strong>Transition</strong> – Pages in transition between lists.</p></li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Process</strong></td>\n<td><p>The name of the process that is the owner of the pages. This information is available only for process private pages. Even if they are not shared, all shareable pages are associated with the “Unknown” (-1) process.</p></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Description</strong></td>\n<td><p>The value represented varies depending on the page category. For example:</p>\n<p></p>\n<ul>\n<li><p>For images, drivers, files, etc, it displays the full file path and name.</p></li>\n<li><p>For <strong>Pool</strong> memory, it shows the driver pool tag name.</p></li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Page Category</strong></td>\n<td><p>The type of data contained within the page as defined below. Some of the possible categories are:</p>\n<p></p>\n<ul>\n<li><p><strong>CopyOnWriteImage</strong> – Process private pages created by the patching of an executable images import address table or rebasing of an executable.</p></li>\n<li><p><strong>Driver</strong> – Code pages for a driver.</p></li>\n<li><p><strong>DriverFile</strong> – Code pages that were read from the driver executable and mapped as data.</p></li>\n<li><p><strong>DriverLockedSystemPage</strong> – Kernel mode pages that are locked or pinned in memory, typically by drivers or the kernel.</p></li>\n<li><p><strong>Image</strong> – Pages from .dll and .exe files loaded as executable images.</p></li>\n<li><p><strong>MapFile</strong> – Pages of data files or images loaded as data.</p></li>\n<li><p><strong>NonPagedPool</strong> – Pages that contain data for the non-pageable system pool.</p></li>\n<li><p><strong>PagedPool</strong> – Pages that contain data for the pageable system pool.</p></li>\n<li><p><strong>PFMappedSection</strong> – Pages of memory-mapped sections backed by the page file.</p></li>\n<li><p><strong>SystemPage</strong> – Pages that contain system page table entries used to map system pages such as I/O space, kernel stacks, and memory descriptor lists.</p></li>\n<li><p><strong>UserStack</strong> – Pages that contain the user mode data for each thread.</p></li>\n<li><p><strong>VirtualAlloc</strong> – Pages allocated by the VirtualAlloc APIs.</p></li>\n<li><p><strong>Win32Heap</strong> – Heap pages.</p></li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Size (MB)</strong></td>\n<td><p>The total size of the pages aggregated in each category.</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\n## Step 6: Identify process working sets that impact the memory footprint\n\n\nResident Set data can be displayed in many different ways based on the column arrangements in the summary table. The summary table has several pre-defined column arrangements that you can use as starting points for an investigation.\n\n1.  Select the **Process Private Working Set** preset.\n\n    ![](images/memoryfootprintlab9.png)\n\n2.  Expand the **Active MMList** group.\n\n    1.  Focus on the **Active** category as it is what’s currently impacting memory usage.\n\n    2.  **Standby** pages could be freed under memory pressure.\n\n    3.  **Modified** pages could be written to disk and freed.\n\n3.  Sort by size by clicking on the **Size (MB)** column header.\n\n4.  Identify the processes with the largest usage. You might see **N/A** and **“Unknown (-1)”** as process names.\n\n    -   **N/A** contains pages not associated to any processes such as driver pool memory.\n\n    -   **“Unknown (-1)”** contains shareable pages.\n\n5.  Expand the processes to look at **Page Category**.\n\n    1.  You can now see the composition of the process working set in the following figure.\n\n    2.  Top categories should be VirtualAlloc or Win32Heap, which we’ll analyze in Exercise 2.\n\n    3.  In the example below, **SearchIndexer.exe** uses 21.7 MB of active memory through **Heap** allocations, and 12.4 MB through **VirtualAlloc** API calls.\n\n    ![](images/memoryfootprintlab10.png)\n\nFocus on 3rd-party processes and determine if they need to be launched on boot as part of the preloaded software. As a developer, you should analyze the dynamic allocations your process is making to understand where optimizations can be made.\n\n \n\n \n\n\n\n\n\n\n"}