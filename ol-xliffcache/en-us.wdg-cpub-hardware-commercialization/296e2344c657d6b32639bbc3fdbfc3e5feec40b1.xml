{"nodes":[{"content":"Exercise 3 - Understand Critical Path and Wait Analysis","pos":[11,66]},{"content":"Scenarios and activities can be unexpectedly delayed.","pos":[80,133]},{"content":"For example, opening a tab within Microsoft Edge may sometimes take longer than expected.","pos":[134,223]},{"content":"Exercise 3 - Understand Critical Path and Wait Analysis","pos":[412,467]},{"content":"Scenarios and activities can be unexpectedly delayed.","pos":[470,523]},{"content":"For example, opening a tab within Microsoft Edge may sometimes take longer than expected.","pos":[524,613]},{"content":"An activity is defined as a series of operations, some sequential and some parallel, that flows from a start event to an end event.","pos":[615,746]},{"content":"Any start/end event pair in a trace can be viewed as an activity.","pos":[747,812]},{"content":"The longest path through this series of operations is known as the critical path.","pos":[813,894]},{"content":"Reducing the duration of any operation on the critical path directly reduces the duration of the overall activity.","pos":[895,1009]},{"content":"It is recommended that you identify the process and the thread that completed the activity and work backwards from the time the activity completed.","pos":[1011,1158]},{"content":"Start by analyzing the thread that completed the activity to determine how that thread spent most of its time and in what state: <bpt id=\"p1\">**</bpt>running<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>ready<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>waiting<ept id=\"p3\">**</ept>.","pos":[1159,1327]},{"content":"Significant running times indicate that direct CPU usage might be contributing to the duration of the critical path.","pos":[1329,1445]},{"content":"Time spent in the <bpt id=\"p1\">**</bpt>ready<ept id=\"p1\">**</ept> state indicates that other threads contribute to the duration of the critical path by preventing a thread on the critical path from executing.","pos":[1446,1616]},{"content":"Time spent <bpt id=\"p1\">**</bpt>waiting<ept id=\"p1\">**</ept> points to I/O, timers, or other threads and processes on the critical path for which the current thread was waiting.","pos":[1617,1756]},{"content":"Each thread that readies the current thread is probably another link in the critical path and can also be analyzed until the duration of the critical path is accounted for.","pos":[1758,1930]},{"content":"All the required information is recorded in the <bpt id=\"p1\">**</bpt>CPU Usage (Precise)<ept id=\"p1\">**</ept> graph and table in <bpt id=\"p2\">**</bpt>WPA<ept id=\"p2\">**</ept>.","pos":[1932,2031]},{"content":"CPU usage events that are logged by the dispatcher are associated with context switches.","pos":[2032,2120]},{"content":"This table focuses on <bpt id=\"p1\">**</bpt>NewThread<ept id=\"p1\">**</ept> which is the thread that was switched in, and each row represents a context switch.","pos":[2121,2240]},{"content":"Data is collected for the following event sequence:","pos":[2241,2292]},{"pos":[2342,2404],"content":"<bpt id=\"p1\">**</bpt>NewThread<ept id=\"p1\">**</ept> is switched out due to a blocking function call."},{"pos":[2410,2468],"content":"<bpt id=\"p1\">**</bpt>NewThread<ept id=\"p1\">**</ept> is made ready to run by the readying thread."},{"pos":[2474,2540],"content":"<bpt id=\"p1\">**</bpt>NewThread<ept id=\"p1\">**</ept> is switched in, thereby switching out an old thread."},{"pos":[2546,2582],"content":"<bpt id=\"p1\">**</bpt>NewThread<ept id=\"p1\">**</ept> is switched out again."},{"pos":[2584,2654],"content":"Here are the interesting columns in the <bpt id=\"p1\">**</bpt>CPU Usage (Precise)<ept id=\"p1\">**</ept> table."},{"content":"Column","pos":[2658,2664]},{"content":"Details","pos":[2681,2688]},{"content":"% CPU Usage","pos":[3026,3037]},{"content":"The CPU usage of the new thread after it is switched.","pos":[3047,3100]},{"content":"This value is expressed as a percentage of the total CPU time over the currently visible time period.","pos":[3101,3202]},{"content":"Count","pos":[3209,3214]},{"content":"The number of context switches that are represented by the row.","pos":[3230,3293]},{"content":"This is always 1 for individual rows.","pos":[3294,3331]},{"content":"CPU Usage (ms)","pos":[3392,3406]},{"content":"The CPU usage of the new thread after the context switch.","pos":[3413,3470]},{"content":"NewProcess","pos":[3575,3585]},{"content":"The process of the new thread.","pos":[3596,3626]},{"content":"NewThreadId","pos":[3758,3769]},{"content":"The thread ID of the new thread.","pos":[3779,3811]},{"content":"NewThreadStack","pos":[3941,3955]},{"content":"The stack of the new thread when it is switched in.","pos":[3962,4013]},{"content":"Usually indicates what the thread was blocked or waiting on.","pos":[4014,4074]},{"content":"Ready(s)","pos":[4124,4132]},{"content":"The time that the thread spent in the Ready queue (due to pre-emption or CPU starvation).","pos":[4145,4234]},{"content":"ReadyingThreadId","pos":[4307,4323]},{"content":"The thread ID of the readying thread.","pos":[4328,4365]},{"content":"ReadyingProcess","pos":[4490,4505]},{"content":"The process that owns the readying thread.","pos":[4511,4553]},{"content":"ReadyThreadStack","pos":[4673,4689]},{"content":"The stack of the readying thread.","pos":[4694,4727]},{"content":"ReadyTime (s)","pos":[4856,4869]},{"content":"The time when the new thread was readied.","pos":[4877,4918]},{"content":"SwitchInTime(s)","pos":[5039,5054]},{"content":"The time when the new thread was switched in.","pos":[5060,5105]},{"content":"Waits (s)","pos":[5222,5231]},{"content":"The amount of time a thread waited on a logical or physical resource.","pos":[5243,5312]},{"content":"The wait ends when <bpt id=\"p1\">**</bpt>NewThreadId<ept id=\"p1\">**</ept> is signaled by <bpt id=\"p2\">**</bpt>ReadyingThreadId<ept id=\"p2\">**</ept>.","pos":[5313,5384]},{"content":"Step 1: Capture and open a trace for a UI delay problem","pos":[5408,5463]},{"content":"This exercise will focus on a dummy process with an unresponsive UI.","pos":[5466,5534]},{"content":"The process is a simple Windows Form application with a button and a text box.","pos":[5535,5613]},{"content":"When the button is clicked, the UI becomes unresponsive for 20 seconds until the text box is updated.","pos":[5614,5715]},{"content":"You will analyze the critical path of this operation.","pos":[5716,5769]},{"pos":[5819,5951],"content":"Download <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept> from <bpt id=\"p2\">[</bpt>here<ept id=\"p2\">](http://download.microsoft.com/download/9/C/5/9C562A35-2E52-4CAE-A662-753486C13F4A/UIDelay.exe)</ept>."},{"pos":[5957,5980],"content":"Launch <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept>."},{"pos":[5986,6023],"content":"Open <bpt id=\"p1\">**</bpt>WPR<ept id=\"p1\">**</ept> from the <bpt id=\"p2\">**</bpt>Start<ept id=\"p2\">**</ept> menu."},{"content":"Modify the tracing configuration.","pos":[6029,6062]},{"pos":[6072,6120],"content":"Select <bpt id=\"p1\">**</bpt>First Level Triage<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CPU Usage<ept id=\"p2\">**</ept>."},{"pos":[6130,6177],"content":"Select <bpt id=\"p1\">**</bpt>General<ept id=\"p1\">**</ept> as the performance scenario."},{"pos":[6187,6226],"content":"Select <bpt id=\"p1\">**</bpt>Verbose<ept id=\"p1\">**</ept> as the detail level."},{"pos":[6284,6303],"content":"Click on <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept>."},{"pos":[6309,6359],"content":"In <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept>, click on the <bpt id=\"p2\">**</bpt>Click<ept id=\"p2\">**</ept> button."},{"content":"Wait until the text box shows “Done!”","pos":[6369,6406]},{"pos":[6412,6464],"content":"In <bpt id=\"p1\">**</bpt>WPR<ept id=\"p1\">**</ept>, save the trace and open it with <bpt id=\"p2\">**</bpt>WPA.<ept id=\"p2\">**</ept>"},{"pos":[6470,6532],"content":"Open the <bpt id=\"p1\">**</bpt>Trace<ept id=\"p1\">**</ept> menu and select <bpt id=\"p2\">**</bpt>Configure symbols path<ept id=\"p2\">**</ept>."},{"content":"Specify the path of the symbol cache.","pos":[6542,6579]},{"content":"For more information on symbols, see the <bpt id=\"p1\">[</bpt>Symbol Support<ept id=\"p1\">](https://go.microsoft.com/fwlink/?linkid=623019)</ept> page on MSDN.","pos":[6580,6699]},{"pos":[6705,6757],"content":"Open the <bpt id=\"p1\">**</bpt>Trace<ept id=\"p1\">**</ept> menu and select <bpt id=\"p2\">**</bpt>Load symbols<ept id=\"p2\">**</ept>."},{"content":"Step 2: Identify the delayed UI thread","pos":[6762,6800]},{"content":"Before performing critical path analysis, you must first identify the activity start and stop events.","pos":[6803,6904]},{"pos":[6910,6997],"content":"Find the <bpt id=\"p1\">**</bpt>UI Delays<ept id=\"p1\">**</ept> graph in the <bpt id=\"p2\">**</bpt>System Activity<ept id=\"p2\">**</ept> node of the <bpt id=\"p3\">**</bpt>Graph Explorer<ept id=\"p3\">**</ept>."},{"pos":[7051,7109],"content":"Drag and drop the <bpt id=\"p1\">**</bpt>UI Delays<ept id=\"p1\">**</ept> graph in the analysis tab."},{"pos":[7115,7148],"content":"Find the <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept> process."},{"content":"Its duration should be around 20 seconds.","pos":[7158,7199]},{"content":"This indicates that there was a delay of 20 seconds on the UI thread of <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept>.","pos":[7200,7288]},{"content":"The UI thread identifier is shown in the <bpt id=\"p1\">**</bpt>Thread Id<ept id=\"p1\">**</ept> column.","pos":[7298,7360]},{"content":"In this example, it is 24174.","pos":[7361,7390]},{"content":"This value will be different in the trace you’ve captured on your machine.","pos":[7391,7465]},{"content":"Make sure to note the thread ID.","pos":[7466,7498]},{"pos":[7556,7629],"content":"Select the entire <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept> time interval, right-click and zoom in."},{"content":"You should always zoom in the regions you’re trying to analyze.","pos":[7679,7742]},{"content":"It reduces the amount of noise introduced by unrelated activities.","pos":[7743,7809]},{"content":"Step 3: Analyze the UI delay critical path","pos":[7814,7856]},{"content":"Now that you have an analysis starting point with the thread ID and the timestamps, you can start digging into the activity critical path to understand the sequence of events that lead to a 20 seconds delay on the UI thread.","pos":[7859,8083]},{"pos":[8085,8200],"content":"The <bpt id=\"p1\">**</bpt>NewThreadId<ept id=\"p1\">**</ept> for this step is the thread you identified in Step 2 (Thread 24174 in <bpt id=\"p2\">**</bpt>UIDelay.exe<ept id=\"p2\">**</ept> process)."},{"pos":[8206,8324],"content":"Add the <bpt id=\"p1\">**</bpt>CPU Usage (Precise)<ept id=\"p1\">**</ept> graph to the <bpt id=\"p2\">**</bpt>analysis<ept id=\"p2\">**</ept> tab and apply the <bpt id=\"p3\">**</bpt>Utilization by Process, Thread<ept id=\"p3\">**</ept> preset."},{"pos":[8378,8503],"content":"Right-click the column headers and make the <bpt id=\"p1\">**</bpt>NewThreadStack<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>ReadyThreadStack<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>CPU Usage (ms)<ept id=\"p3\">**</ept> columns visible."},{"content":"Remove the <bpt id=\"p1\">**</bpt>Ready (us) <ph id=\"ph1\">\\[</ph>Max<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Waits (us) <ph id=\"ph3\">\\[</ph>Max<ph id=\"ph4\">\\]</ph><ept id=\"p2\">**</ept> columns.","pos":[8509,8578]},{"content":"Your viewport should now look like this.","pos":[8579,8619]},{"pos":[8673,8814],"content":"Find and expand the <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept> process in the <bpt id=\"p2\">**</bpt>NewProcess<ept id=\"p2\">**</ept> column and sort by <bpt id=\"p3\">**</bpt>Waits (us) <ph id=\"ph1\">\\[</ph>Sum<ph id=\"ph2\">\\]</ph><ept id=\"p3\">**</ept> by clicking on the column header."},{"pos":[8820,8950],"content":"Search for the <bpt id=\"p1\">**</bpt>NewThreadId<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>UIDelay.exe<ept id=\"p2\">**</ept> process, and analyze its time spent in the Running, Ready, or Waiting state."},{"content":"In the following example, you can find that:","pos":[8960,9004]},{"content":"The thread is consuming 10.025 seconds of CPU time.","pos":[9018,9069]},{"content":"The thread is waiting for 5.159 seconds.","pos":[9083,9123]},{"content":"The thread is in the ready state for a negligible amount of time (10ms).","pos":[9137,9209]},{"pos":[9267,9471],"content":"**Note**  \nYou can analyze the 10 seconds of CPU activity using the same methodology described in Exercise 2, Step 4 using the **CPU Usage (sampled)** graph and looking at the **UIDelay.exe** process.","leadings":["","    "],"nodes":[{"content":"Note","pos":[2,6]},{"content":"You can analyze the 10 seconds of CPU activity using the same methodology described in Exercise 2, Step 4 using the <bpt id=\"p1\">**</bpt>CPU Usage (sampled)<ept id=\"p1\">**</ept> graph and looking at the <bpt id=\"p2\">**</bpt>UIDelay.exe<ept id=\"p2\">**</ept> process.","pos":[11,200]}]},{"pos":[9484,9605],"content":"To discover what the <bpt id=\"p1\">**</bpt>NewThreadId<ept id=\"p1\">**</ept> was waiting for, expand the <bpt id=\"p2\">**</bpt>NewThreadId<ept id=\"p2\">**</ept> group to display the <bpt id=\"p3\">**</bpt>NewThreadStack<ept id=\"p3\">**</ept>."},{"pos":[9611,9680],"content":"Expand <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\[</ph>Root<ph id=\"ph2\">\\]</ph><ept id=\"p1\">**</ept> and identify the function calls leading to waits."},{"pos":[9730,9890],"content":"In this example, <bpt id=\"p1\">**</bpt>UIDelay.exe<ept id=\"p1\">**</ept> thread ID 24174 is waiting on underlying blocking function calls for 5.073 seconds when the button click function is triggered:"},{"pos":[9896,9975],"content":"5.021 seconds are due to operations underneath the <bpt id=\"p1\">**</bpt>ExecuteWMICall<ept id=\"p1\">**</ept> function."},{"pos":[9981,10048],"content":"35 ms are due to operations underneath the <bpt id=\"p1\">**</bpt>PingServer<ept id=\"p1\">**</ept> function."},{"content":"Step 3.1: Look at the ExecuteWMICall code path","pos":[10054,10100]},{"pos":[10102,10270],"content":"If you expand the call stack further under <bpt id=\"p1\">**</bpt>ExecuteWMICall<ept id=\"p1\">**</ept>, you’ll find that the UI thread is actually sleeping for 5 seconds by explicitly calling <bpt id=\"p2\">**</bpt>Thread.Sleep<ept id=\"p2\">**</ept>."},{"content":"This kind of behavior should be avoided at all cost as it directly impacts responsiveness.","pos":[10316,10406]},{"content":"If the code needs to wait for information, it should do it asynchronously on a separate thread and use an event-driven method.","pos":[10407,10533]},{"content":"Step 3.2: Look at the PingServer code","pos":[10538,10575]},{"pos":[10578,10741],"content":"If you expand the call stack further under <bpt id=\"p1\">**</bpt>PingServer<ept id=\"p1\">**</ept>, you’ll find that the UI thread has I/O dependencies as it is sending <bpt id=\"p2\">**</bpt>Ping<ept id=\"p2\">**</ept> commands over the network."},{"content":"While the delay is very small (35 ms), it should be avoided on a UI thread.","pos":[10787,10862]},{"content":"Keep in mind that the average person will notice any UI delay larger than 100 ms.","pos":[10863,10944]},{"content":"This operation could increase the total activity elapsed time above 100 ms, resulting in users having a bad perception of responsiveness.","pos":[10945,11082]},{"content":"Those operations should happen asynchronously on a separate thread and not block the UI.","pos":[11084,11172]}],"content":"---\ntitle: Exercise 3 - Understand Critical Path and Wait Analysis\ndescription: Scenarios and activities can be unexpectedly delayed. For example, opening a tab within Microsoft Edge may sometimes take longer than expected.\nMSHAttr:\n- 'PreferredSiteName:MSDN'\n- 'PreferredLib:/library/windows/hardware'\nms.assetid: C17DDC73-DE68-4C4A-9968-08C5FE90CC7E\nms.prod: W10\nms.mktglfcycl: operate\nms.sitesec: msdn\n---\n\n# Exercise 3 - Understand Critical Path and Wait Analysis\n\n\nScenarios and activities can be unexpectedly delayed. For example, opening a tab within Microsoft Edge may sometimes take longer than expected.\n\nAn activity is defined as a series of operations, some sequential and some parallel, that flows from a start event to an end event. Any start/end event pair in a trace can be viewed as an activity. The longest path through this series of operations is known as the critical path. Reducing the duration of any operation on the critical path directly reduces the duration of the overall activity.\n\nIt is recommended that you identify the process and the thread that completed the activity and work backwards from the time the activity completed. Start by analyzing the thread that completed the activity to determine how that thread spent most of its time and in what state: **running**, **ready**, or **waiting**.\n\nSignificant running times indicate that direct CPU usage might be contributing to the duration of the critical path. Time spent in the **ready** state indicates that other threads contribute to the duration of the critical path by preventing a thread on the critical path from executing. Time spent **waiting** points to I/O, timers, or other threads and processes on the critical path for which the current thread was waiting.\n\nEach thread that readies the current thread is probably another link in the critical path and can also be analyzed until the duration of the critical path is accounted for.\n\nAll the required information is recorded in the **CPU Usage (Precise)** graph and table in **WPA**. CPU usage events that are logged by the dispatcher are associated with context switches. This table focuses on **NewThread** which is the thread that was switched in, and each row represents a context switch. Data is collected for the following event sequence:\n\n![](images/optimizingperformancelab25.png)\n\n1.  **NewThread** is switched out due to a blocking function call.\n\n2.  **NewThread** is made ready to run by the readying thread.\n\n3.  **NewThread** is switched in, thereby switching out an old thread.\n\n4.  **NewThread** is switched out again.\n\nHere are the interesting columns in the **CPU Usage (Precise)** table.\n\n| Column               | Details                                                                                                                                                     |\n|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **% CPU Usage**      | The CPU usage of the new thread after it is switched. This value is expressed as a percentage of the total CPU time over the currently visible time period. |\n| **Count**            | The number of context switches that are represented by the row. This is always 1 for individual rows.                                                       |\n| **CPU Usage (ms)**   | The CPU usage of the new thread after the context switch.                                                                                                   |\n| **NewProcess**       | The process of the new thread.                                                                                                                              |\n| **NewThreadId**      | The thread ID of the new thread.                                                                                                                            |\n| **NewThreadStack**   | The stack of the new thread when it is switched in. Usually indicates what the thread was blocked or waiting on.                                            |\n| **Ready(s)**         | The time that the thread spent in the Ready queue (due to pre-emption or CPU starvation).                                                                   |\n| **ReadyingThreadId** | The thread ID of the readying thread.                                                                                                                       |\n| **ReadyingProcess**  | The process that owns the readying thread.                                                                                                                  |\n| **ReadyThreadStack** | The stack of the readying thread.                                                                                                                           |\n| **ReadyTime (s)**    | The time when the new thread was readied.                                                                                                                   |\n| **SwitchInTime(s)**  | The time when the new thread was switched in.                                                                                                               |\n| **Waits (s)**        | The amount of time a thread waited on a logical or physical resource. The wait ends when **NewThreadId** is signaled by **ReadyingThreadId**.               |\n\n \n\n## Step 1: Capture and open a trace for a UI delay problem\n\n\nThis exercise will focus on a dummy process with an unresponsive UI. The process is a simple Windows Form application with a button and a text box. When the button is clicked, the UI becomes unresponsive for 20 seconds until the text box is updated. You will analyze the critical path of this operation.\n\n![](images/optimizingperformancelab26.png)\n\n1.  Download **UIDelay.exe** from [here](http://download.microsoft.com/download/9/C/5/9C562A35-2E52-4CAE-A662-753486C13F4A/UIDelay.exe).\n\n2.  Launch **UIDelay.exe**.\n\n3.  Open **WPR** from the **Start** menu.\n\n4.  Modify the tracing configuration.\n\n    1.  Select **First Level Triage** and **CPU Usage**.\n\n    2.  Select **General** as the performance scenario.\n\n    3.  Select **Verbose** as the detail level.\n\n        ![](images/optimizingperformancelab27.png)\n\n5.  Click on **Start**.\n\n6.  In **UIDelay.exe**, click on the **Click** button.\n\n    -   Wait until the text box shows “Done!”\n\n7.  In **WPR**, save the trace and open it with **WPA.**\n\n8.  Open the **Trace** menu and select **Configure symbols path**.\n\n    -   Specify the path of the symbol cache. For more information on symbols, see the [Symbol Support](https://go.microsoft.com/fwlink/?linkid=623019) page on MSDN.\n\n9.  Open the **Trace** menu and select **Load symbols**.\n\n## Step 2: Identify the delayed UI thread\n\n\nBefore performing critical path analysis, you must first identify the activity start and stop events.\n\n1.  Find the **UI Delays** graph in the **System Activity** node of the **Graph Explorer**.\n\n    ![](images/optimizingperformancelab28.png)\n\n2.  Drag and drop the **UI Delays** graph in the analysis tab.\n\n3.  Find the **UIDelay.exe** process.\n\n    1.  Its duration should be around 20 seconds. This indicates that there was a delay of 20 seconds on the UI thread of **UIDelay.exe**.\n\n    2.  The UI thread identifier is shown in the **Thread Id** column. In this example, it is 24174. This value will be different in the trace you’ve captured on your machine. Make sure to note the thread ID.\n\n        ![](images/optimizingperformancelab29.png)\n\n4.  Select the entire **UIDelay.exe** time interval, right-click and zoom in.\n\n    ![](images/optimizingperformancelab30.png)\n\nYou should always zoom in the regions you’re trying to analyze. It reduces the amount of noise introduced by unrelated activities.\n\n## Step 3: Analyze the UI delay critical path\n\n\nNow that you have an analysis starting point with the thread ID and the timestamps, you can start digging into the activity critical path to understand the sequence of events that lead to a 20 seconds delay on the UI thread.\n\nThe **NewThreadId** for this step is the thread you identified in Step 2 (Thread 24174 in **UIDelay.exe** process).\n\n1.  Add the **CPU Usage (Precise)** graph to the **analysis** tab and apply the **Utilization by Process, Thread** preset.\n\n    ![](images/optimizingperformancelab31.png)\n\n2.  Right-click the column headers and make the **NewThreadStack**, **ReadyThreadStack**, and **CPU Usage (ms)** columns visible.\n\n3.  Remove the **Ready (us) \\[Max\\]** and **Waits (us) \\[Max\\]** columns. Your viewport should now look like this.\n\n    ![](images/optimizingperformancelab32.png)\n\n4.  Find and expand the **UIDelay.exe** process in the **NewProcess** column and sort by **Waits (us) \\[Sum\\]** by clicking on the column header.\n\n5.  Search for the **NewThreadId** in the **UIDelay.exe** process, and analyze its time spent in the Running, Ready, or Waiting state.\n\n    -   In the following example, you can find that:\n\n        -   The thread is consuming 10.025 seconds of CPU time.\n\n        -   The thread is waiting for 5.159 seconds.\n\n        -   The thread is in the ready state for a negligible amount of time (10ms).\n\n        ![](images/optimizingperformancelab33.png)\n\n    **Note**  \n    You can analyze the 10 seconds of CPU activity using the same methodology described in Exercise 2, Step 4 using the **CPU Usage (sampled)** graph and looking at the **UIDelay.exe** process.\n\n     \n\n6.  To discover what the **NewThreadId** was waiting for, expand the **NewThreadId** group to display the **NewThreadStack**.\n\n7.  Expand **\\[Root\\]** and identify the function calls leading to waits.\n\n    ![](images/optimizingperformancelab34.png)\n\nIn this example, **UIDelay.exe** thread ID 24174 is waiting on underlying blocking function calls for 5.073 seconds when the button click function is triggered:\n\n-   5.021 seconds are due to operations underneath the **ExecuteWMICall** function.\n\n-   35 ms are due to operations underneath the **PingServer** function.\n\n### Step 3.1: Look at the ExecuteWMICall code path\n\nIf you expand the call stack further under **ExecuteWMICall**, you’ll find that the UI thread is actually sleeping for 5 seconds by explicitly calling **Thread.Sleep**.\n\n![](images/optimizingperformancelab35.png)\n\nThis kind of behavior should be avoided at all cost as it directly impacts responsiveness. If the code needs to wait for information, it should do it asynchronously on a separate thread and use an event-driven method.\n\n## Step 3.2: Look at the PingServer code\n\n\nIf you expand the call stack further under **PingServer**, you’ll find that the UI thread has I/O dependencies as it is sending **Ping** commands over the network.\n\n![](images/optimizingperformancelab36.png)\n\nWhile the delay is very small (35 ms), it should be avoided on a UI thread. Keep in mind that the average person will notice any UI delay larger than 100 ms. This operation could increase the total activity elapsed time above 100 ms, resulting in users having a bad perception of responsiveness.\n\nThose operations should happen asynchronously on a separate thread and not block the UI.\n\n \n\n \n\n\n\n\n\n\n"}