{"nodes":[{"content":"Implementing image integrity validation in custom flashing tools","pos":[34,98]},{"content":"Implementing image integrity validation in custom flashing tools","pos":[205,269]},{"content":"Implementing image integrity validation in custom flashing tools","pos":[277,341]},{"content":"The FFU image contains a signed catalog file, a hash within the catalog, and a table of hashes corresponding to each chunk of the image.","pos":[344,480]},{"content":"The hash table contents are generated using the SHA256 secure hash algorithm.","pos":[481,558]},{"content":"Three checks must be performed before the image is flashed:","pos":[559,618]},{"pos":[624,769],"content":"<bpt id=\"p1\">**</bpt>Catalog signature validation<ept id=\"p1\">**</ept> - Validating the signature of the signed catalog file helps to verify that the image came from a trusted source."},{"pos":[775,934],"content":"<bpt id=\"p1\">**</bpt>Hash of the table of hashes validation<ept id=\"p1\">**</ept> - Validating the hash of the table of hashes in the table helps to verify that the image has not been tampered with."},{"pos":[940,1116],"content":"<bpt id=\"p1\">**</bpt>Data chunk validation using the hash table entries<ept id=\"p1\">**</ept> - The FFU application must check each chunk against its corresponding chunk hash before flashing the image to the device."},{"pos":[1424,1506],"content":"Checking the signature on the catalog and checking the hash of the table of hashes"},{"content":"The goal in signature validation is to make sure that the signature in the catalog matches the PK certificate on the phone.","pos":[1509,1632]},{"content":"This approach allows checking for a signature up front without having the full image on the device before flashing.","pos":[1633,1748]},{"content":"The signature check assumes that catalog contains a SHA1 hash.","pos":[1749,1811]},{"content":"Microsoft provides a UEFI protocol which exposes a function for this purpose, EFI<ph id=\"ph1\">\\_</ph>CHECK<ph id=\"ph2\">\\_</ph>SIG<ph id=\"ph3\">\\_</ph>AND<ph id=\"ph4\">\\_</ph>HASH.","pos":[1813,1918]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>UEFI check signature protocol<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/dn772115)</ept>.","pos":[1919,2039]},{"content":"This function also validates the hash of the table of hashes.","pos":[2040,2101]},{"content":"Example code flow","pos":[2105,2122]},{"content":"Establish pointers to catalog and hash table data.","pos":[2130,2180]},{"content":"Determine the size of the catalog and hash table data in bytes.","pos":[2186,2249]},{"pos":[2255,2429],"content":"Use the <bpt id=\"p1\">[</bpt>UEFI check signature protocol<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/dn772115)</ept> to call EFI<ph id=\"ph1\">\\_</ph>CHECK<ph id=\"ph2\">\\_</ph>SIG<ph id=\"ph3\">\\_</ph>AND<ph id=\"ph4\">\\_</ph>HASH, passing the pointers and data sizes."},{"content":"Based on the EFI return code either continue to process the image, or post a security message such as EFI<ph id=\"ph1\">\\_</ph>SECURITY<ph id=\"ph2\">\\_</ph>VIOLATION.","pos":[2435,2562]},{"content":"Note","pos":[2566,2570]},{"content":"If secure boot is not enabled on the device, a signature check in not performed.","pos":[2575,2655]},{"pos":[2864,2912],"content":"Checking the data against the hash table entries"},{"content":"The OEM flashing tool must check the data against the hash table entries.","pos":[2915,2988]},{"content":"For info about the flashing tool, <bpt id=\"p1\">[</bpt>Developing custom OEM flashing tools<ept id=\"p1\">](developing-custom-oem-flashing-tools.md)</ept>.","pos":[2989,3103]},{"content":"Example code flow","pos":[3107,3124]},{"content":"A number of valid approaches can be used; an example is provided here to serve as a common point of reference.","pos":[3128,3238]},{"content":"Get the new hash data from the hash table in the image header.","pos":[3244,3306]},{"content":"Set up a loop to process chunks of data in the image.","pos":[3312,3365]},{"content":"Get a pointer to the hash of the current chunk of data.","pos":[3371,3426]},{"pos":[3432,3542],"content":"Compare the hash of the current chunk of data against the hash table data using a function such as <bpt id=\"p1\">**</bpt>memcmp<ept id=\"p1\">**</ept>."},{"content":"If the two hashes match, increment the pointer and get ready to check the next chunk of data.","pos":[3548,3641]},{"pos":[3647,3777],"content":"If the two hashes do not match, stop all processing of the image and post a security message such as <bpt id=\"p1\">**</bpt>EFI<ph id=\"ph1\">\\_</ph>SECURITY<ph id=\"ph2\">\\_</ph>VIOLATION<ept id=\"p1\">**</ept>."},{"content":"Continue processing until there is no more data in the image to process.","pos":[3783,3855]},{"pos":[3857,3946],"content":"For info on the FFU elements discussed here, see <bpt id=\"p1\">[</bpt>FFU image format<ept id=\"p1\">](ffu-image-format.md)</ept>."},{"pos":[4050,4064],"content":"Error handling"},{"content":"Standard error handling code techniques should be used.","pos":[4067,4122]},{"content":"A few common situations to handle are listed here:","pos":[4123,4173]},{"content":"Missing catalog data","pos":[4179,4199]},{"content":"Insufficient resources","pos":[4205,4227]},{"content":"Empty image","pos":[4233,4244]},{"pos":[4357,4374],"content":"Clean up and exit"},{"content":"Follow standard practice and clean up any created arrays or other objects before exiting the flashing code.","pos":[4377,4484]},{"content":"The exit process should return the final <bpt id=\"p1\">**</bpt>EFI<ph id=\"ph1\">\\_</ph>STATUS<ept id=\"p1\">**</ept> value.","pos":[4485,4548]},{"content":"For example, if the image is valid, you can return a value of <ph id=\"ph1\">`EFI_SUCCESS`</ph>.","pos":[4549,4625]},{"pos":[4741,4759],"content":"Encryption library"},{"content":"Locate and include an appropriate encryption library in the image to support hash validation, such as EFI<ph id=\"ph1\">\\_</ph>HASH<ph id=\"ph2\">\\_</ph>PROTOCOL.","pos":[4762,4884]},{"pos":[4922,4936],"content":"Related topics"},{"content":"Developing custom OEM flashing tools","pos":[4940,4976]}],"content":"---\nauthor: kpacquer\nDescription: Implementing image integrity validation in custom flashing tools\nms.assetid: 0885d221-e9c6-4fe1-987b-34781546ba07\nMSHAttr: 'PreferredLib:/library/windows/hardware'\ntitle: Implementing image integrity validation in custom flashing tools\n---\n\n# Implementing image integrity validation in custom flashing tools\n\n\nThe FFU image contains a signed catalog file, a hash within the catalog, and a table of hashes corresponding to each chunk of the image. The hash table contents are generated using the SHA256 secure hash algorithm. Three checks must be performed before the image is flashed:\n\n-   **Catalog signature validation** - Validating the signature of the signed catalog file helps to verify that the image came from a trusted source.\n\n-   **Hash of the table of hashes validation** - Validating the hash of the table of hashes in the table helps to verify that the image has not been tampered with.\n\n-   **Data chunk validation using the hash table entries** - The FFU application must check each chunk against its corresponding chunk hash before flashing the image to the device.\n\n## <span id=\"Checking_the_signature_on_the_catalog_and_checking_the_hash_of_the_table_of_hashes\"></span><span id=\"checking_the_signature_on_the_catalog_and_checking_the_hash_of_the_table_of_hashes\"></span><span id=\"CHECKING_THE_SIGNATURE_ON_THE_CATALOG_AND_CHECKING_THE_HASH_OF_THE_TABLE_OF_HASHES\"></span>Checking the signature on the catalog and checking the hash of the table of hashes\n\n\nThe goal in signature validation is to make sure that the signature in the catalog matches the PK certificate on the phone. This approach allows checking for a signature up front without having the full image on the device before flashing. The signature check assumes that catalog contains a SHA1 hash.\n\nMicrosoft provides a UEFI protocol which exposes a function for this purpose, EFI\\_CHECK\\_SIG\\_AND\\_HASH. For more information, see [UEFI check signature protocol](https://msdn.microsoft.com/library/windows/hardware/dn772115). This function also validates the hash of the table of hashes.\n\n**Example code flow**\n\n1.  Establish pointers to catalog and hash table data.\n\n2.  Determine the size of the catalog and hash table data in bytes.\n\n3.  Use the [UEFI check signature protocol](https://msdn.microsoft.com/library/windows/hardware/dn772115) to call EFI\\_CHECK\\_SIG\\_AND\\_HASH, passing the pointers and data sizes.\n\n4.  Based on the EFI return code either continue to process the image, or post a security message such as EFI\\_SECURITY\\_VIOLATION.\n\n**Note**  \nIf secure boot is not enabled on the device, a signature check in not performed.\n\n \n\n## <span id=\"Checking_the_data_against_the_hash_table_entries\"></span><span id=\"checking_the_data_against_the_hash_table_entries\"></span><span id=\"CHECKING_THE_DATA_AGAINST_THE_HASH_TABLE_ENTRIES\"></span>Checking the data against the hash table entries\n\n\nThe OEM flashing tool must check the data against the hash table entries. For info about the flashing tool, [Developing custom OEM flashing tools](developing-custom-oem-flashing-tools.md).\n\n**Example code flow**\n\nA number of valid approaches can be used; an example is provided here to serve as a common point of reference.\n\n1.  Get the new hash data from the hash table in the image header.\n\n2.  Set up a loop to process chunks of data in the image.\n\n3.  Get a pointer to the hash of the current chunk of data.\n\n4.  Compare the hash of the current chunk of data against the hash table data using a function such as **memcmp**.\n\n5.  If the two hashes match, increment the pointer and get ready to check the next chunk of data.\n\n6.  If the two hashes do not match, stop all processing of the image and post a security message such as **EFI\\_SECURITY\\_VIOLATION**.\n\n7.  Continue processing until there is no more data in the image to process.\n\nFor info on the FFU elements discussed here, see [FFU image format](ffu-image-format.md).\n\n## <span id=\"Error_handling\"></span><span id=\"error_handling\"></span><span id=\"ERROR_HANDLING\"></span>Error handling\n\n\nStandard error handling code techniques should be used. A few common situations to handle are listed here:\n\n-   Missing catalog data\n\n-   Insufficient resources\n\n-   Empty image\n\n## <span id=\"Clean_up_and_exit\"></span><span id=\"clean_up_and_exit\"></span><span id=\"CLEAN_UP_AND_EXIT\"></span>Clean up and exit\n\n\nFollow standard practice and clean up any created arrays or other objects before exiting the flashing code. The exit process should return the final **EFI\\_STATUS** value. For example, if the image is valid, you can return a value of `EFI_SUCCESS`.\n\n## <span id=\"Encryption_library\"></span><span id=\"encryption_library\"></span><span id=\"ENCRYPTION_LIBRARY\"></span>Encryption library\n\n\nLocate and include an appropriate encryption library in the image to support hash validation, such as EFI\\_HASH\\_PROTOCOL.\n\n## <span id=\"related_topics\"></span>Related topics\n\n\n[Developing custom OEM flashing tools](developing-custom-oem-flashing-tools.md)\n\n \n\n \n\n\n\n\n\n\n"}