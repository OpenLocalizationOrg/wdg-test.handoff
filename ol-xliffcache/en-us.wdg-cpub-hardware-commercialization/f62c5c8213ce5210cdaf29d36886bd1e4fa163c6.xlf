<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationtype">Human Translation</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">docset\manufacture\mobile\implementing-image-integrity-validation-in-custom-flashing-tools.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">f62c5c8213ce5210cdaf29d36886bd1e4fa163c6</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-48076a9</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Implementing image integrity validation in custom flashing tools</source>
          <target>Implementing image integrity validation in custom flashing tools</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Implementing image integrity validation in custom flashing tools</source>
          <target>Implementing image integrity validation in custom flashing tools</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Implementing image integrity validation in custom flashing tools</source>
          <target>Implementing image integrity validation in custom flashing tools</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>The FFU image contains a signed catalog file, a hash within the catalog, and a table of hashes corresponding to each chunk of the image.</source>
          <target>The FFU image contains a signed catalog file, a hash within the catalog, and a table of hashes corresponding to each chunk of the image.</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>The hash table contents are generated using the SHA256 secure hash algorithm.</source>
          <target>The hash table contents are generated using the SHA256 secure hash algorithm.</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Three checks must be performed before the image is flashed:</source>
          <target>Three checks must be performed before the image is flashed:</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Catalog signature validation</pc> - Validating the signature of the signed catalog file helps to verify that the image came from a trusted source.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Catalog signature validation</pc> - Validating the signature of the signed catalog file helps to verify that the image came from a trusted source.</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Hash of the table of hashes validation</pc> - Validating the hash of the table of hashes in the table helps to verify that the image has not been tampered with.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Hash of the table of hashes validation</pc> - Validating the hash of the table of hashes in the table helps to verify that the image has not been tampered with.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data chunk validation using the hash table entries</pc> - The FFU application must check each chunk against its corresponding chunk hash before flashing the image to the device.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data chunk validation using the hash table entries</pc> - The FFU application must check each chunk against its corresponding chunk hash before flashing the image to the device.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Checking the signature on the catalog and checking the hash of the table of hashes</source>
          <target>Checking the signature on the catalog and checking the hash of the table of hashes</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>The goal in signature validation is to make sure that the signature in the catalog matches the PK certificate on the phone.</source>
          <target>The goal in signature validation is to make sure that the signature in the catalog matches the PK certificate on the phone.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>This approach allows checking for a signature up front without having the full image on the device before flashing.</source>
          <target>This approach allows checking for a signature up front without having the full image on the device before flashing.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>The signature check assumes that catalog contains a SHA1 hash.</source>
          <target>The signature check assumes that catalog contains a SHA1 hash.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
        </originalData>
        <segment state="initial">
          <source>Microsoft provides a UEFI protocol which exposes a function for this purpose, EFI<ph dataRef="id1" id="ph1" />CHECK<ph dataRef="id2" id="ph2" />SIG<ph dataRef="id3" id="ph3" />AND<ph dataRef="id4" id="ph4" />HASH.</source>
          <target>Microsoft provides a UEFI protocol which exposes a function for this purpose, EFI<ph dataRef="id1" id="ph1" />CHECK<ph dataRef="id2" id="ph2" />SIG<ph dataRef="id3" id="ph3" />AND<ph dataRef="id4" id="ph4" />HASH.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/dn772115)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI check signature protocol</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI check signature protocol</pc>.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>This function also validates the hash of the table of hashes.</source>
          <target>This function also validates the hash of the table of hashes.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>Example code flow</source>
          <target>Example code flow</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>Establish pointers to catalog and hash table data.</source>
          <target>Establish pointers to catalog and hash table data.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>Determine the size of the catalog and hash table data in bytes.</source>
          <target>Determine the size of the catalog and hash table data in bytes.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/dn772115)</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
        </originalData>
        <segment state="initial">
          <source>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI check signature protocol</pc> to call EFI<ph dataRef="id3" id="ph1" />CHECK<ph dataRef="id4" id="ph2" />SIG<ph dataRef="id5" id="ph3" />AND<ph dataRef="id6" id="ph4" />HASH, passing the pointers and data sizes.</source>
          <target>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UEFI check signature protocol</pc> to call EFI<ph dataRef="id3" id="ph1" />CHECK<ph dataRef="id4" id="ph2" />SIG<ph dataRef="id5" id="ph3" />AND<ph dataRef="id6" id="ph4" />HASH, passing the pointers and data sizes.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
        </originalData>
        <segment state="initial">
          <source>Based on the EFI return code either continue to process the image, or post a security message such as EFI<ph dataRef="id1" id="ph1" />SECURITY<ph dataRef="id2" id="ph2" />VIOLATION.</source>
          <target>Based on the EFI return code either continue to process the image, or post a security message such as EFI<ph dataRef="id1" id="ph1" />SECURITY<ph dataRef="id2" id="ph2" />VIOLATION.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Note</source>
          <target>Note</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>If secure boot is not enabled on the device, a signature check in not performed.</source>
          <target>If secure boot is not enabled on the device, a signature check in not performed.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>Checking the data against the hash table entries</source>
          <target>Checking the data against the hash table entries</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>The OEM flashing tool must check the data against the hash table entries.</source>
          <target>The OEM flashing tool must check the data against the hash table entries.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](developing-custom-oem-flashing-tools.md)</data>
        </originalData>
        <segment state="initial">
          <source>For info about the flashing tool, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Developing custom OEM flashing tools</pc>.</source>
          <target>For info about the flashing tool, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Developing custom OEM flashing tools</pc>.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>Example code flow</source>
          <target>Example code flow</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>A number of valid approaches can be used; an example is provided here to serve as a common point of reference.</source>
          <target>A number of valid approaches can be used; an example is provided here to serve as a common point of reference.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>Get the new hash data from the hash table in the image header.</source>
          <target>Get the new hash data from the hash table in the image header.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Set up a loop to process chunks of data in the image.</source>
          <target>Set up a loop to process chunks of data in the image.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>Get a pointer to the hash of the current chunk of data.</source>
          <target>Get a pointer to the hash of the current chunk of data.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Compare the hash of the current chunk of data against the hash table data using a function such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">memcmp</pc>.</source>
          <target>Compare the hash of the current chunk of data against the hash table data using a function such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">memcmp</pc>.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>If the two hashes match, increment the pointer and get ready to check the next chunk of data.</source>
          <target>If the two hashes match, increment the pointer and get ready to check the next chunk of data.</target>
        </segment>
      </unit>
      <unit id="134">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
        </originalData>
        <segment state="initial">
          <source>If the two hashes do not match, stop all processing of the image and post a security message such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />SECURITY<ph dataRef="id4" id="ph2" />VIOLATION</pc>.</source>
          <target>If the two hashes do not match, stop all processing of the image and post a security message such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />SECURITY<ph dataRef="id4" id="ph2" />VIOLATION</pc>.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>Continue processing until there is no more data in the image to process.</source>
          <target>Continue processing until there is no more data in the image to process.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](ffu-image-format.md)</data>
        </originalData>
        <segment state="initial">
          <source>For info on the FFU elements discussed here, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FFU image format</pc>.</source>
          <target>For info on the FFU elements discussed here, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FFU image format</pc>.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Error handling</source>
          <target>Error handling</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Standard error handling code techniques should be used.</source>
          <target>Standard error handling code techniques should be used.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>A few common situations to handle are listed here:</source>
          <target>A few common situations to handle are listed here:</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>Missing catalog data</source>
          <target>Missing catalog data</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Insufficient resources</source>
          <target>Insufficient resources</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Empty image</source>
          <target>Empty image</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>Clean up and exit</source>
          <target>Clean up and exit</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Follow standard practice and clean up any created arrays or other objects before exiting the flashing code.</source>
          <target>Follow standard practice and clean up any created arrays or other objects before exiting the flashing code.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
        </originalData>
        <segment state="initial">
          <source>The exit process should return the final <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />STATUS</pc> value.</source>
          <target>The exit process should return the final <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EFI<ph dataRef="id3" id="ph1" />STATUS</pc> value.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">`EFI_SUCCESS`</data>
        </originalData>
        <segment state="initial">
          <source>For example, if the image is valid, you can return a value of <ph dataRef="id1" id="ph1" />.</source>
          <target>For example, if the image is valid, you can return a value of <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>Encryption library</source>
          <target>Encryption library</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
        </originalData>
        <segment state="initial">
          <source>Locate and include an appropriate encryption library in the image to support hash validation, such as EFI<ph dataRef="id1" id="ph1" />HASH<ph dataRef="id2" id="ph2" />PROTOCOL.</source>
          <target>Locate and include an appropriate encryption library in the image to support hash validation, such as EFI<ph dataRef="id1" id="ph1" />HASH<ph dataRef="id2" id="ph2" />PROTOCOL.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>Developing custom OEM flashing tools</source>
          <target>Developing custom OEM flashing tools</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>