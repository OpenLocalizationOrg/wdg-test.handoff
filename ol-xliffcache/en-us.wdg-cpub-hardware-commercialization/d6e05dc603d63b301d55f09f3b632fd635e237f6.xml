{"nodes":[{"content":"FFU image format","pos":[34,50]},{"content":"FFU image format","pos":[157,173]},{"content":"FFU image format","pos":[181,197]},{"content":"The following diagram shows both V1 and V2 FFU format.","pos":[200,254]},{"content":"A major changed introduced in V2 FFU format is the support for multiple data stores – each store contains sector-based data targeting a unique physical partition.","pos":[255,417]},{"pos":[585,607],"content":"Security header region"},{"content":"cbSize","pos":[685,691]},{"content":"The size of the SECURITY<ph id=\"ph1\">\\_</ph>HEADER struct.","pos":[694,734]},{"content":"Used in conjunction with the signature string to identify the FFU security header.","pos":[735,817]},{"content":"Signature string","pos":[924,940]},{"content":"A hard-coded ASCII string of \"SignedImage \" that identifies this image as a secure FFU image.","pos":[943,1036]},{"content":"Chunk size in KB","pos":[1143,1159]},{"content":"The size of chunks used to generate the hash table.","pos":[1162,1213]},{"content":"Used to break the image up into hashable chunks for validation against the hash table entries and ensure the image has not been tampered with since creation.","pos":[1214,1371]},{"content":"Hash algorithm ID","pos":[1481,1498]},{"content":"Defines which hash algorithm was used to generate the hash table.","pos":[1501,1566]},{"content":"Catalog size","pos":[1661,1673]},{"content":"The size in bytes of the catalog after the security header.","pos":[1676,1735]},{"content":"Hash table size","pos":[1839,1854]},{"content":"The size in bytes of the hash table after the security header and catalog.","pos":[1857,1931]},{"pos":[1933,1972],"content":"<bpt id=\"p1\">**</bpt>Security header<ept id=\"p1\">**</ept>, byte count: cbSize"},{"pos":[2433,2478],"content":"<bpt id=\"p1\">**</bpt>Signed Catalog<ept id=\"p1\">**</ept>, byte count: dwCatalogSize"},{"content":"A catalog file containing the hash of the hash table blob that will be signed and must match one of the certificates on the device.","pos":[2480,2611]},{"content":"This approach allows checking for a signature up front without having the full image on the device before flashing.","pos":[2612,2727]},{"content":"Streaming data is checked as it is received against the hash table entries.","pos":[2728,2803]},{"pos":[2805,2853],"content":"<bpt id=\"p1\">**</bpt>Hash table data<ept id=\"p1\">**</ept>, byte count: dwHashTableSize"},{"content":"The actual hashes for each chunk of the base image.","pos":[2855,2906]},{"content":"Chunk validation begins at the image header and ends at the end of the FFU.","pos":[2907,2982]},{"pos":[2984,3059],"content":"<bpt id=\"p1\">**</bpt>Padding<ept id=\"p1\">**</ept> - next section starts on a chunk boundary, byte count: variable"},{"content":"After the hash table padding (blank space) is added to fill out to current chunk.","pos":[3061,3142]},{"content":"This ensures that the full secure header, catalog, and hash table end at a chunk boundary and the actual image header and beyond are chunk aligned.","pos":[3143,3290]},{"pos":[3409,3428],"content":"Image header region"},{"content":"cbSize","pos":[3506,3512]},{"content":"The size in bytes of the ImageHeader struc.","pos":[3515,3558]},{"content":"Used in conjunction with the signature string to identify the FFU image header.","pos":[3559,3638]},{"content":"Signature string","pos":[3745,3761]},{"content":"A hard-coded string of \"ImageFlash \" that identifies this image as an FFU image.","pos":[3764,3844]},{"content":"Manifest Length","pos":[3948,3963]},{"content":"The size in bytes of the manifest data immediately following the image header.","pos":[3966,4044]},{"content":"Chunk size","pos":[4133,4143]},{"content":"The size of chunks used to generate the hash table.","pos":[4146,4197]},{"content":"Used to break the image up into hashable chunks for validation against the hash table entries and ensure the image has not been tampered with since creation.","pos":[4198,4355]},{"content":"This should match the chunk size in the secure header.","pos":[4356,4410]},{"content":"Used only during image validation.","pos":[4411,4445]},{"pos":[4447,4483],"content":"<bpt id=\"p1\">**</bpt>Image header<ept id=\"p1\">**</ept>, byte count: cbSize"},{"pos":[4792,4837],"content":"<bpt id=\"p1\">**</bpt>Manifest data<ept id=\"p1\">**</ept>, byte count: ManifestLength"},{"content":"The manifest contains the description of the device layout and the payload included in the FFU.","pos":[4839,4934]},{"pos":[4936,4968],"content":"<bpt id=\"p1\">**</bpt>Padding<ept id=\"p1\">**</ept> byte count: variable"},{"content":"After the manifest padding (blank space) is added to fill out to current chunk.","pos":[4970,5049]},{"content":"This ensures that the data that follows begins on a chunk boundary.","pos":[5050,5117]},{"pos":[5236,5255],"content":"Store header region"},{"pos":[5355,5367],"content":"Store header"},{"content":"<bpt id=\"p1\">**</bpt>Store header<ept id=\"p1\">**</ept>, byte count: STORE<ph id=\"ph1\">\\_</ph>HEADER<ph id=\"ph2\">\\_</ph>V1<ph id=\"ph3\">\\_</ph>0<ph id=\"ph4\">\\_</ph>SIZE (248 bytes)","pos":[5606,5674]},{"content":"The store header contains metadata that describes the payload.","pos":[5677,5739]},{"content":"This includes update type, validation size, data size, and versioning.","pos":[5740,5810]},{"content":"Some information is redundant, but is included for convenience.","pos":[5811,5874]},{"content":"The store header contains the DWORD count/length fields that describe the validation &amp; write descriptor sections.","pos":[5876,5989]},{"content":"This allows those sections to be copied out and processed later.","pos":[5991,6055]},{"content":"In V1 FFU format, you should see only one store header.","pos":[6057,6112]},{"content":"In V2 FFU format, you should expect to see a number of store headers, depending on the value defined by the NumOfStores struct.","pos":[6113,6240]},{"content":"Validation descriptor region","pos":[6383,6411]},{"content":"The validation descriptor region is a collection of VALIDATION<ph id=\"ph1\">\\_</ph>ENTRY structs.","pos":[6414,6492]},{"content":"There are dwValidateDescriptorCount of them, and the overall byte count of the region is dwValidateDescriptorLength.","pos":[6494,6610]},{"content":"Write descriptor region","pos":[6738,6761]},{"content":"The write descriptor region is a collection of BLOCK<ph id=\"ph1\">\\_</ph>DATA<ph id=\"ph2\">\\_</ph>ENTRY structs.","pos":[6764,6838]},{"content":"There are dwWriteDescriptorCount of them, and the overall size in bytes of the region is dwWriteDescriptorLength.","pos":[6840,6953]},{"content":"MajorVersion, MinorVersion","pos":[7090,7116]},{"content":"Major and minor versions of the store header.","pos":[7119,7164]},{"content":"FullFlashMajorVersion, FullFlashMinorVersion","pos":[7358,7402]},{"content":"Major and minor versions of the full flash update file format.","pos":[7406,7468]},{"content":"The following table shows the version values for V1 and V2 ffu image formats.","pos":[7470,7547]},{"content":"V1","pos":[7705,7707]},{"content":"V2","pos":[7730,7732]},{"content":"MajorVersion","pos":[7782,7794]},{"content":"1","pos":[7824,7825]},{"content":"2","pos":[7855,7856]},{"content":"MinorVersion","pos":[7909,7921]},{"content":"0","pos":[7951,7952]},{"content":"0","pos":[7982,7983]},{"content":"FullFlashMajorVersion","pos":[8037,8058]},{"content":"2","pos":[8088,8089]},{"content":"2","pos":[8119,8120]},{"content":"FullFlashMinorVersion","pos":[8173,8194]},{"content":"0","pos":[8224,8225]},{"content":"0","pos":[8255,8256]},{"content":"Note","pos":[8296,8300]},{"content":"The OEM should not flash the image to the device unless the version of the image matches these values.","pos":[8309,8411]},{"content":"NumOfStores (V2 only)","pos":[8536,8557]},{"content":"Number of stores and their payloads in this FFU.","pos":[8560,8608]},{"content":"StoreIndex (V2 only)","pos":[8727,8747]},{"content":"Current store index, starting from 1.","pos":[8750,8787]},{"content":"StorePayloadSize (V2 only)","pos":[8924,8950]},{"content":"Size of the store payload in bytes, excluding padding.","pos":[8953,9007]},{"content":"DevicePathLength (V2 only)","pos":[9144,9170]},{"content":"Size of the device path that follows, in characters, without including the terminating null character.","pos":[9173,9275]},{"content":"DevicePath (V2 only)","pos":[9394,9414]},{"content":"Actual device path that the store is targeted for.","pos":[9417,9467]},{"content":"This should be the same as device path retrieved from UEFI protocol: DEVICE<ph id=\"ph1\">\\_</ph>PATH<ph id=\"ph2\">\\_</ph>TO<ph id=\"ph3\">\\_</ph>TEXT<ph id=\"ph4\">\\_</ph>PROTOCOL.","pos":[9468,9570]},{"content":"ConvertDevicePathToText()","pos":[9571,9596]},{"pos":[11588,11606],"content":"Validation Entries"},{"pos":[11608,11712],"content":"<bpt id=\"p1\">**</bpt>Validation entries<ept id=\"p1\">**</ept>, element count: dwValidateDescriptorCount, byte count: dwValidateDescriptorLength"},{"content":"The validation section is used only for partial updates.","pos":[11714,11770]},{"content":"It contains a set of VALIDATION<ph id=\"ph1\">\\_</ph>ENTRY structs.","pos":[11771,11818]},{"content":"Each validation entry contains a byte array and a range on disk to compare.","pos":[11819,11894]},{"content":"If the data in the validation entry matches the data on disk, that validation entry is confirmed.","pos":[11895,11992]},{"content":"If and only if all validation entries are confirmed, the partial update is safe to apply to the device.","pos":[11993,12096]},{"pos":[12098,12140],"content":"<bpt id=\"p1\">**</bpt>Validation entry<ept id=\"p1\">**</ept>, byte count: variable"},{"content":"Each VALIDATION<ph id=\"ph1\">\\_</ph>ENTRY struct describes a location on disk that whose data should match the byte array in that entry.","pos":[12142,12259]},{"pos":[12574,12592],"content":"Block data entries"},{"pos":[12594,12692],"content":"<bpt id=\"p1\">**</bpt>Block data entries<ept id=\"p1\">**</ept>, element count: dwWriteDescriptorCount, byte count: dwWriteDescriptorLength"},{"content":"The block data entries describe how to write the data to disk.","pos":[12694,12756]},{"content":"It is possible to write a single area of the disk more than once or to write the same data to multiple places on the disk, allowing for a compressed payload.","pos":[12757,12914]},{"content":"The write descriptor region is composed of BLOCK<ph id=\"ph1\">\\_</ph>DATA<ph id=\"ph2\">\\_</ph>ENTRY structs.","pos":[12915,12985]},{"content":"Each entry has a size and a byte array, and an array of locations to write to disk.","pos":[12986,13069]},{"content":"The fields <bpt id=\"p1\">**</bpt>dwFlashOnlyTableIndex<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>dwFlashOnlyTableCount<ept id=\"p2\">**</ept> are used to determine the last block entry that is necessary to lay out all of the partitions required to re-flash the device.","pos":[13071,13264]},{"content":"If all of the blocks up to and including this block are successfully flashed to the device, the device can be re-flashed without requiring any silicon vendor or OEM code.","pos":[13265,13435]},{"pos":[13437,13479],"content":"<bpt id=\"p1\">**</bpt>Block data entry<ept id=\"p1\">**</ept>, byte count: variable"},{"content":"Each block data entry describes a block of data in the store data section.","pos":[13481,13555]},{"content":"Each entry describes the number of data blocks and the locations to which they should be written on disk.","pos":[13556,13661]},{"content":"The accessMethod is used like the accessMethod in SetFilePointer, meaning that it gives meaning to the blockIndex.","pos":[13662,13776]},{"pos":[14200,14207],"content":"Padding"},{"pos":[14209,14299],"content":"<bpt id=\"p1\">**</bpt>Padding<ept id=\"p1\">**</ept> – to allow the next section to start on a block boundary, byte count: variable"},{"pos":[14421,14441],"content":"Image payload region"},{"content":"The payload of block data to be written to disk, byte count: variable.","pos":[14444,14514]},{"content":"This is an array of data blocks.","pos":[14516,14548]},{"content":"Each data block consists of <bpt id=\"p1\">**</bpt>BytesPerBlock<ept id=\"p1\">**</ept> bytes, where <bpt id=\"p2\">**</bpt>BytesPerBlock<ept id=\"p2\">**</ept> is defined in the store header.","pos":[14549,14657]},{"content":"In V1 FFU format, you should see only one image payload region.","pos":[14659,14722]},{"content":"in V2 FFU format, you should expect to see a number of image payload regions depending on the value defined by the NumOfStores struct.","pos":[14723,14857]},{"pos":[14895,14909],"content":"Related topics"},{"content":"Flashing tools","pos":[14913,14927]}],"content":"---\nauthor: justinha\nDescription: FFU image format\nms.assetid: 6847ef65-becf-4a96-a4e0-6cef27dcabf7\nMSHAttr: 'PreferredLib:/library/windows/hardware'\ntitle: FFU image format\n---\n\n# FFU image format\n\n\nThe following diagram shows both V1 and V2 FFU format. A major changed introduced in V2 FFU format is the support for multiple data stores – each store contains sector-based data targeting a unique physical partition.\n\n![](images/oem-ffuv2-image-format.png)\n\n## <span id=\"Security_header_region\"></span><span id=\"security_header_region\"></span><span id=\"SECURITY_HEADER_REGION\"></span>Security header region\n\n\n<span id=\"cbSize\"></span><span id=\"cbsize\"></span><span id=\"CBSIZE\"></span>cbSize  \nThe size of the SECURITY\\_HEADER struct. Used in conjunction with the signature string to identify the FFU security header.\n\n<span id=\"Signature_string\"></span><span id=\"signature_string\"></span><span id=\"SIGNATURE_STRING\"></span>Signature string  \nA hard-coded ASCII string of \"SignedImage \" that identifies this image as a secure FFU image.\n\n<span id=\"Chunk_size_in_KB\"></span><span id=\"chunk_size_in_kb\"></span><span id=\"CHUNK_SIZE_IN_KB\"></span>Chunk size in KB  \nThe size of chunks used to generate the hash table. Used to break the image up into hashable chunks for validation against the hash table entries and ensure the image has not been tampered with since creation.\n\n<span id=\"Hash_algorithm_ID\"></span><span id=\"hash_algorithm_id\"></span><span id=\"HASH_ALGORITHM_ID\"></span>Hash algorithm ID  \nDefines which hash algorithm was used to generate the hash table.\n\n<span id=\"Catalog_size\"></span><span id=\"catalog_size\"></span><span id=\"CATALOG_SIZE\"></span>Catalog size  \nThe size in bytes of the catalog after the security header.\n\n<span id=\"Hash_table_size\"></span><span id=\"hash_table_size\"></span><span id=\"HASH_TABLE_SIZE\"></span>Hash table size  \nThe size in bytes of the hash table after the security header and catalog.\n\n**Security header**, byte count: cbSize\n\n``` syntax\n#define SECURITY_SIGNATURE \"SignedImage \"\n\ntypedef struct _SECURITY_HEADER\n{\n    UINT32 cbSize;            // size of struct, overall\n    BYTE   signature[12];     // \"SignedImage \"\n    UINT32 dwChunkSizeInKb;   // size of a hashed chunk within the image\n    UINT32 dwAlgId;           // algorithm used to hash\n    UINT32 dwCatalogSize;     // size of catalog to validate\n    UINT32 dwHashTableSize;   // size of hash table\n} SECURITY_HEADER;\n```\n\n**Signed Catalog**, byte count: dwCatalogSize\n\nA catalog file containing the hash of the hash table blob that will be signed and must match one of the certificates on the device. This approach allows checking for a signature up front without having the full image on the device before flashing. Streaming data is checked as it is received against the hash table entries.\n\n**Hash table data**, byte count: dwHashTableSize\n\nThe actual hashes for each chunk of the base image. Chunk validation begins at the image header and ends at the end of the FFU.\n\n**Padding** - next section starts on a chunk boundary, byte count: variable\n\nAfter the hash table padding (blank space) is added to fill out to current chunk. This ensures that the full secure header, catalog, and hash table end at a chunk boundary and the actual image header and beyond are chunk aligned.\n\n## <span id=\"Image_header_region\"></span><span id=\"image_header_region\"></span><span id=\"IMAGE_HEADER_REGION\"></span>Image header region\n\n\n<span id=\"cbSize\"></span><span id=\"cbsize\"></span><span id=\"CBSIZE\"></span>cbSize  \nThe size in bytes of the ImageHeader struc. Used in conjunction with the signature string to identify the FFU image header.\n\n<span id=\"Signature_string\"></span><span id=\"signature_string\"></span><span id=\"SIGNATURE_STRING\"></span>Signature string  \nA hard-coded string of \"ImageFlash \" that identifies this image as an FFU image.\n\n<span id=\"Manifest_Length\"></span><span id=\"manifest_length\"></span><span id=\"MANIFEST_LENGTH\"></span>Manifest Length  \nThe size in bytes of the manifest data immediately following the image header.\n\n<span id=\"Chunk_size\"></span><span id=\"chunk_size\"></span><span id=\"CHUNK_SIZE\"></span>Chunk size  \nThe size of chunks used to generate the hash table. Used to break the image up into hashable chunks for validation against the hash table entries and ensure the image has not been tampered with since creation. This should match the chunk size in the secure header. Used only during image validation.\n\n**Image header**, byte count: cbSize\n\n``` syntax\n#define FFU_SIGNATURE \"ImageFlash  \"\n\ntypedef struct _IMAGE_HEADER\n{\n    DWORD  cbSize;           // sizeof(ImageHeader)\n    BYTE   Signature[12];    // \"ImageFlash  \"\n    DWORD  ManifestLength;   // in bytes\n    DWORD  dwChunkSize;      // Used only during image generation.\n} ImageHeader;\n```\n\n**Manifest data**, byte count: ManifestLength\n\nThe manifest contains the description of the device layout and the payload included in the FFU.\n\n**Padding** byte count: variable\n\nAfter the manifest padding (blank space) is added to fill out to current chunk. This ensures that the data that follows begins on a chunk boundary.\n\n## <span id=\"Store_header_region\"></span><span id=\"store_header_region\"></span><span id=\"STORE_HEADER_REGION\"></span>Store header region\n\n\n### <span id=\"Store_header\"></span><span id=\"store_header\"></span><span id=\"STORE_HEADER\"></span>Store header\n\n<span id=\"Store_header__byte_count__STORE_HEADER_V1_0_SIZE__248_bytes_\"></span><span id=\"store_header__byte_count__store_header_v1_0_size__248_bytes_\"></span><span id=\"STORE_HEADER__BYTE_COUNT__STORE_HEADER_V1_0_SIZE__248_BYTES_\"></span>**Store header**, byte count: STORE\\_HEADER\\_V1\\_0\\_SIZE (248 bytes)  \nThe store header contains metadata that describes the payload. This includes update type, validation size, data size, and versioning. Some information is redundant, but is included for convenience.\n\nThe store header contains the DWORD count/length fields that describe the validation & write descriptor sections.  This allows those sections to be copied out and processed later.\n\nIn V1 FFU format, you should see only one store header. In V2 FFU format, you should expect to see a number of store headers, depending on the value defined by the NumOfStores struct.\n\n<span id=\"Validation_descriptor_region\"></span><span id=\"validation_descriptor_region\"></span><span id=\"VALIDATION_DESCRIPTOR_REGION\"></span>Validation descriptor region  \nThe validation descriptor region is a collection of VALIDATION\\_ENTRY structs.  There are dwValidateDescriptorCount of them, and the overall byte count of the region is dwValidateDescriptorLength.\n\n<span id=\"Write_descriptor_region\"></span><span id=\"write_descriptor_region\"></span><span id=\"WRITE_DESCRIPTOR_REGION\"></span>Write descriptor region  \nThe write descriptor region is a collection of BLOCK\\_DATA\\_ENTRY structs.  There are dwWriteDescriptorCount of them, and the overall size in bytes of the region is dwWriteDescriptorLength.\n\n<span id=\"MajorVersion__MinorVersion\"></span><span id=\"majorversion__minorversion\"></span><span id=\"MAJORVERSION__MINORVERSION\"></span>MajorVersion, MinorVersion  \nMajor and minor versions of the store header.\n\n<span id=\"FullFlashMajorVersion__FullFlashMinorVersion_\"></span><span id=\"fullflashmajorversion__fullflashminorversion_\"></span><span id=\"FULLFLASHMAJORVERSION__FULLFLASHMINORVERSION_\"></span>FullFlashMajorVersion, FullFlashMinorVersion   \nMajor and minor versions of the full flash update file format.\n\nThe following table shows the version values for V1 and V2 ffu image formats.\n\n<table>\n<colgroup>\n<col width=\"33%\" />\n<col width=\"33%\" />\n<col width=\"33%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\"></td>\n<td align=\"left\">V1</td>\n<td align=\"left\">V2</td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p>MajorVersion</p></td>\n<td align=\"left\"><p>1</p></td>\n<td align=\"left\"><p>2</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p>MinorVersion</p></td>\n<td align=\"left\"><p>0</p></td>\n<td align=\"left\"><p>0</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p>FullFlashMajorVersion</p></td>\n<td align=\"left\"><p>2</p></td>\n<td align=\"left\"><p>2</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p>FullFlashMinorVersion</p></td>\n<td align=\"left\"><p>0</p></td>\n<td align=\"left\"><p>0</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\n**Note**  \n-   The OEM should not flash the image to the device unless the version of the image matches these values.\n\n \n\n<span id=\"NumOfStores__V2_only_\"></span><span id=\"numofstores__v2_only_\"></span><span id=\"NUMOFSTORES__V2_ONLY_\"></span>NumOfStores (V2 only)  \nNumber of stores and their payloads in this FFU.\n\n<span id=\"StoreIndex__V2_only_\"></span><span id=\"storeindex__v2_only_\"></span><span id=\"STOREINDEX__V2_ONLY_\"></span>StoreIndex (V2 only)  \nCurrent store index, starting from 1.\n\n<span id=\"StorePayloadSize__V2_only_\"></span><span id=\"storepayloadsize__v2_only_\"></span><span id=\"STOREPAYLOADSIZE__V2_ONLY_\"></span>StorePayloadSize (V2 only)  \nSize of the store payload in bytes, excluding padding.\n\n<span id=\"DevicePathLength__V2_only_\"></span><span id=\"devicepathlength__v2_only_\"></span><span id=\"DEVICEPATHLENGTH__V2_ONLY_\"></span>DevicePathLength (V2 only)  \nSize of the device path that follows, in characters, without including the terminating null character.\n\n<span id=\"DevicePath__V2_only_\"></span><span id=\"devicepath__v2_only_\"></span><span id=\"DEVICEPATH__V2_ONLY_\"></span>DevicePath (V2 only)  \nActual device path that the store is targeted for. This should be the same as device path retrieved from UEFI protocol: DEVICE\\_PATH\\_TO\\_TEXT\\_PROTOCOL. ConvertDevicePathToText()\n\n<pre><code>\ntypedef struct _STORE_HEADER\n{\n    UINT32 dwUpdateType; // indicates partial or full flash\n    UINT16 MajorVersion, MinorVersion; // used to validate struct\n    UINT16 FullFlashMajorVersion, FullFlashMinorVersion; // FFU version, i.e. the image format\n    char szPlatformId[192]; // string which indicates what device this FFU is intended to be written to\n    UINT32 dwBlockSizeInBytes; // size of an image block in bytes – the device’s actual sector size may differ\n    UINT32 dwWriteDescriptorCount; // number of write descriptors to iterate through\n    UINT32 dwWriteDescriptorLength; // total size of all the write descriptors, in bytes (included so they can be read out up front and interpreted later)\n    UINT32 dwValidateDescriptorCount; // number of validation descriptors to check\n    UINT32 dwValidateDescriptorLength; // total size of all the validation descriptors, in bytes\n    UINT32 dwInitialTableIndex; // block index in the payload of the initial (invalid) GPT\n    UINT32 dwInitialTableCount; // count of blocks for the initial GPT, i.e. the GPT spans blockArray[idx..(idx + count -1)]\n    UINT32 dwFlashOnlyTableIndex; // first block index in the payload of the flash-only GPT (included so safe flashing can be accomplished)\n    UINT32 dwFlashOnlyTableCount; // count of blocks in the flash-only GPT\n    UINT32 dwFinalTableIndex; // index in the table of the real GPT\n    UINT32 dwFinalTableCount; // number of blocks in the real GPT\n    <b>UINT16 NumOfStores; // Total number of stores (V2 only)</b>\n    <b>UINT16 StoreIndex; // Current store index, 1-based (V2 only)</b>\n    <b>UINT64 StorePayloadSize; // Payload data only, excludes padding (V2 only)</b>\n    <b>UINT16 DevicePathLength; // Length of the device path (V2 only)</b>\n    <b>CHAR16 DevicePath[1]; // Device path has no NUL at then end (V2 only)</b>\n} STORE_HEADER;\n</code></pre>\n\n### <span id=\"Validation_Entries\"></span><span id=\"validation_entries\"></span><span id=\"VALIDATION_ENTRIES\"></span>Validation Entries\n\n**Validation entries**, element count: dwValidateDescriptorCount, byte count: dwValidateDescriptorLength\n\nThe validation section is used only for partial updates. It contains a set of VALIDATION\\_ENTRY structs. Each validation entry contains a byte array and a range on disk to compare. If the data in the validation entry matches the data on disk, that validation entry is confirmed. If and only if all validation entries are confirmed, the partial update is safe to apply to the device.\n\n**Validation entry**, byte count: variable\n\nEach VALIDATION\\_ENTRY struct describes a location on disk that whose data should match the byte array in that entry.\n\n``` syntax\ntypedef struct _VALIDATION_ENTRY\n{\n    UINT32 dwSectorIndex;\n    UINT32 dwSectorOffset;\n    UINT32 dwByteCount;\n    BYTE rgCompareData[1]; // size is dwByteCount\n} VALIDATION_ENTRY;\n```\n\n### <span id=\"Block_data_entries\"></span><span id=\"block_data_entries\"></span><span id=\"BLOCK_DATA_ENTRIES\"></span>Block data entries\n\n**Block data entries**, element count: dwWriteDescriptorCount, byte count: dwWriteDescriptorLength\n\nThe block data entries describe how to write the data to disk. It is possible to write a single area of the disk more than once or to write the same data to multiple places on the disk, allowing for a compressed payload. The write descriptor region is composed of BLOCK\\_DATA\\_ENTRY structs. Each entry has a size and a byte array, and an array of locations to write to disk.\n\nThe fields **dwFlashOnlyTableIndex** and **dwFlashOnlyTableCount** are used to determine the last block entry that is necessary to lay out all of the partitions required to re-flash the device. If all of the blocks up to and including this block are successfully flashed to the device, the device can be re-flashed without requiring any silicon vendor or OEM code.\n\n**Block data entry**, byte count: variable\n\nEach block data entry describes a block of data in the store data section. Each entry describes the number of data blocks and the locations to which they should be written on disk. The accessMethod is used like the accessMethod in SetFilePointer, meaning that it gives meaning to the blockIndex.\n\n``` syntax\nenum DISK_ACCESS_METHOD\n{\n    DISK_BEGIN  = 0,\n    DISK_END    = 2\n};\n\ntypedef struct _DISK_LOCATION\n{\n    UINT32 dwDiskAccessMethod;\n    UINT32 dwBlockIndex;\n} DISK_LOCATION; \n\ntypedef struct _BLOCK_DATA_ENTRY\n{\n    UINT32 dwLocationCount;\n    UINT32 dwBlockCount;\n    DISK_LOCATION rgDiskLocations[1];\n} BLOCK_DATA_ENTRY;\n```\n\n### <span id=\"Padding\"></span><span id=\"padding\"></span><span id=\"PADDING\"></span>Padding\n\n**Padding** – to allow the next section to start on a block boundary, byte count: variable\n\n## <span id=\"Image_payload_region\"></span><span id=\"image_payload_region\"></span><span id=\"IMAGE_PAYLOAD_REGION\"></span>Image payload region\n\n\nThe payload of block data to be written to disk, byte count: variable.\n\nThis is an array of data blocks. Each data block consists of **BytesPerBlock** bytes, where **BytesPerBlock** is defined in the store header.\n\nIn V1 FFU format, you should see only one image payload region. in V2 FFU format, you should expect to see a number of image payload regions depending on the value defined by the NumOfStores struct.\n\n## <span id=\"related_topics\"></span>Related topics\n\n\n[Flashing tools](flashing-tools.md)\n\n \n\n \n\n\n\n\n\n\n"}