{"nodes":[{"content":"Windows Firewall with Advanced Security Administration with Windows PowerShell (Windows 10)","pos":[11,102]},{"content":"Windows Firewall with Advanced Security Administration with Windows PowerShell","pos":[116,194]},{"content":"Windows Firewall with Advanced Security Administration with Windows PowerShell","pos":[301,379]},{"content":"Applies to","pos":[383,393]},{"content":"Windows 10","pos":[400,410]},{"content":"Windows Server 2016 Technical Preview","pos":[415,452]},{"content":"The Windows Firewall with Advanced Security Administration with Windows PowerShell Guide provides essential scriptlets for automating Windows Firewall with Advanced Security management.","pos":[454,639]},{"content":"It is designed for IT pros, system administrators, IT managers, and others who use and need to automate Windows Firewall with Advanced Security management in Windows.","pos":[640,806]},{"content":"You can use Windows PowerShell to manage your firewall and IPsec deployments.","pos":[808,885]},{"content":"This object-oriented scripting environment will make it easier for you to manage policies and monitor network conditions than was possible in netsh.","pos":[886,1034]},{"content":"Windows PowerShell allows network settings to be self-discoverable through the syntax and parameters in each of the cmdlets.","pos":[1035,1159]},{"content":"This guide demonstrates how common tasks were performed in netsh and how you can use Windows PowerShell to accomplish them.","pos":[1160,1283]},{"content":"In future versions of Windows, Microsoft might remove the netsh functionality for Windows Firewall with Advanced Security.","pos":[1285,1407]},{"content":"Microsoft recommends that you transition to Windows PowerShell if you currently use netsh to configure and manage Windows Firewall with Advanced Security.","pos":[1408,1562]},{"content":"Windows PowerShell and netsh command references are at the following locations.","pos":[1564,1643]},{"content":"Netsh Commands for Windows Firewall with Advanced Security","pos":[1650,1708]},{"content":"Scope","pos":[1761,1766]},{"content":"This guide does not teach you the fundamentals of Windows Firewall with Advanced Security, which can be found in <bpt id=\"p1\">[</bpt>Windows Firewall with Advanced Security<ept id=\"p1\">](windows-firewall-with-advanced-security.md)</ept>.","pos":[1768,1967]},{"content":"It does not teach the fundamentals of Windows PowerShell, and it assumes that you are familiar with the Windows PowerShell language and the basic concepts of Windows PowerShell.","pos":[1968,2145]},{"content":"For more info about Windows PowerShell concepts and usage, see the reference topics in the <bpt id=\"p1\">[</bpt>Additional resources<ept id=\"p1\">](#additional-resources)</ept> section of this guide.","pos":[2146,2305]},{"content":"Audience and user requirements","pos":[2310,2340]},{"content":"This guide is intended for IT pros, system administrators, and IT managers, and it assumes that you are familiar with Windows Firewall with Advanced Security, the Windows PowerShell language, and the basic concepts of Windows PowerShell.","pos":[2342,2579]},{"content":"In this topic","pos":[2584,2597]},{"content":"Section","pos":[2601,2608]},{"content":"Description","pos":[2611,2622]},{"content":"Set profile global defaults","pos":[2638,2665]},{"content":"Enable and control firewall behavior","pos":[2699,2735]},{"content":"Deploy basic firewall rules","pos":[2740,2767]},{"content":"How to create, modify, and delete firewall rules","pos":[2800,2848]},{"content":"Manage Remotely","pos":[2854,2869]},{"pos":[2891,2917],"content":"Remote management by using"},{"content":"Deploy basic IPsec rule settings","pos":[2937,2969]},{"content":"IPsec rules and associated parameters","pos":[3008,3045]},{"content":"Deploy secure firewall rules with IPsec","pos":[3051,3090]},{"content":"Domain and server isolation","pos":[3136,3163]},{"content":"Additional resources","pos":[3169,3189]},{"content":"More information about Windows PowerShell","pos":[3216,3257]},{"pos":[3311,3338],"content":"Set profile global defaults"},{"content":"Global defaults set the device behavior in a per-profile basis.","pos":[3340,3403]},{"content":"Windows Firewall with Advanced Security supports Domain, Private, and Public profiles.","pos":[3404,3490]},{"content":"Enable Windows Firewall","pos":[3496,3519]},{"content":"Windows Firewall drops traffic that does not correspond to allowed unsolicited traffic, or traffic that is sent in response to a request by the  device.","pos":[3521,3673]},{"content":"If you find that the rules you create are not being enforced, you may need to enable Windows Firewall.","pos":[3674,3776]},{"content":"Here is how to do this on a local domain  device:","pos":[3777,3826]},{"content":"Netsh","pos":[3830,3835]},{"content":"Windows PowerShell","pos":[3900,3918]},{"content":"Control firewall behavior","pos":[4010,4035]},{"content":"The global default settings can be defined through the command-line interface.","pos":[4037,4115]},{"content":"These modifications are also available through the Windows Firewall with Advanced Security console.","pos":[4116,4215]},{"content":"The following scriptlets set the default inbound and outbound actions, specifies protected network connections, and allows notifications to be displayed to the user when a program is blocked from receiving inbound connections.","pos":[4217,4443]},{"content":"It allows unicast response to multicast or broadcast network traffic, and it specifies logging settings for troubleshooting.","pos":[4444,4568]},{"content":"Netsh","pos":[4572,4577]},{"content":"Windows PowerShell","pos":[4930,4948]},{"content":"Deploy basic firewall rules","pos":[5175,5202]},{"content":"This section provides scriptlet examples for creating, modifying, and deleting firewall rules.","pos":[5204,5298]},{"content":"Create firewall rules","pos":[5304,5325]},{"content":"Adding a firewall rule in Windows PowerShell looks a lot like it did in Netsh, but the parameters and values are specified differently.","pos":[5327,5462]},{"content":"Here is an example of how to allow the Telnet application to listen on the network.","pos":[5464,5547]},{"content":"This firewall rule is scoped to the local subnet by using a keyword instead of an IP address.","pos":[5548,5641]},{"content":"Just like in Netsh, the rule is created on the local  device, and it becomes effective immediately.","pos":[5642,5741]},{"content":"Netsh","pos":[5745,5750]},{"content":"Windows PowerShell","pos":[5918,5936]},{"content":"The following scriptlet shows how to add a basic firewall rule that blocks outbound traffic from a specific application and local port to a Group Policy Object (GPO) in Active Directory.","pos":[6113,6299]},{"content":"In Windows PowerShell, the policy store is specified as a parameter within the <bpt id=\"p1\">**</bpt>New-NetFirewall<ept id=\"p1\">**</ept> cmdlet.","pos":[6300,6406]},{"content":"In Netsh, you must first specify the GPO that the commands in a Netsh session should modify.","pos":[6407,6499]},{"content":"The commands you enter are run against the contents of the GPO, and this remains in effect until the Netsh session is ended or until another set store command is executed.","pos":[6500,6671]},{"content":"Here, <bpt id=\"p1\">**</bpt>domain.contoso.com<ept id=\"p1\">**</ept> is the name of your Active Directory Domain Services (AD DS), and <bpt id=\"p2\">**</bpt>gpo<ph id=\"ph1\">\\_</ph>name<ept id=\"p2\">**</ept> is the name of the GPO that you want to modify.","pos":[6673,6829]},{"content":"Quotation marks are required if there are any spaces in the GPO name.","pos":[6830,6899]},{"content":"Netsh","pos":[6903,6908]},{"content":"Windows PowerShell","pos":[7142,7160]},{"content":"GPO Caching","pos":[7386,7397]},{"content":"To reduce the burden on busy domain controllers, Windows PowerShell allows you to load a GPO to your local session, make all your changes in that session, and then save it back at all once.","pos":[7399,7588]},{"content":"The following performs the same actions as the previous example (by adding a Telnet rule to a GPO), but we do so leveraging GPO caching in PowerShell.","pos":[7590,7740]},{"content":"Changing the GPO by loading it onto your local session and using the <bpt id=\"p1\">*</bpt>-GPOSession<ept id=\"p1\">*</ept> parameter are not supported in Netsh","pos":[7741,7860]},{"content":"Windows PowerShell","pos":[7862,7880]},{"content":"Note that this does not batch your individual changes, it loads and saves the entire GPO at once.","pos":[8166,8263]},{"content":"So if any other changes are made by other administrators, or in a different Windows PowerShell window, saving the GPO overwrites those changes.","pos":[8264,8407]},{"content":"Modify an existing firewall rule","pos":[8413,8445]},{"pos":[8447,8665],"content":"When a rule is created, Netsh and Windows PowerShell allow you to change rule properties and influence, but the rule maintains its unique identifier (in Windows PowerShell this is specified with the <bpt id=\"p1\">*</bpt>-Name<ept id=\"p1\">*</ept> parameter)."},{"content":"For example, you could have a rule <bpt id=\"p1\">**</bpt>Allow Web 80<ept id=\"p1\">**</ept> that enables TCP port 80 for inbound unsolicited traffic.","pos":[8667,8776]},{"content":"You can change the rule to match a different remote IP address of a Web server whose traffic will be allowed by specifying the human-readable, localized name of the rule.","pos":[8777,8947]},{"content":"Netsh","pos":[8951,8956]},{"content":"Windows PowerShell","pos":[9057,9075]},{"content":"Netsh requires you to provide the name of the rule for it to be changed and we do not have an alternate way of getting the firewall rule.","pos":[9168,9305]},{"content":"In Windows PowerShell, you can query for the rule using its known properties.","pos":[9306,9383]},{"content":"When you run <ph id=\"ph1\">`Get-NetFirewallRule`</ph>, you may notice that common conditions like addresses and ports do not appear.","pos":[9385,9498]},{"content":"These conditions are represented in separate objects called Filters.","pos":[9499,9567]},{"content":"As shown before, you can set all the conditions in New-NetFirewallRule and Set-NetFirewallRule.","pos":[9568,9663]},{"content":"If you want to query for firewall rules based on these fields (ports, addresses, security, interfaces, services), you will need to get the filter objects themselves.","pos":[9664,9829]},{"content":"You can change the remote endpoint of the <bpt id=\"p1\">**</bpt>Allow Web 80<ept id=\"p1\">**</ept> rule (as done previously) using filter objects.","pos":[9831,9937]},{"content":"Using Windows PowerShell you query by port using the port filter, then assuming additional rules exist affecting the local port, you build with further queries until your desired rule is retrieved.","pos":[9938,10135]},{"pos":[10137,10329],"content":"In the following example, we assume the query returns a single firewall rule, which is then piped to the <ph id=\"ph1\">`Set-NetFirewallRule`</ph> cmdlet utilizing Windows PowerShell’s ability to pipeline inputs."},{"content":"Windows PowerShell","pos":[10331,10349]},{"content":"You can also query for rules using the wildcard character.","pos":[10549,10607]},{"content":"The following example returns an array of firewall rules associated with a particular program.","pos":[10608,10702]},{"content":"The elements of the array can be modified in subsequent <ph id=\"ph1\">`Set-NetFirewallRule`</ph> cmdlets.","pos":[10703,10789]},{"content":"Windows PowerShell","pos":[10791,10809]},{"content":"Multiple rules in a group can be simultaneously modified when the associated group name is specified in a Set command.","pos":[10903,11021]},{"content":"You can add firewall rules to specified management groups in order to manage multiple rules that share the same influences.","pos":[11022,11145]},{"content":"In the following example, we add both inbound and outbound Telnet firewall rules to the group <bpt id=\"p1\">**</bpt>Telnet Management<ept id=\"p1\">**</ept>.","pos":[11147,11263]},{"content":"In Windows PowerShell, group membership is specified when the rules are first created so we re-create the previous example rules.","pos":[11264,11393]},{"content":"Adding rules to a custom rule group is not possible in Netsh.","pos":[11394,11455]},{"content":"Windows PowerShell","pos":[11457,11475]},{"content":"If the group is not specified at rule creation time, the rule can be added to the rule group using dot notation in Windows PowerShell.","pos":[11866,12000]},{"content":"You cannot specify the group using <ph id=\"ph1\">`Set-NetFirewallRule`</ph> since the command allows querying by rule group.","pos":[12001,12106]},{"content":"Windows PowerShell","pos":[12108,12126]},{"pos":[12271,12469],"content":"Using the <ph id=\"ph1\">`Set`</ph> command, if the rule group name is specified, the group membership is not modified but rather all rules of the group receive the same modifications indicated by the given parameters."},{"content":"The following scriptlet enables all rules in a predefined group containing remote management influencing firewall rules.","pos":[12471,12591]},{"content":"Netsh","pos":[12595,12600]},{"content":"Windows PowerShell","pos":[12714,12732]},{"pos":[12835,12955],"content":"There is also a separate <ph id=\"ph1\">`Enable-NetFirewallRule`</ph> cmdlet for enabling rules by group or by other properties of the rule."},{"content":"Windows PowerShell","pos":[12957,12975]},{"content":"Delete a firewall rule","pos":[13080,13102]},{"content":"Rule objects can be disabled so that they are no longer active.","pos":[13104,13167]},{"content":"In Windows PowerShell, the <bpt id=\"p1\">**</bpt>Disable-NetFirewallRule<ept id=\"p1\">**</ept> cmdlet will leave the rule on the system, but put it in a disabled state so the rule no longer is applied and impacts traffic.","pos":[13168,13349]},{"content":"A disabled firewall rule can be re-enabled by <bpt id=\"p1\">**</bpt>Enable-NetFirewallRule<ept id=\"p1\">**</ept>.","pos":[13350,13423]},{"content":"This is different from the <bpt id=\"p1\">**</bpt>Remove-NetFirewallRule<ept id=\"p1\">**</ept>, which permanently removes the rule definition from the device.","pos":[13424,13541]},{"content":"The following cmdlet deletes the specified existing firewall rule from the local policy store.","pos":[13543,13637]},{"content":"Netsh","pos":[13641,13646]},{"content":"Windows PowerShell","pos":[13725,13743]},{"content":"Like with other cmdlets, you can also query for rules to be removed.","pos":[13812,13880]},{"content":"Here, all blocking firewall rules are deleted from the device.","pos":[13881,13943]},{"content":"Windows PowerShell","pos":[13945,13963]},{"content":"Note that it may be safer to query the rules with the <bpt id=\"p1\">**</bpt>Get<ept id=\"p1\">**</ept> command and save it in a variable, observe the rules to be affected, then pipe them to the <bpt id=\"p2\">**</bpt>Remove<ept id=\"p2\">**</ept> command, just as we did for the <bpt id=\"p3\">**</bpt>Set<ept id=\"p3\">**</ept> commands.","pos":[14018,14231]},{"content":"The following example shows how you can view all the blocking firewall rules, and then delete the first four rules.","pos":[14232,14347]},{"content":"Windows PowerShell","pos":[14349,14367]},{"content":"Manage remotely","pos":[14463,14478]},{"content":"Remote management using WinRM is enabled by default.","pos":[14480,14532]},{"content":"The cmdlets that support the <bpt id=\"p1\">*</bpt>CimSession<ept id=\"p1\">*</ept> parameter use WinRM and can be managed remotely by default.","pos":[14533,14634]},{"pos":[14636,14744],"content":"The following example returns all firewall rules of the persistent store on a device named <bpt id=\"p1\">**</bpt>RemoteDevice<ept id=\"p1\">**</ept>."},{"content":"Windows PowerShell","pos":[14746,14764]},{"content":"We can perform any modifications or view rules on remote  devices by simply using the <bpt id=\"p1\">*</bpt>–CimSession<ept id=\"p1\">*</ept> parameter.","pos":[14827,14937]},{"content":"Here we remove a specific firewall rule from a remote device.","pos":[14938,14999]},{"content":"Windows PowerShell","pos":[15001,15019]},{"content":"Deploy basic IPsec rule settings","pos":[15184,15216]},{"content":"An Internet Protocol security (IPsec) policy consists of rules that determine IPsec behavior.","pos":[15218,15311]},{"content":"IPsec supports network-level peer authentication, data origin authentication, data integrity, data confidentiality (encryption), and replay protection.","pos":[15312,15463]},{"content":"Windows PowerShell can create powerful, complex IPsec policies like in Netsh and the Windows Firewall with Advanced Security console.","pos":[15465,15598]},{"content":"However, because Windows PowerShell is object-based rather than string token-based, configuration in Windows PowerShell offers greater control and flexibility.","pos":[15599,15758]},{"content":"In Netsh, the authentication and cryptographic sets were specified as a list of comma-separated tokens in a specific format.","pos":[15760,15884]},{"content":"In Windows PowerShell, rather than using default settings, you first create your desired authentication or cryptographic proposal objects and bundle them into lists in your preferred order.","pos":[15885,16074]},{"content":"Then, you create one or more IPsec rules that reference these sets.","pos":[16075,16142]},{"content":"The benefit of this model is that programmatic access to the information in the rules is much easier.","pos":[16143,16244]},{"content":"See the following sections for clarifying examples.","pos":[16245,16296]},{"content":"object model for creating a single ipsec rule","pos":[16300,16345]},{"content":"Create IPsec rules","pos":[16380,16398]},{"content":"The following cmdlet creates basic IPsec transport mode rule in a Group Policy Object.","pos":[16400,16486]},{"content":"An IPsec rule is simple to create; all that is required is the display name, and the remaining properties use default values.","pos":[16487,16612]},{"content":"Inbound traffic is authenticated and integrity checked using the default quick mode and main mode settings.","pos":[16613,16720]},{"content":"These default settings can be found in the console under Customize IPsec Defaults.","pos":[16721,16803]},{"content":"Netsh","pos":[16807,16812]},{"content":"Windows PowerShell","pos":[17019,17037]},{"content":"Add custom authentication methods to an IPsec rule","pos":[17163,17213]},{"content":"If you want to create a custom set of quick-mode proposals that includes both AH and ESP in an IPsec rule object, you create the associated objects separately and link their associations.","pos":[17215,17402]},{"content":"For more information about authentication methods, see <bpt id=\"p1\">[</bpt>Choosing the IPsec Protocol<ept id=\"p1\">](http://technet.microsoft.com/library/cc757847(WS.10).aspx)</ept> .","pos":[17403,17548]},{"content":"You can then use the newly created custom quick-mode policies when you create IPsec rules.","pos":[17550,17640]},{"content":"The cryptography set object is linked to an IPsec rule object.","pos":[17641,17703]},{"content":"crypto set object","pos":[17707,17724]},{"content":"In this example, we build on the previously created IPsec rule by specifying a custom quick-mode crypto set.","pos":[17751,17859]},{"content":"The final IPsec rule requires outbound traffic to be authenticated by the specified cryptography method.","pos":[17860,17964]},{"content":"Netsh","pos":[17968,17973]},{"content":"Windows PowerShell","pos":[18216,18234]},{"content":"IKEv2 IPsec transport rules","pos":[18711,18738]},{"content":"A corporate network may need to secure communications with another agency.","pos":[18740,18814]},{"content":"But, you discover the agency runs non-Windows operating systems and requires the use of the Internet Key Exchange Version 2 (IKEv2) standard.","pos":[18815,18956]},{"content":"You can leverage IKEv2 capabilities in Windows Server 2012 by simply specifying IKEv2 as the key module in an IPsec rule.","pos":[18958,19079]},{"content":"This can only be done using computer certificate authentication and cannot be used with phase 2 authentication.","pos":[19080,19191]},{"content":"Windows PowerShell","pos":[19193,19211]},{"pos":[19423,19587],"content":"For more info about IKEv2, including scenarios, see <bpt id=\"p1\">[</bpt>Securing End-to-End IPsec Connections by Using IKEv2<ept id=\"p1\">](securing-end-to-end-ipsec-connections-by-using-ikev2.md)</ept>."},{"content":"Copy an IPsec rule from one policy to another","pos":[19593,19638]},{"content":"Firewall and IPsec rules with the same rule properties can be duplicated to simplify the task of re-creating them within different policy stores.","pos":[19640,19785]},{"content":"To copy the previously created rule from one policy store to another, the associated objects must be also be copied separately.","pos":[19787,19914]},{"content":"Note that there is no need to copy associated firewall filters.","pos":[19915,19978]},{"content":"You can query rules to be copied in the same way as other cmdlets.","pos":[19979,20045]},{"content":"Copying individual rules is a task that is not possible through the Netsh interface.","pos":[20047,20131]},{"content":"Here is how you can accomplish it with Windows PowerShell.","pos":[20132,20190]},{"content":"Windows PowerShell","pos":[20192,20210]},{"content":"Handling Windows PowerShell errors","pos":[20455,20489]},{"content":"To handle errors in your Windows PowerShell scripts, you can use the <bpt id=\"p1\">*</bpt>–ErrorAction<ept id=\"p1\">*</ept> parameter.","pos":[20491,20585]},{"content":"This is especially useful with the <bpt id=\"p1\">**</bpt>Remove<ept id=\"p1\">**</ept> cmdlets.","pos":[20586,20640]},{"content":"If you want to remove a particular rule, you will notice that it fails if the rule is not found.","pos":[20641,20737]},{"content":"When removing rules, if the rule isn’t already there, it is generally acceptable to ignore that error.","pos":[20738,20840]},{"content":"In this case, you can do the following to suppress any “rule not found” errors during the remove operation.","pos":[20841,20948]},{"content":"Windows PowerShell","pos":[20950,20968]},{"content":"Note that the use of wildcards can also suppress errors, but they could potentially match rules that you did not intend to remove.","pos":[21075,21205]},{"content":"This can be a useful shortcut, but should only be used if you know there aren’t any extra rules that will be accidentally deleted.","pos":[21206,21336]},{"content":"So the following cmdlet will also remove the rule, suppressing any “not found” errors.","pos":[21337,21423]},{"content":"Windows PowerShell","pos":[21425,21443]},{"pos":[21521,21641],"content":"When using wildcards, if you want to double-check the set of rules that is matched, you can use the <bpt id=\"p1\">*</bpt>–WhatIf<ept id=\"p1\">*</ept> parameter."},{"content":"Windows PowerShell","pos":[21643,21661]},{"pos":[21747,21880],"content":"If you only want to delete some of the matched rules, you can use the <bpt id=\"p1\">*</bpt>–Confirm<ept id=\"p1\">*</ept> parameter to get a rule-by-rule confirmation prompt."},{"content":"Windows PowerShell","pos":[21882,21900]},{"content":"You can also just perform the whole operation, displaying the name of each rule as the operation is performed.","pos":[21987,22097]},{"content":"Windows PowerShell","pos":[22099,22117]},{"content":"Monitor","pos":[22208,22215]},{"content":"The following Windows PowerShell commands are useful in the update cycle of a deployment phase.","pos":[22217,22312]},{"content":"To allow you to view all the IPsec rules in a particular store, you can use the following commands.","pos":[22314,22413]},{"content":"In Netsh, this command does not show rules where profile=domain,public or profile=domain,private.","pos":[22414,22511]},{"content":"It only shows rules that have the single entry domain that is included in the rule.","pos":[22512,22595]},{"content":"The following command examples will show the IPsec rules in all profiles.","pos":[22596,22669]},{"content":"Netsh","pos":[22673,22678]},{"content":"Windows PowerShell","pos":[22742,22760]},{"content":"You can monitor main mode security associations for information such as which peers are currently connected to the device and which protection suite is used to form the security associations.","pos":[22821,23012]},{"content":"Use the following cmdlet to view existing main mode rules and their security associations:","pos":[23014,23104]},{"content":"Netsh","pos":[23108,23113]},{"content":"Windows PowerShell","pos":[23173,23191]},{"content":"Find the source GPO of a rule","pos":[23236,23265]},{"content":"To view the properties of a particular rule or group of rules, you query for the rule.","pos":[23267,23353]},{"content":"When a query returns fields that are specified as <bpt id=\"p1\">**</bpt>NotConfigured<ept id=\"p1\">**</ept>, you can to determine which policy store a rule originates from.","pos":[23354,23486]},{"pos":[23488,23730],"content":"For objects that come from a GPO (the <bpt id=\"p1\">*</bpt>–PolicyStoreSourceType<ept id=\"p1\">*</ept> parameter is specified as <bpt id=\"p2\">**</bpt>GroupPolicy<ept id=\"p2\">**</ept> in the <bpt id=\"p3\">**</bpt>Show<ept id=\"p3\">**</ept> command), if <bpt id=\"p4\">*</bpt>–TracePolicyStore<ept id=\"p4\">*</ept> is passed, the name of the GPO is found and returned in the <bpt id=\"p5\">**</bpt>PolicyStoreSource<ept id=\"p5\">**</ept> field."},{"content":"Windows PowerShell","pos":[23732,23750]},{"content":"It is important to note that the revealed sources do not contain a domain name.","pos":[23850,23929]},{"content":"Deploy a basic domain isolation policy","pos":[23935,23973]},{"content":"IPsec can be used to isolate domain members from non-domain members.","pos":[23975,24043]},{"content":"Domain isolation uses IPsec authentication to require that the domain-joined devices positively establish the identities of the communicating devices to improve security of an organization.","pos":[24044,24233]},{"content":"One or more features of IPsec can be used to secure traffic with an IPsec rule object.","pos":[24234,24320]},{"content":"To implement domain isolation on your network, the devices in the domain receive IPsec rules that block unsolicited inbound network traffic that is not protected by IPsec.","pos":[24322,24493]},{"content":"Here we create an IPsec rule that requires authentication by domain members.","pos":[24494,24570]},{"content":"Through this, you can isolate domain-joined devices from devices that are not joined to a domain.","pos":[24571,24668]},{"content":"In the following examples, Kerberos authentication is required for inbound traffic and requested for outbound traffic.","pos":[24669,24787]},{"content":"Netsh","pos":[24791,24796]},{"content":"Windows PowerShell","pos":[25050,25068]},{"content":"Configure IPsec tunnel mode","pos":[25508,25535]},{"content":"The following command creates an IPsec tunnel that routes traffic from a private network (192.168.0.0/16) through an interface on the local device (1.1.1.1) attached to a public network to a second device through its public interface (2.2.2.2) to another private network (192.157.0.0/16).","pos":[25537,25825]},{"content":"All traffic through the tunnel is checked for integrity by using ESP/SHA1, and it is encrypted by using ESP/DES3.","pos":[25826,25939]},{"content":"Netsh","pos":[25943,25948]},{"content":"Windows PowerShell","pos":[26227,26245]},{"content":"Deploy secure firewall rules with IPsec","pos":[26747,26786]},{"content":"In situations where only secure traffic can be allowed through the Windows Firewall, a combination of manually configured firewall and IPsec rules are necessary.","pos":[26788,26949]},{"content":"The firewall rules determine the level of security for allowed packets, and the underlying IPsec rules secure the traffic.","pos":[26950,27072]},{"content":"The scenarios can be accomplished in Windows PowerShell and in Netsh, with many similarities in deployment.","pos":[27073,27180]},{"content":"Create a secure firewall rule (allow if secure)","pos":[27186,27233]},{"content":"Configuring firewalls rule to allow connections if they are secure requires the corresponding traffic to be authenticated and integrity protected, and then optionally encrypted by IPsec.","pos":[27235,27421]},{"content":"The following example creates a firewall rule that requires traffic to be authenticated.","pos":[27423,27511]},{"content":"The command permits inbound Telnet network traffic only if the connection from the remote device is authenticated by using a separate IPsec rule.","pos":[27512,27657]},{"content":"Netsh","pos":[27661,27666]},{"content":"Windows PowerShell","pos":[27840,27858]},{"content":"The following command creates an IPsec rule that requires a first (computer) authentication and then attempts an optional second (user) authentication.","pos":[28039,28190]},{"content":"Creating this rule secures and allows the traffic through the firewall rule requirements for the messenger program.","pos":[28191,28306]},{"content":"Netsh","pos":[28310,28315]},{"content":"Windows PowerShell","pos":[28533,28551]},{"content":"Isolate a server by requiring encryption and group membership","pos":[29255,29316]},{"content":"To improve the security of the  devices in an organization, you can deploy domain isolation in which domain-members are restricted.","pos":[29318,29449]},{"content":"They require authentication when communicating among each other and reject non-authenticated inbound connections.","pos":[29450,29563]},{"content":"To improve the security of servers with sensitive data, this data must be protected by allowing access only to a subset of devices within the enterprise domain.","pos":[29564,29724]},{"content":"IPsec can provide this additional layer of protection by isolating the server.","pos":[29726,29804]},{"content":"In server isolation, sensitive data access is restricted to users and devices with legitimate business need, and the data is additionally encrypted to prevent eavesdropping.","pos":[29805,29978]},{"content":"Create a firewall rule that requires group membership and encryption","pos":[29984,30052]},{"content":"To deploy server isolation, we layer a firewall rule that restricts traffic to authorized users or devices on the IPsec rule that enforces authentication.","pos":[30054,30208]},{"content":"The following firewall rule allows Telnet traffic from user accounts that are members of a custom group called “Authorized to Access Server.”","pos":[30210,30351]},{"content":"This access can additionally be restricted based on the  device, user, or both by specifying the restriction parameters.","pos":[30352,30472]},{"content":"A Security Descriptor Definition Language (SDDL) string is created by extending a user or group’s security identifier (SID).","pos":[30474,30598]},{"content":"For more information about finding a group’s SID, see: <bpt id=\"p1\">[</bpt>Finding the SID for a group account<ept id=\"p1\">](http://technet.microsoft.com/library/cc753463(WS.10).aspx#bkmk_FINDSID)</ept>.","pos":[30599,30764]},{"content":"Restricting access to a group allows administrations to extend strong authentication support through Windows Firewall/and or IPsec policies.","pos":[30766,30906]},{"content":"The following example shows you how to create an SDDL string that represents security groups.","pos":[30908,31001]},{"content":"Windows PowerShell","pos":[31003,31021]},{"content":"By using the previous scriptlet, you can also get the SDDL string for a secure computer group as shown here:","pos":[31279,31387]},{"content":"Windows PowerShell","pos":[31389,31407]},{"pos":[31486,31656],"content":"For more information about how to create security groups or how to determine the SDDL string, see <bpt id=\"p1\">[</bpt>Working with SIDs<ept id=\"p1\">](http://technet.microsoft.com/library/ff730940.aspx)</ept>."},{"content":"Telnet is an application that does not provide encryption.","pos":[31658,31716]},{"content":"This application can send data, such as names and passwords, over the network.","pos":[31717,31795]},{"content":"This data can be intercepted by malicious users.","pos":[31796,31844]},{"content":"If an administrator would like to allow the use of Telnet, but protect the traffic, a firewall rule that requires IPsec encryption can be created.","pos":[31845,31991]},{"content":"This is necessary so that the administrator can be certain that when this application is used, all of the traffic sent or received by this port is encrypted.","pos":[31992,32149]},{"content":"If IPsec fails to authorize the connection, no traffic is allowed from this application.","pos":[32150,32238]},{"content":"In this example, we allow only authenticated and encrypted inbound Telnet traffic from a specified secure user group through the creation of the following firewall rule.","pos":[32240,32409]},{"content":"Netsh","pos":[32413,32418]},{"content":"Windows PowerShell","pos":[32780,32798]},{"content":"Endpoint security enforcement","pos":[33136,33165]},{"content":"The previous example showed end to end security for a particular application.","pos":[33167,33244]},{"content":"In situations where endpoint security is required for many applications, having a firewall rule per application can be cumbersome and difficult to manage.","pos":[33245,33399]},{"content":"Authorization can override the per-rule basis and be done at the IPsec layer.","pos":[33400,33477]},{"content":"In this example, we set the global IPsec setting to only allow transport mode traffic to come from an authorized user group with the following cmdlet.","pos":[33479,33629]},{"content":"Consult the previous examples for working with security groups.","pos":[33630,33693]},{"content":"Windows PowerShell","pos":[33695,33713]},{"content":"Create firewall rules that allow IPsec-protected network traffic (authenticated bypass)","pos":[33819,33906]},{"content":"Authenticated bypass allows traffic from a specified trusted  device or user to override firewall block rules.","pos":[33908,34018]},{"content":"This is helpful when an administrator wants to use scanning servers to monitor and update  devices without the need to use port-level exceptions.","pos":[34019,34164]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to enable authenticated firewall bypass<ept id=\"p1\">](http://technet.microsoft.com/library/cc753463(WS.10).aspx)</ept>.","pos":[34165,34296]},{"content":"In this example, we assume that a blocking firewall rule exists.","pos":[34298,34362]},{"content":"This example permits any network traffic on any port from any IP address to override the block rule, if the traffic is authenticated as originating from a  device or user account that is a member of the specified  device or user security group.","pos":[34363,34607]},{"content":"Netsh","pos":[34611,34616]},{"content":"Windows PowerShell","pos":[34967,34985]},{"content":"Additional resources","pos":[35251,35271]},{"content":"For more information about Windows PowerShell concepts, see the following topics.","pos":[35274,35355]},{"content":"Windows PowerShell Getting Started Guide","pos":[35362,35402]},{"content":"Windows PowerShell User Guide","pos":[35459,35488]},{"content":"Windows PowerShell About Help Topics","pos":[35545,35581]},{"content":"about<ph id=\"ph1\">\\_</ph>Functions","pos":[35638,35654]},{"content":"about<ph id=\"ph1\">\\_</ph>Functions<ph id=\"ph2\">\\_</ph>Advanced","pos":[35711,35737]},{"content":"about<ph id=\"ph1\">\\_</ph>Execution<ph id=\"ph2\">\\_</ph>Policies","pos":[35794,35820]},{"content":"about<ph id=\"ph1\">\\_</ph>Foreach","pos":[35877,35891]},{"content":"about<ph id=\"ph1\">\\_</ph>Objects","pos":[35948,35962]},{"content":"about<ph id=\"ph1\">\\_</ph>Properties","pos":[36019,36036]},{"content":"about<ph id=\"ph1\">\\_</ph>While","pos":[36093,36105]},{"content":"about<ph id=\"ph1\">\\_</ph>Scripts","pos":[36162,36176]},{"content":"about<ph id=\"ph1\">\\_</ph>Signing","pos":[36233,36247]},{"content":"about<ph id=\"ph1\">\\_</ph>Throw","pos":[36304,36316]},{"content":"about<ph id=\"ph1\">\\_</ph>PSSessions","pos":[36373,36390]},{"content":"about<ph id=\"ph1\">\\_</ph>Modules","pos":[36447,36461]},{"content":"about<ph id=\"ph1\">\\_</ph>Command<ph id=\"ph2\">\\_</ph>Precedence","pos":[36518,36544]}],"content":"---\ntitle: Windows Firewall with Advanced Security Administration with Windows PowerShell (Windows 10)\ndescription: Windows Firewall with Advanced Security Administration with Windows PowerShell\nms.prod: w10\nms.mktglfcycl: deploy\nms.sitesec: library\nms.pagetype: security\nauthor: brianlic-msft\n---\n\n# Windows Firewall with Advanced Security Administration with Windows PowerShell\n\n**Applies to**\n-   Windows 10\n-   Windows Server 2016 Technical Preview\n\nThe Windows Firewall with Advanced Security Administration with Windows PowerShell Guide provides essential scriptlets for automating Windows Firewall with Advanced Security management. It is designed for IT pros, system administrators, IT managers, and others who use and need to automate Windows Firewall with Advanced Security management in Windows.\n\nYou can use Windows PowerShell to manage your firewall and IPsec deployments. This object-oriented scripting environment will make it easier for you to manage policies and monitor network conditions than was possible in netsh. Windows PowerShell allows network settings to be self-discoverable through the syntax and parameters in each of the cmdlets. This guide demonstrates how common tasks were performed in netsh and how you can use Windows PowerShell to accomplish them.\n\nIn future versions of Windows, Microsoft might remove the netsh functionality for Windows Firewall with Advanced Security. Microsoft recommends that you transition to Windows PowerShell if you currently use netsh to configure and manage Windows Firewall with Advanced Security.\n\nWindows PowerShell and netsh command references are at the following locations.\n\n-   [Netsh Commands for Windows Firewall with Advanced Security](http://technet.microsoft.com/library/cc771920)\n\n## Scope\n\nThis guide does not teach you the fundamentals of Windows Firewall with Advanced Security, which can be found in [Windows Firewall with Advanced Security](windows-firewall-with-advanced-security.md). It does not teach the fundamentals of Windows PowerShell, and it assumes that you are familiar with the Windows PowerShell language and the basic concepts of Windows PowerShell. For more info about Windows PowerShell concepts and usage, see the reference topics in the [Additional resources](#additional-resources) section of this guide.\n\n## Audience and user requirements\n\nThis guide is intended for IT pros, system administrators, and IT managers, and it assumes that you are familiar with Windows Firewall with Advanced Security, the Windows PowerShell language, and the basic concepts of Windows PowerShell.\n\n## In this topic\n\n| Section | Description |\n| - | - |\n| [Set profile global defaults](#set-profile-global-defaults) | Enable and control firewall behavior|\n| [Deploy basic firewall rules](#deploy-basic-firewall-rules)| How to create, modify, and delete firewall rules| \n| [Manage Remotely](#manage-remotely) | Remote management by using `-CimSession`| \n| [Deploy basic IPsec rule settings](#deploy-basic-ipsec-rule-settings) | IPsec rules and associated parameters| \n| [Deploy secure firewall rules with IPsec](#deploy-secure-firewall-rules-with-ipsec) | Domain and server isolation| \n| [Additional resources](#additional-resources) | More information about Windows PowerShell| \n\n## <a href=\"\" id=\"bkmk-profileglobaldefaults\"></a>Set profile global defaults\n\nGlobal defaults set the device behavior in a per-profile basis. Windows Firewall with Advanced Security supports Domain, Private, and Public profiles.\n\n### Enable Windows Firewall\n\nWindows Firewall drops traffic that does not correspond to allowed unsolicited traffic, or traffic that is sent in response to a request by the  device. If you find that the rules you create are not being enforced, you may need to enable Windows Firewall. Here is how to do this on a local domain  device:\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set allprofiles state on\n```\n\n**Windows PowerShell**\n\n``` syntax\nSet-NetFirewallProfile -Profile Domain,Public,Private -Enabled True\n```\n\n### Control firewall behavior\n\nThe global default settings can be defined through the command-line interface. These modifications are also available through the Windows Firewall with Advanced Security console.\n\nThe following scriptlets set the default inbound and outbound actions, specifies protected network connections, and allows notifications to be displayed to the user when a program is blocked from receiving inbound connections. It allows unicast response to multicast or broadcast network traffic, and it specifies logging settings for troubleshooting.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set allprofiles firewallpolicy blockinbound,allowoutbound \nnetsh advfirewall set allprofiles settings inboundusernotification enable\nnetsh advfirewall set allprofiles settings unicastresponsetomulticast enable\nnetsh advfirewall set allprofiles logging filename %SystemRoot%\\System32\\LogFiles\\Firewall\\pfirewall.log\n```\n\nWindows PowerShell\n\n``` syntax\nSet-NetFirewallProfile -DefaultInboundAction Block -DefaultOutboundAction Allow –NotifyOnListen True -AllowUnicastResponseToMulticast True –LogFileName %SystemRoot%\\System32\\LogFiles\\Firewall\\pfirewall.log\n```\n\n## Deploy basic firewall rules\n\nThis section provides scriptlet examples for creating, modifying, and deleting firewall rules.\n\n### Create firewall rules\n\nAdding a firewall rule in Windows PowerShell looks a lot like it did in Netsh, but the parameters and values are specified differently.\n\nHere is an example of how to allow the Telnet application to listen on the network. This firewall rule is scoped to the local subnet by using a keyword instead of an IP address. Just like in Netsh, the rule is created on the local  device, and it becomes effective immediately.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall firewall add rule name=\"Allow Inbound Telnet\" dir=in program= %SystemRoot%\\System32\\tlntsvr.exe remoteip=localsubnet action=allow\n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule -DisplayName “Allow Inbound Telnet” -Direction Inbound -Program %SystemRoot%\\System32\\tlntsvr.exe -RemoteAddress LocalSubnet -Action Allow\n```\n\nThe following scriptlet shows how to add a basic firewall rule that blocks outbound traffic from a specific application and local port to a Group Policy Object (GPO) in Active Directory. In Windows PowerShell, the policy store is specified as a parameter within the **New-NetFirewall** cmdlet. In Netsh, you must first specify the GPO that the commands in a Netsh session should modify. The commands you enter are run against the contents of the GPO, and this remains in effect until the Netsh session is ended or until another set store command is executed.\n\nHere, **domain.contoso.com** is the name of your Active Directory Domain Services (AD DS), and **gpo\\_name** is the name of the GPO that you want to modify. Quotation marks are required if there are any spaces in the GPO name.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\gpo_name\nnetsh advfirewall firewall add rule name=\"Block Outbound Telnet\" dir=out program=%SystemRoot%\\System32\\telnet.exe protocol=tcp localport=23 action=block \n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule -DisplayName “Block Outbound Telnet” -Direction Outbound -Program %SystemRoot%\\System32\\tlntsvr.exe –Protocol TCP –LocalPort 23 -Action Block –PolicyStore domain.contoso.com\\gpo_name \n```\n\n### GPO Caching\n\nTo reduce the burden on busy domain controllers, Windows PowerShell allows you to load a GPO to your local session, make all your changes in that session, and then save it back at all once.\n\nThe following performs the same actions as the previous example (by adding a Telnet rule to a GPO), but we do so leveraging GPO caching in PowerShell. Changing the GPO by loading it onto your local session and using the *-GPOSession* parameter are not supported in Netsh\n\nWindows PowerShell\n\n``` syntax\n$gpo = Open-NetGPO –PolicyStore domain.contoso.com\\gpo_name\nNew-NetFirewallRule -DisplayName “Block Outbound Telnet” -Direction Outbound -Program %SystemRoot%\\System32\\telnet.exe –Protocol TCP –LocalPort 23 -Action Block –GPOSession $gpo\nSave-NetGPO –GPOSession $gpo \n```\n\nNote that this does not batch your individual changes, it loads and saves the entire GPO at once. So if any other changes are made by other administrators, or in a different Windows PowerShell window, saving the GPO overwrites those changes.\n\n### Modify an existing firewall rule\n\nWhen a rule is created, Netsh and Windows PowerShell allow you to change rule properties and influence, but the rule maintains its unique identifier (in Windows PowerShell this is specified with the *-Name* parameter).\n\nFor example, you could have a rule **Allow Web 80** that enables TCP port 80 for inbound unsolicited traffic. You can change the rule to match a different remote IP address of a Web server whose traffic will be allowed by specifying the human-readable, localized name of the rule.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall firewall set rule name=\"Allow Web 80\" new remoteip=192.168.0.2\n```\n\nWindows PowerShell\n\n``` syntax\nSet-NetFirewallRule –DisplayName “Allow Web 80” -RemoteAddress 192.168.0.2\n```\n\nNetsh requires you to provide the name of the rule for it to be changed and we do not have an alternate way of getting the firewall rule. In Windows PowerShell, you can query for the rule using its known properties.\n\nWhen you run `Get-NetFirewallRule`, you may notice that common conditions like addresses and ports do not appear. These conditions are represented in separate objects called Filters. As shown before, you can set all the conditions in New-NetFirewallRule and Set-NetFirewallRule. If you want to query for firewall rules based on these fields (ports, addresses, security, interfaces, services), you will need to get the filter objects themselves.\n\nYou can change the remote endpoint of the **Allow Web 80** rule (as done previously) using filter objects. Using Windows PowerShell you query by port using the port filter, then assuming additional rules exist affecting the local port, you build with further queries until your desired rule is retrieved.\n\nIn the following example, we assume the query returns a single firewall rule, which is then piped to the `Set-NetFirewallRule` cmdlet utilizing Windows PowerShell’s ability to pipeline inputs.\n\nWindows PowerShell\n\n``` syntax\nGet-NetFirewallPortFilter | ?{$_.LocalPort -eq 80} | Get-NetFirewallRule | ?{ $_.Direction –eq “Inbound” -and $_.Action –eq “Allow”} | Set-NetFirewallRule -RemoteAddress 192.168.0.2\n```\n\nYou can also query for rules using the wildcard character. The following example returns an array of firewall rules associated with a particular program. The elements of the array can be modified in subsequent `Set-NetFirewallRule` cmdlets.\n\nWindows PowerShell\n\n``` syntax\nGet-NetFirewallApplicationFilter -Program \"*svchost*\" | Get-NetFirewallRule\n```\n\nMultiple rules in a group can be simultaneously modified when the associated group name is specified in a Set command. You can add firewall rules to specified management groups in order to manage multiple rules that share the same influences.\n\nIn the following example, we add both inbound and outbound Telnet firewall rules to the group **Telnet Management**. In Windows PowerShell, group membership is specified when the rules are first created so we re-create the previous example rules. Adding rules to a custom rule group is not possible in Netsh.\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule -DisplayName “Allow Inbound Telnet” -Direction Inbound -Program %SystemRoot%\\System32\\tlntsvr.exe -RemoteAddress LocalSubnet -Action Allow –Group “Telnet Management”\nNew-NetFirewallRule -DisplayName “Block Outbound Telnet” -Direction Inbound -Program %SystemRoot%\\System32\\tlntsvr.exe -RemoteAddress LocalSubnet -Action Allow –Group “Telnet Management”\n```\n\nIf the group is not specified at rule creation time, the rule can be added to the rule group using dot notation in Windows PowerShell. You cannot specify the group using `Set-NetFirewallRule` since the command allows querying by rule group.\n\nWindows PowerShell\n\n``` syntax\n$rule = Get-NetFirewallRule -DisplayName “Allow Inbound Telnet” \n$rule.Group = “Telnet Management”\n$rule | Set-NetFirewallRule\n```\n\nUsing the `Set` command, if the rule group name is specified, the group membership is not modified but rather all rules of the group receive the same modifications indicated by the given parameters.\n\nThe following scriptlet enables all rules in a predefined group containing remote management influencing firewall rules.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall firewall set rule group=\"windows firewall remote management\" new enable=yes\n```\n\nWindows PowerShell\n\n``` syntax\nSet-NetFirewallRule -DisplayGroup “Windows Firewall Remote Management” –Enabled True\n```\n\nThere is also a separate `Enable-NetFirewallRule` cmdlet for enabling rules by group or by other properties of the rule.\n\nWindows PowerShell\n\n``` syntax\nEnable-NetFirewallRule -DisplayGroup “Windows Firewall Remote Management” -Verbose\n```\n\n### Delete a firewall rule\n\nRule objects can be disabled so that they are no longer active. In Windows PowerShell, the **Disable-NetFirewallRule** cmdlet will leave the rule on the system, but put it in a disabled state so the rule no longer is applied and impacts traffic. A disabled firewall rule can be re-enabled by **Enable-NetFirewallRule**. This is different from the **Remove-NetFirewallRule**, which permanently removes the rule definition from the device.\n\nThe following cmdlet deletes the specified existing firewall rule from the local policy store.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall firewall delete rule name=“Allow Web 80”\n```\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Allow Web 80”\n```\n\nLike with other cmdlets, you can also query for rules to be removed. Here, all blocking firewall rules are deleted from the device.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –Action Block\n```\n\nNote that it may be safer to query the rules with the **Get** command and save it in a variable, observe the rules to be affected, then pipe them to the **Remove** command, just as we did for the **Set** commands. The following example shows how you can view all the blocking firewall rules, and then delete the first four rules.\n\nWindows PowerShell\n\n``` syntax\n$x = Get-NetFirewallRule –Action Block\n$x\n$x[0-3] | Remove-NetFirewallRule\n```\n\n## Manage remotely\n\nRemote management using WinRM is enabled by default. The cmdlets that support the *CimSession* parameter use WinRM and can be managed remotely by default.\n\nThe following example returns all firewall rules of the persistent store on a device named **RemoteDevice**.\n\nWindows PowerShell\n\n``` syntax\nGet-NetFirewallRule –CimSession RemoteDevice\n```\n\nWe can perform any modifications or view rules on remote  devices by simply using the *–CimSession* parameter. Here we remove a specific firewall rule from a remote device.\n\nWindows PowerShell\n\n``` syntax\n$RemoteSession = New-CimSession –ComputerName RemoteDevice\nRemove-NetFirewallRule –DisplayName “AllowWeb80” –CimSession $RemoteSession -Confirm\n```\n\n## Deploy basic IPsec rule settings\n\nAn Internet Protocol security (IPsec) policy consists of rules that determine IPsec behavior. IPsec supports network-level peer authentication, data origin authentication, data integrity, data confidentiality (encryption), and replay protection.\n\nWindows PowerShell can create powerful, complex IPsec policies like in Netsh and the Windows Firewall with Advanced Security console. However, because Windows PowerShell is object-based rather than string token-based, configuration in Windows PowerShell offers greater control and flexibility.\n\nIn Netsh, the authentication and cryptographic sets were specified as a list of comma-separated tokens in a specific format. In Windows PowerShell, rather than using default settings, you first create your desired authentication or cryptographic proposal objects and bundle them into lists in your preferred order. Then, you create one or more IPsec rules that reference these sets. The benefit of this model is that programmatic access to the information in the rules is much easier. See the following sections for clarifying examples.\n\n![object model for creating a single ipsec rule](images/createipsecrule.gif)\n\n### Create IPsec rules\n\nThe following cmdlet creates basic IPsec transport mode rule in a Group Policy Object. An IPsec rule is simple to create; all that is required is the display name, and the remaining properties use default values. Inbound traffic is authenticated and integrity checked using the default quick mode and main mode settings. These default settings can be found in the console under Customize IPsec Defaults.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\gpo_name\nnetsh advfirewall consec add rule name=\"Require Inbound Authentication\" endpoint1=any endpoint2=any action=requireinrequestout\n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetIPsecRule -DisplayName “Require Inbound Authentication” -PolicyStore domain.contoso.com\\gpo_name\n```\n\n### Add custom authentication methods to an IPsec rule\n\nIf you want to create a custom set of quick-mode proposals that includes both AH and ESP in an IPsec rule object, you create the associated objects separately and link their associations. For more information about authentication methods, see [Choosing the IPsec Protocol](http://technet.microsoft.com/library/cc757847(WS.10).aspx) .\n\nYou can then use the newly created custom quick-mode policies when you create IPsec rules. The cryptography set object is linked to an IPsec rule object.\n\n![crypto set object](images/qmcryptoset.gif)\n\nIn this example, we build on the previously created IPsec rule by specifying a custom quick-mode crypto set. The final IPsec rule requires outbound traffic to be authenticated by the specified cryptography method.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\gpo_name\nnetsh advfirewall consec add rule name=\"Require Outbound Authentication\" endpoint1=any endpoint2=any action=requireinrequestout qmsecmethods=ah:sha1+esp:sha1-3des\n```\n\nWindows PowerShell\n\n``` syntax\n$AHandESPQM = New-NetIPsecQuickModeCryptoProposal -Encapsulation AH,ESP –AHHash SHA1 -ESPHash SHA1 -Encryption DES3\n$QMCryptoSet = New-NetIPsecQuickModeCryptoSet –DisplayName “ah:sha1+esp:sha1-des3” -Proposal $AHandESPQM –PolicyStore domain.contoso.com\\gpo_name\nNew-NetIPsecRule -DisplayName “Require Inbound Authentication” -InboundSecurity Require -OutboundSecurity Request -QuickModeCryptoSet $QMCryptoSet.Name –PolicyStore domain.contoso.com\\gpo_name\n```\n\n### IKEv2 IPsec transport rules\n\nA corporate network may need to secure communications with another agency. But, you discover the agency runs non-Windows operating systems and requires the use of the Internet Key Exchange Version 2 (IKEv2) standard.\n\nYou can leverage IKEv2 capabilities in Windows Server 2012 by simply specifying IKEv2 as the key module in an IPsec rule. This can only be done using computer certificate authentication and cannot be used with phase 2 authentication.\n\nWindows PowerShell\n\n``` syntax\nNew-NetIPsecRule -DisplayName “Require Inbound Authentication” -InboundSecurity Require -OutboundSecurity Request –Phase1AuthSet MyCertAuthSet -KeyModule IKEv2 –RemoteAddress $nonWindowsGateway\n```\n\nFor more info about IKEv2, including scenarios, see [Securing End-to-End IPsec Connections by Using IKEv2](securing-end-to-end-ipsec-connections-by-using-ikev2.md).\n\n### Copy an IPsec rule from one policy to another\n\nFirewall and IPsec rules with the same rule properties can be duplicated to simplify the task of re-creating them within different policy stores.\n\nTo copy the previously created rule from one policy store to another, the associated objects must be also be copied separately. Note that there is no need to copy associated firewall filters. You can query rules to be copied in the same way as other cmdlets.\n\nCopying individual rules is a task that is not possible through the Netsh interface. Here is how you can accomplish it with Windows PowerShell.\n\nWindows PowerShell\n\n``` syntax\n$Rule = Get-NetIPsecRule –DisplayName “Require Inbound Authentication”\n$Rule | Copy-NetIPsecRule –NewPolicyStore domain.costoso.com\\new_gpo_name\n$Rule | Copy-NetPhase1AuthSet –NewPolicyStore domain.costoso.com\\new_gpo_name\n```\n\n### Handling Windows PowerShell errors\n\nTo handle errors in your Windows PowerShell scripts, you can use the *–ErrorAction* parameter. This is especially useful with the **Remove** cmdlets. If you want to remove a particular rule, you will notice that it fails if the rule is not found. When removing rules, if the rule isn’t already there, it is generally acceptable to ignore that error. In this case, you can do the following to suppress any “rule not found” errors during the remove operation.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Contoso Messenger 98” –ErrorAction SilentlyContinue\n```\n\nNote that the use of wildcards can also suppress errors, but they could potentially match rules that you did not intend to remove. This can be a useful shortcut, but should only be used if you know there aren’t any extra rules that will be accidentally deleted. So the following cmdlet will also remove the rule, suppressing any “not found” errors.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Contoso Messenger 98*”\n```\n\nWhen using wildcards, if you want to double-check the set of rules that is matched, you can use the *–WhatIf* parameter.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Contoso Messenger 98*” –WhatIf\n```\n\nIf you only want to delete some of the matched rules, you can use the *–Confirm* parameter to get a rule-by-rule confirmation prompt.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Contoso Messenger 98*” –Confirm\n```\n\nYou can also just perform the whole operation, displaying the name of each rule as the operation is performed.\n\nWindows PowerShell\n\n``` syntax\nRemove-NetFirewallRule –DisplayName “Contoso Messenger 98*” –Verbose\n```\n\n### Monitor\n\nThe following Windows PowerShell commands are useful in the update cycle of a deployment phase.\n\nTo allow you to view all the IPsec rules in a particular store, you can use the following commands. In Netsh, this command does not show rules where profile=domain,public or profile=domain,private. It only shows rules that have the single entry domain that is included in the rule. The following command examples will show the IPsec rules in all profiles.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall consec show rule name=all\n```\n\nWindows PowerShell\n\n``` syntax\nShow-NetIPsecRule –PolicyStore ActiveStore\n```\n\nYou can monitor main mode security associations for information such as which peers are currently connected to the device and which protection suite is used to form the security associations.\n\nUse the following cmdlet to view existing main mode rules and their security associations:\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall monitor show mmsa all\n```\n\nWindows PowerShell\n\n``` syntax\nGet-NetIPsecMainModeSA\n```\n\n### Find the source GPO of a rule\n\nTo view the properties of a particular rule or group of rules, you query for the rule. When a query returns fields that are specified as **NotConfigured**, you can to determine which policy store a rule originates from.\n\nFor objects that come from a GPO (the *–PolicyStoreSourceType* parameter is specified as **GroupPolicy** in the **Show** command), if *–TracePolicyStore* is passed, the name of the GPO is found and returned in the **PolicyStoreSource** field.\n\nWindows PowerShell\n\n``` syntax\nGet-NetIPsecRule –DisplayName “Require Inbound Authentication” –TracePolicyStore \n```\n\nIt is important to note that the revealed sources do not contain a domain name.\n\n### Deploy a basic domain isolation policy\n\nIPsec can be used to isolate domain members from non-domain members. Domain isolation uses IPsec authentication to require that the domain-joined devices positively establish the identities of the communicating devices to improve security of an organization. One or more features of IPsec can be used to secure traffic with an IPsec rule object.\n\nTo implement domain isolation on your network, the devices in the domain receive IPsec rules that block unsolicited inbound network traffic that is not protected by IPsec. Here we create an IPsec rule that requires authentication by domain members. Through this, you can isolate domain-joined devices from devices that are not joined to a domain. In the following examples, Kerberos authentication is required for inbound traffic and requested for outbound traffic.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\domain_isolation\nnetsh advfirewall consec add rule name=“Basic Domain Isolation Policy” profile=domain endpoint1=”any” endpoint2=”any” action=requireinrequestout auth1=”computerkerb”\n```\n\nWindows PowerShell\n\n``` syntax\n$kerbprop = New-NetIPsecAuthProposal –Machine –Kerberos\n$Phase1AuthSet = New-NetIPsecPhase1AuthSet -DisplayName \"Kerberos Auth Phase1\" -Proposal $kerbprop –PolicyStore domain.contoso.com\\domain_isolation\nNew-NetIPsecRule –DisplayName “Basic Domain Isolation Policy” –Profile Domain –Phase1AuthSet $Phase1AuthSet.Name –InboundSecurity Require –OutboundSecurity Request –PolicyStore domain.contoso.com\\domain_isolation \n```\n\n### Configure IPsec tunnel mode\n\nThe following command creates an IPsec tunnel that routes traffic from a private network (192.168.0.0/16) through an interface on the local device (1.1.1.1) attached to a public network to a second device through its public interface (2.2.2.2) to another private network (192.157.0.0/16). All traffic through the tunnel is checked for integrity by using ESP/SHA1, and it is encrypted by using ESP/DES3.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall consec add rule name=\"Tunnel from 192.168.0.0/16 to 192.157.0.0/16\" mode=tunnel endpoint1=192.168.0.0/16 endpoint2=192.157.0.0/16 localtunnelendpoint=1.1.1.1 remotetunnelendpoint=2.2.2.2 action=requireinrequireout qmsecmethods=esp:sha1-3des\n```\n\nWindows PowerShell\n\n``` syntax\n$QMProposal = New-NetIPsecQuickModeCryptoProposal -Encapsulation ESP -ESPHash SHA1 -Encryption DES3\n$QMCryptoSet = New-NetIPsecQuickModeCryptoSet –DisplayName “esp:sha1-des3” -Proposal $QMProposal\nNew-NetIPSecRule -DisplayName “Tunnel from HQ to Dallas Branch” -Mode Tunnel -LocalAddress 192.168.0.0/16 -RemoteAddress 192.157.0.0/16 -LocalTunnelEndpoint 1.1.1.1 -RemoteTunnelEndpoint 2.2.2.2 -InboundSecurity Require -OutboundSecurity Require -QuickModeCryptoSet $QMCryptoSet.Name\n```\n\n## Deploy secure firewall rules with IPsec\n\nIn situations where only secure traffic can be allowed through the Windows Firewall, a combination of manually configured firewall and IPsec rules are necessary. The firewall rules determine the level of security for allowed packets, and the underlying IPsec rules secure the traffic. The scenarios can be accomplished in Windows PowerShell and in Netsh, with many similarities in deployment.\n\n### Create a secure firewall rule (allow if secure)\n\nConfiguring firewalls rule to allow connections if they are secure requires the corresponding traffic to be authenticated and integrity protected, and then optionally encrypted by IPsec.\n\nThe following example creates a firewall rule that requires traffic to be authenticated. The command permits inbound Telnet network traffic only if the connection from the remote device is authenticated by using a separate IPsec rule.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall firewall add rule name=\"Allow Authenticated Telnet\" dir=in program=%SystemRoot%\\System32\\tlntsvr.exe security=authenticate action=allow\n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule -DisplayName “Allow Authenticated Telnet” -Direction Inbound -Program %SystemRoot%\\System32\\tlntsvr.exe -Authentication Required -Action Allow\n```\n\nThe following command creates an IPsec rule that requires a first (computer) authentication and then attempts an optional second (user) authentication. Creating this rule secures and allows the traffic through the firewall rule requirements for the messenger program.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall consec add rule name=\"Authenticate Both Computer and User\" endpoint1=any endpoint2=any action=requireinrequireout auth1=computerkerb,computerntlm auth2=userkerb,userntlm,anonymous\n```\n\nWindows PowerShell\n\n``` syntax\n$mkerbauthprop = New-NetIPsecAuthProposal -Machine –Kerberos\n$mntlmauthprop = New-NetIPsecAuthProposal -Machine -NTLM\n$P1Auth = New-NetIPsecPhase1AuthSet -DisplayName “Machine Auth” –Proposal $mkerbauthprop,$mntlmauthprop\n$ukerbauthprop = New-NetIPsecAuthProposal -User -Kerberos\n$unentlmauthprop = New-NetIPsecAuthProposal -User -NTLM\n$anonyauthprop = New-NetIPsecAuthProposal -Anonymous\n$P2Auth = New-NetIPsecPhase2AuthSet -DisplayName “User Auth” -Proposal $ukerbauthprop,$unentlmauthprop,$anonyauthprop\nNew-NetIPSecRule -DisplayName “Authenticate Both Computer and User” -InboundSecurity Require -OutboundSecurity Require -Phase1AuthSet $P1Auth.Name –Phase2AuthSet $P2Auth.Name\n```\n\n### Isolate a server by requiring encryption and group membership\n\nTo improve the security of the  devices in an organization, you can deploy domain isolation in which domain-members are restricted. They require authentication when communicating among each other and reject non-authenticated inbound connections. To improve the security of servers with sensitive data, this data must be protected by allowing access only to a subset of devices within the enterprise domain.\n\nIPsec can provide this additional layer of protection by isolating the server. In server isolation, sensitive data access is restricted to users and devices with legitimate business need, and the data is additionally encrypted to prevent eavesdropping.\n\n### Create a firewall rule that requires group membership and encryption\n\nTo deploy server isolation, we layer a firewall rule that restricts traffic to authorized users or devices on the IPsec rule that enforces authentication.\n\nThe following firewall rule allows Telnet traffic from user accounts that are members of a custom group called “Authorized to Access Server.” This access can additionally be restricted based on the  device, user, or both by specifying the restriction parameters.\n\nA Security Descriptor Definition Language (SDDL) string is created by extending a user or group’s security identifier (SID). For more information about finding a group’s SID, see: [Finding the SID for a group account](http://technet.microsoft.com/library/cc753463(WS.10).aspx#bkmk_FINDSID).\n\nRestricting access to a group allows administrations to extend strong authentication support through Windows Firewall/and or IPsec policies.\n\nThe following example shows you how to create an SDDL string that represents security groups.\n\nWindows PowerShell\n\n``` syntax\n$user = new-object System.Security.Principal.NTAccount (“corp.contoso.com\\Administrators”)\n$SIDofSecureUserGroup = $user.Translate([System.Security.Principal.SecurityIdentifier]).Value\n$secureUserGroup = \"D:(A;;CC;;;$SIDofSecureUserGroup)\"\n```\n\nBy using the previous scriptlet, you can also get the SDDL string for a secure computer group as shown here:\n\nWindows PowerShell\n\n``` syntax\n$secureMachineGroup = \"D:(A;;CC;;;$SIDofSecureMachineGroup)\"\n```\n\nFor more information about how to create security groups or how to determine the SDDL string, see [Working with SIDs](http://technet.microsoft.com/library/ff730940.aspx).\n\nTelnet is an application that does not provide encryption. This application can send data, such as names and passwords, over the network. This data can be intercepted by malicious users. If an administrator would like to allow the use of Telnet, but protect the traffic, a firewall rule that requires IPsec encryption can be created. This is necessary so that the administrator can be certain that when this application is used, all of the traffic sent or received by this port is encrypted. If IPsec fails to authorize the connection, no traffic is allowed from this application.\n\nIn this example, we allow only authenticated and encrypted inbound Telnet traffic from a specified secure user group through the creation of the following firewall rule.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\Server_Isolation\nnetsh advfirewall firewall add rule name=“Allow Encrypted Inbound Telnet to Group Members Only” program=%SystemRoot%\\System32\\tlntsvr.exe protocol=TCP dir=in action=allow localport=23 security=authenc rmtusrgrp =\"D:(A;;CC;;; S-1-5-21-2329867823-2610410949-1491576313-1735)\"\n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule -DisplayName \"Allow Encrypted Inbound Telnet to Group Members Only\" -Program %SystemRoot%\\System32\\tlntsvr.exe -Protocol TCP -Direction Inbound -Action Allow -LocalPort 23 -Authentication Required -Encryption Required –RemoteUser $secureUserGroup –PolicyStore domain.contoso.com\\Server_Isolation\n```\n\n### Endpoint security enforcement\n\nThe previous example showed end to end security for a particular application. In situations where endpoint security is required for many applications, having a firewall rule per application can be cumbersome and difficult to manage. Authorization can override the per-rule basis and be done at the IPsec layer.\n\nIn this example, we set the global IPsec setting to only allow transport mode traffic to come from an authorized user group with the following cmdlet. Consult the previous examples for working with security groups.\n\nWindows PowerShell\n\n``` syntax\nSet-NetFirewallSetting -RemoteMachineTransportAuthorizationList $secureMachineGroup\n```\n\n### Create firewall rules that allow IPsec-protected network traffic (authenticated bypass)\n\nAuthenticated bypass allows traffic from a specified trusted  device or user to override firewall block rules. This is helpful when an administrator wants to use scanning servers to monitor and update  devices without the need to use port-level exceptions. For more information, see [How to enable authenticated firewall bypass](http://technet.microsoft.com/library/cc753463(WS.10).aspx).\n\nIn this example, we assume that a blocking firewall rule exists. This example permits any network traffic on any port from any IP address to override the block rule, if the traffic is authenticated as originating from a  device or user account that is a member of the specified  device or user security group.\n\n**Netsh**\n\n``` syntax\nnetsh advfirewall set store gpo=domain.contoso.com\\domain_isolation\nnetsh advfirewall firewall add rule name=\"Inbound Secure Bypass Rule\" dir=in security=authenticate action=\"bypass\" rmtcomputergrp=\"D:(A;;CC;;;S-1-5-21-2329867823-2610410949-1491576313-1114)\" rmtusrgrp=\"D:(A;;CC;;; S-1-5-21-2329867823-2610410949-1491576313-1735)\"\n```\n\nWindows PowerShell\n\n``` syntax\nNew-NetFirewallRule –DisplayName “Inbound Secure Bypass Rule\" –Direction Inbound –Authentication Required –OverrideBlockRules $true -RemoteMachine $secureMachineGroup –RemoteUser $secureUserGroup –PolicyStore domain.contoso.com\\domain_isolation\n```\n\n## Additional resources\n\n\nFor more information about Windows PowerShell concepts, see the following topics.\n\n-   [Windows PowerShell Getting Started Guide](http://go.microsoft.com/fwlink/p/?linkid=113440)\n\n-   [Windows PowerShell User Guide](http://go.microsoft.com/fwlink/p/?linkid=113441)\n\n-   [Windows PowerShell About Help Topics](http://go.microsoft.com/fwlink/p/?linkid=113206)\n\n-   [about\\_Functions](http://go.microsoft.com/fwlink/p/?linkid=113231)\n\n-   [about\\_Functions\\_Advanced](http://go.microsoft.com/fwlink/p/?linkid=144511)\n\n-   [about\\_Execution\\_Policies](http://go.microsoft.com/fwlink/p/?linkid=135170)\n\n-   [about\\_Foreach](http://go.microsoft.com/fwlink/p/?linkid=113229)\n\n-   [about\\_Objects](http://go.microsoft.com/fwlink/p/?linkid=113241)\n\n-   [about\\_Properties](http://go.microsoft.com/fwlink/p/?linkid=113249)\n\n-   [about\\_While](http://go.microsoft.com/fwlink/p/?linkid=113275)\n\n-   [about\\_Scripts](http://go.microsoft.com/fwlink/p/?linkid=144310)\n\n-   [about\\_Signing](http://go.microsoft.com/fwlink/p/?linkid=113268)\n\n-   [about\\_Throw](http://go.microsoft.com/fwlink/p/?linkid=145153)\n\n-   [about\\_PSSessions](http://go.microsoft.com/fwlink/p/?linkid=135181)\n\n-   [about\\_Modules](http://go.microsoft.com/fwlink/p/?linkid=144311)\n\n-   [about\\_Command\\_Precedence](http://go.microsoft.com/fwlink/p/?linkid=113214)\n\n \n\n \n\n\n\n\n\n"}